Web Services and Service-Oriented Architecture

Web services and service-oriented architecture (hereafter, SOA) are related but distinct.
SOA, like REST itself, is more an architectural style--indeed, a mindset--than a body of 
well-defined rules for the design and implementation of distributed systems; and web services are a 
natural, important way to provide the services at the core of any SOA system. A fundamental idea in
SOA is that an application results from integrating network-accessible services, which are 
interoperable because each has an interface that clearly defines the operations encapsulated in the
service: per operation, the interface specifies the number and type of each argument
passed to the service operation together with the number and type of values returned from each service
operation. At the implementation level, a service operation is thus a function call. 
The simplicity of service operations promotes code reuse through the composition of new services out of 
existing ones and enables relatively straightforward troubleshooting because services reduce to
primitive function calls. Perhaps the best way to clarify SOA is to contrast this approach to distributed 
systems with a preceding approach.

A Very Short History of Web Services

Web services evolved from the RPC (Remote Procedure Call) mechanism in
DCE (Distributed Computing Environment), a framework for software development
that emerged in the early 1990s. DCE includes a distributed file system
DCE/DFS) and a Kerberos-based authentication system. Although DCE has its
origins in the Unix world, Microsoft quickly did its own implementation
known as MSRPC, which in turn served as the infrastructure for interprocess communication in Windows. 
Microsoft's COM/OLE (Common Object Model/Object Linking and Embedding) technologies and services 
were built on a DCE/RPC foundation. The first-generation frameworks for distributed-object systems, 
CORBA (Common Object Request Broker Architecture) and Microsoft's DCOM (Distributed COM), are anchored 
in the DCE/RPC procedural framework. Java RMI (Remote Method Invocation) also derives from DCE/RPC; and the 
method calls in Java EE (Enterprise Editition), specially in Session and Entity EJBs (Enterprise Java Bean), 
are Java RMI calls. Java EE (formerly J2EE) and Microsoft's DotNet are second-generation frameworks for 
distributed-object systems; and these frameworks, like CORBA and DCOM before them, trace
their ancestry back to DCE/RPC. By the way, DCE/RPC is not dead. Various popular system utilities (for 
instance, the Samba file and print service for Windows clients) are DCE/RPC.

DCE/RPC has the familiar client/server architecture in which a
client invokes a procedure that executes on the server. Arguments can be
passed from the client to the server and return values can be passed from
the server to the client. The framework is platform and language neutral in principle,
although strongly biased towards C/C++ in practice. DCE/RPC includes
utilities for generating client and server artifacts (stubs and skeletons,
respectively) and software libraries that hide the transport details. Of
interest now is the IDL (Interface Definition Language) document that acts as the 
service contract and is an input to utilities that generate artifacts in support
of the DCE/RPC calls. Here is a simple IDL file:

/* echo.idl */
[uuid(2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]
interface echo {
    const long int ECHO_SIZE = 512;
    void echo(
        [in]             handle_t h,
        [in,  string]    idl_char from_client[ ],
        [out, string]    idl_char from_server[ECHO_SIZE]
    );
}

The interface, identified with a machine-generated UUID (Universally Unique IDentifier), 
declares a single function of three arguments, two of which are
in parameters (that is, inputs to the remote procedure) and one of which is an out parameter (that
is, an output from the remote procedure). The first argument, of defined
type handle_t, is required and points to an RPC data structure. The function echo could but does
not return a value because the echoed string is returned instead as an out parameter. The IDL specifies 
the invocation syntax for the echo function, which is the one and only operation in the service.

In the late 1990s, Dave Winer of UserLand Software developed XML-RPC, a technology often cited
as the birth of web services. XML-RPC is a very lightweight RPC system with support for
elementary data types (basically, the built-in C types together with a
boolean and a datetime type) and a few simple commands. The original specification is about seven 
pages in length. The two key features are the use of XML marshaling/unmarshaling
to achieve language neutrality and reliance on HTTP (and, later, SMTP)
for transport. Marshaling refers to the conversion of an in-memory object (for instance, an
Employee object in Java) to some other format, for instance, an XML document; and unmarshaling
references to the inverse process of generating an in-memory object from, in this example,
an XML document. The O'Reilly open-wire Meerkat service is an XML-RPC application.

As an RPC technology, XML-RPC supports the request/response pattern. Here is the XML request from 
an invocation of the Fibonacci function with an argument of 11, which is passed as a four-byte
integer.

<?xml version="1.0">
<methodCall>
   <methodName>fib<methodName>
   <params>
     <param><value><i4>11</i4></value></param>
   </params>
</methodCall>

XML-RPC is deliberately low fuss and lightweight. SOAP, an XML dialect derived from XML-RPC, is 
considerably heavier in weight. From inception, XML-RPC faced competition from DOA-based systems 
such as Java EE (J2EE) and AspNet.

Distributed Object Architecture: The Java Example

Java RMI, including the Session and Entity EJB constructs built on
it, and DotNet Remoting are examples of second-generation distributed
object systems. Consider what a Java RMI client requires to invoke a
method declared in a service interface such as this:

package doa; // distributed object architecture
import java.util.List;

public interface BenefitsService extends java.rmi.Remote {
   public List<EmpBenefits> getBenefits(Emp emp) throws RemoteException;
}

A client against this service needs a Java RMI stub, an instance
of a class that implements the BenefitsService
interface. The stub is downloaded automatically to the client through
serialization over the socket that connects the client and the service.
The stub class requires the programmer-defined Emp and
EmpBenefits types, which in turn may nest other
programmer-defined types, for instance, Department,
BusinessCertification, and ClientAccount:

public class Emp {
   private Department                   department;
   private List<BusinessCertification>  certifications;
   private List<ClientAccount>          accounts;
   ...
}

The standard Java types such as List already are available on the client side as 
the client is, by assumption, a Java application. The challenge involves the 
programmer-defined types such as Emp and EmpBenefits that are needed
to support the client-side invocation of a remotely executed method, as
this code segment illustrates:

   List<EmpBenefit> fredBenefits = remote_object.getBenefits(fred);  

Under Java RMI, programmer-defined types required on the client side
are loaded remotely and automatically. Yet the remote loading of Java
classes is inherently complicated and, of course, the format of Javaâ€™s
.class files is proprietary. Lots of bytes need to come down from the server 
to the client before the client can invoke a method remotely. The arguments passed 
to the Java RMI service (in this example, the Emp instance to which
fred refers) are serialized on the client side and
deserialized on the service side. The returned value, in this case a list
of EmpBenefits, is serialized by the service and
deserialized by the client. The client and service communicate through
binary rather than text streams and the structure of the binary streams is
Java specific.

Web services, as a foundational code base in an SOA system, simplify matters. 
For one thing, the client and service typically exchange XML or equivalent documents,
that is, text. If needed, non-text bytes can be exchanged
instead but the preferred payloads are text. The exchanged text can be inspected, validated, 
transformed, persisted, and otherwise processed using readily available,
non-proprietary, and often free tools. Each side, client and service,
simply needs a local software library that binds language-specific types
such as the Java String to XML Schema (or comparable)
types, in this case xsd:string. (In the qualified name xsd:string, xsd is a namespace
and string is a local name. Of interest here is that xsd:string is an XML type rather
than a Java type.) Given these bindings, relatively simple library modules can 
serialize and deserialize. Processing on the client side, as on the service side,
requires only locally available libraries and
utilities. The complexities, therefore, can be isolated at the endpoints and need not
seep into the exchanged messages. Finally, web services are available over HTTP, a 
non-propriety protocol whose implementation is ubiquitous.

In a web service, the requesting client and the service need not be coded in
the same language or even in the same style of language. Clients and
services can be implemented in object-oriented, procedural, functional,
and other language styles. The languages on either end may be statically
typed (for instance, Java and Go) or dynamically typed (for example, JavaScript
and Ruby). The complexities of stubs and skeletons, the serializating and
deserializing of objects encoded in some proprietary format, gives way to relatively
simple text-based representations of request and response messages.








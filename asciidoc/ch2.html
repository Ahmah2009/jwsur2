<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#jwsur_2nd_chapter_2">1. RESTful Web Services: The Service Side</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_java_options">1.1. The Java Options</a></span></dt><dt><span class="section"><a href="#_a_restful_service_as_an_literal_httpservlet_literal">1.2. A RESTful Service as an <code class="literal">HttpServlet</code></a></span></dt><dt><span class="section"><a href="#_a_restful_web_service_as_a_jax_rs_resource">1.3. A RESTful Web Service as a JAX-RS Resource</a></span></dt><dt><span class="section"><a href="#_a_restful_web_service_as_restlet_resources">1.4. A RESTful Web Service as Restlet Resources</a></span></dt><dt><span class="section"><a href="#_a_restful_service_as_a_literal_webserviceprovider_literal">1.5. A RESTful Service as a <code class="literal">@WebServiceProvider</code></a></span></dt><dt><span class="section"><a href="#_what_8217_s_next">1.6. What’s Next?</a></span></dt></dl></dd></dl></div><div class="section" title="1. RESTful Web Services: The Service Side"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="jwsur_2nd_chapter_2"></a>1. RESTful Web Services: The Service Side</h2></div></div></div><div class="section" title="1.1. The Java Options"><div class="titlepage"><div><div><h3 class="title"><a id="_the_java_options"></a>1.1. The Java Options</h3></div></div></div><p>Java has options for implementing and publishing RESTful web services.
On the publishing side, the choices range from very basic, command-line servers that are well suited for
development, testing, and even low-volume production;
through lightweight, Java-centric web servers such as Tomcat and Jetty; and up to full-blown Java
application servers (JAS) such as GlassFish, JBoss, Oracle WebLogic, and WebSphere. This chapter introduces
publication options in the first two categories and Chapter 7 covers JAS publication.</p><p>There is also variety among the APIs and their implementations for
RESTful services. Here is the list of APIs covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The <code class="literal">HttpServlet</code> and JSP APIs, introduced briefly in Chapter 1 and examined more thoroughly in this chapter.
</li><li class="listitem">
The JAX-RS (Java API for XML-Restful Services) API.
</li><li class="listitem">
The third-party Restlet API, which is very similar to JAX-RS in look-and-feel.
</li><li class="listitem">
The JAX-WS (Java API for XML-Web Services) API, the <code class="literal">@WebServiceProvider</code> interface in particular.
</li></ul></div><p>For the most part, the API used to implement the web service does not constrain how this service can be published.
The exception is the servlet API, as servlets need to be
deployed in a servlet container such as Tomcat’s Catalina or Jetty. (Jetty is the name of both the web server
and its servlet container.) There are shortcuts for
publishing JAX-RS and JAX-WS services but these, too, can be published with Tomcat or Jetty; and the same goes for
Restlet services.</p><p>The decision about how to publish a service depends on many
factors. For example, if service deployment requires wire-level security in the form of HTTPS together with
user authentication/authorization, then a web server such as Tomcat or Jetty is the obvious starting point. If the published
web services are to interact with EJBs, which are deployed in an EJB container, then a souped-up web server such as TomEE (Tomcat
with EE support) or a full JAS is a better choice. In development, simpler command-line options such as <code class="literal">Endpoint</code>, introduced
later, are attractive.</p></div><div class="section" title="1.2. A RESTful Service as an HttpServlet"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_service_as_an_literal_httpservlet_literal"></a>1.2. A RESTful Service as an <code class="literal">HttpServlet</code></h3></div></div></div><p>Chapter 1 has a sample RESTful service implemented as a JSP script and two back-end classes, <code class="literal">Prediction</code> and
<code class="literal">Predictions</code>. The JSP-based service supported only GET requests. This section revises the example to provide an
<code class="literal">HttpServlet</code> implementation with support for the four CRUD operations:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A new <code class="literal">Prediction</code> can be created with a POST request whose body should have two key/value pairs: a <code class="literal">who</code> key whose value
is the name of the predictor and a <code class="literal">what</code> key whose value is the prediction.
</li><li class="listitem">
The <code class="literal">Prediction</code> objects can be read one at a time or all together with a GET request.
If the GET request has a query string with an <code class="literal">id</code> key, then the corresponding <code class="literal">Prediction</code>, if any, is returned.
If the GET request has no query string, then the full list of <code class="literal">Predictions</code> is returned. On any GET request,
the client can indicate a preference for JSON rather than the default XML format.
</li><li class="listitem">
A specified <code class="literal">Prediction</code> can be updated with a PUT request that provides the identifier for the
<code class="literal">Prediction</code> and either
a new <code class="literal">who</code> or a new <code class="literal">what</code>.
</li><li class="listitem">
A specified <code class="literal">Prediction</code> can be deleted.
</li></ul></div><p>The earlier JSP service is <span class="emphasis"><em>predictions</em></span> and the servlet revision is <span class="emphasis"><em>predictions2</em></span>.
The structure of <span class="emphasis"><em>predictions2</em></span> differs from that of <span class="emphasis"><em>predictions</em></span> in several ways.
The most obvious change is that
an explicit <code class="literal">HttpServlet</code> subclass replaces the JSP script. There are also changes in the details of the <code class="literal">Prediction</code> and
<code class="literal">Predictions</code> classes, which still provide back-end support. The details follow.</p><div class="sidebar" title="The Jetty web server"><p class="title"><b>The Jetty web server</b></p><p>The Jetty web server is available at <span class="emphasis"><em>jetty.codehaus.org</em></span> as a ZIP file. Let the install directory be <span class="emphasis"><em>JETTY_HOME</em></span>.
Its subdirectories are similar to those of <span class="emphasis"><em>TOMCAT_HOME</em></span>. For
example, there is a <span class="emphasis"><em>webapps</em></span> subdirectory into which WAR files are deployed; a <span class="emphasis"><em>logs</em></span> subdirectory; a <span class="emphasis"><em>lib</em></span> subdirectory with various
JAR files, including a versioned counterpart
of Tomcat’s <span class="emphasis"><em>servlet-api.jar</em></span>; and others. Jetty ships with an executable JAR file <span class="emphasis"><em>start.jar</em></span>; hence,
Jetty can be started at the command line with the command</p><pre class="screen">% java -jar start.jar</pre><p>In general, a WAR file deployable under Tomcat is deployable under Jetty and vice-versa; my examples can be
deployed under either.
The Jetty web
server, like Tomcat, listens by default on port 8080. Jetty is a first-rate web server that
has a lighter feel than does Tomcat; and Jetty’s simplicity makes embedding this web server in other
systems relatively straightforward. It is hard to make a bad choice between Tomcat and
Jetty.</p></div><div class="section" title="1.2.1. Implementation Details"><div class="titlepage"><div><div><h4 class="title"><a id="_implementation_details"></a>1.2.1. Implementation Details</h4></div></div></div><div class="example"><a id="Ex1"></a><p class="title"><b>Example 1. The back-end <code class="literal">Prediction</code> class.</b></p><div class="example-contents"><pre class="screen">package predictions2;
import java.io.Serializable;

public class Prediction implements Serializable, Comparable&lt;Prediction&gt; {
    private String who;   // person
    private String what;  // his/her prediction
    private int    id;    // identifier used as lookup-key

    public Prediction() { }
    public void setWho(String who) { this.who = who; }
    public String getWho() { return this.who; }
    public void setWhat(String what) { this.what = what; }
    public String getWhat() { return this.what; }
    public void setId(int id) { this.id = id; }     <a id="CO1-1"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public int getId() { return this.id; }
    public int compareTo(Prediction other) { return this.id - other.id; }
}</pre></div></div><br class="example-break" /><p>There are small but important changes to the <code class="literal">Prediction</code> class (see <a class="xref" href="#Ex1" title="Example 1. The back-end Prediction class.">Example 1, “The back-end <code class="literal">Prediction</code> class.”</a>), which now includes an <code class="literal">id</code> property (line 1), an
an auto-incremented integer that the service sets when a <code class="literal">Prediction</code> object is constructed. The <code class="literal">id</code>
property is used to sort the <code class="literal">Prediction</code> objects, which explains why the <code class="literal">Prediction</code> class implements
the interface <code class="literal">Comparable</code> used in sorting:</p><pre class="screen">public class Prediction implements Serializable, Comparable&lt;Prediction&gt; {</pre><p>Implementing the <code class="literal">Comparable</code> interface requires that the <code class="literal">compareTo</code> method be defined:</p><pre class="screen">public int compareTo(Prediction other) {
    return this.id - other.id;
}</pre><p>The <code class="literal">compareTo</code> method uses the comparison semantics of the age-old C function <code class="literal">qsort</code>. For illustration,
suppose that <code class="literal">this.id</code> in the code above is 7 and <code class="literal">other.id</code> is 12, where <code class="literal">this</code> is the current object
and <code class="literal">other</code> is another <code class="literal">Prediction</code> object against which the current <code class="literal">Prediction</code> object is being
compared. The difference 7 - 12 is the negative integer -5, which signals that the current <code class="literal">Prediction</code>
<span class="emphasis"><em>precedes</em></span> the other <code class="literal">Prediction</code> because 7 precedes 12. In general,</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A returned negative integer signals that the current object <span class="emphasis"><em>precedes</em></span> the other object.
</li><li class="listitem">
A returned positive integer signals that the current object <span class="emphasis"><em>succeeds</em></span> the other object.
</li><li class="listitem">
A returned zero signals that the two objects are to be treated as equals with respect to sorting.
</li></ul></div><p>The implementation of the <code class="literal">compareTo</code> method means the sort is to be in ascending order. Were the <code class="literal">return</code>
statement changed to</p><pre class="screen">return other.id - this.id;</pre><p>the sort would be in descending order. The <code class="literal">Prediction</code> objects are sorted for ease of confirming that
the CRUD operations work correctly. For example, if a <code class="literal">Prediction</code> object is created with the
appropriate POST request, then the newly created <code class="literal">Prediction</code> occurs at the <span class="emphasis"><em>end</em></span> of the
<code class="literal">Prediction</code> list. In similar fashion, it is easy to confirm that the other destructive CRUD
operations—PUT (update) and DELETE—work as intended by inspecting the resulting sorted list of <code class="literal">Prediction</code>
objects.</p><p>A <code class="literal">Prediction</code> is still <code class="literal">Serializable</code> so that a list of these can be serialized into
XML using the <code class="literal">XmlEncoder</code> utility. An added feature is that this list also can be formatted in
JSON if the client so requests.</p><div class="example"><a id="Ex2"></a><p class="title"><b>Example 2. The back-end <code class="literal">Predictions</code> class.</b></p><div class="example-contents"><pre class="screen">package predictions2;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
import java.beans.XMLEncoder; // simple and effective
import javax.servlet.ServletContext;

public class Predictions {
    private ConcurrentMap&lt;Integer, Prediction&gt; predictions;
    private ServletContext sctx;
    private AtomicInteger mapKey;

    public Predictions() {
        predictions = new ConcurrentHashMap&lt;Integer, Prediction&gt;();
        mapKey = new AtomicInteger();
    }
    public void setServletContext(ServletContext sctx) {
        this.sctx = sctx;
    }
    public ServletContext getServletContext() { return this.sctx; }
    public void setMap(ConcurrentMap&lt;String, Prediction&gt; predictions) {
        // no-op for now
    }
    public ConcurrentMap&lt;Integer, Prediction&gt; getMap() {
        // Has the ServletContext been set?
        if (getServletContext() == null) return null;
        // Have the data been read already?
        if (predictions.size() &lt; 1) populate();
        return this.predictions;
    }
    public String toXML(Object obj) {
        String xml = null;
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            XMLEncoder encoder = new XMLEncoder(out);
            encoder.writeObject(obj); // serialize to XML
            encoder.close();
            xml = out.toString(); // stringify
        }
        catch(Exception e) { }
        return xml;
    }
    public int addPrediction(Prediction p) {
        int id = mapKey.incrementAndGet();
        p.setId(id);
        predictions.put(id, p);
        return id;
    }
    private void populate() {
        String filename = "/WEB-INF/data/predictions.db";
        InputStream in = sctx.getResourceAsStream(filename);
        // Read the data into the array of Predictions.
        if (in != null) {
            try {
                InputStreamReader isr = new InputStreamReader(in);
                BufferedReader reader = new BufferedReader(isr);
                int i = 0;
                String record = null;
                while ((record = reader.readLine()) != null) {
                    String[] parts = record.split("!");
                    Prediction p = new Prediction();
                    p.setWho(parts[0]);
                    p.setWhat(parts[1]);
                    addPrediction(p);
                }
            }
            catch (IOException e) { }
        }
    }
}</pre></div></div><br class="example-break" /><p>The utility class <code class="literal">Predictions</code> has changed as well (see <a class="xref" href="#Ex2" title="Example 2. The back-end Predictions class.">Example 2, “The back-end <code class="literal">Predictions</code> class.”</a>). As explained in the
sidebar about thread synchronization and servlets, the <code class="literal">Map</code> of the earlier JSP
implementation gives way to a <code class="literal">ConcurrentMap</code> so that the code can avoid explicit
locks in the form of <code class="literal">synchronized</code> blocks. The <code class="literal">Predictions</code> class now has an <code class="literal">addPrediction</code> method</p><pre class="screen">public int addPrediction(Prediction p) {
   int id = mapKey.incrementAndGet(); // AtomicInteger
   p.setId(id);
   predictions.put(id, p);
   return id;
}</pre><p>to support POST requests. The servlet’s <code class="literal">doPost</code> method creates a new <code class="literal">Prediction</code>, sets
the <code class="literal">who</code> and <code class="literal">what</code> properties with data from the POST message’s body, and then
invokes <code class="literal">addPrediction</code> to add the newly constructed <code class="literal">Prediction</code> to the map whose
object reference is <code class="literal">predictions</code>. The <code class="literal">mapKey</code>, a thread-safe <code class="literal">AtomicInteger</code>, gets incremented
with each new <code class="literal">Prediction</code> and behaves like an auto-incremented integer in a database system; the
<code class="literal">mapKey</code> value becomes the <code class="literal">id</code> of each newly constructed
<code class="literal">Prediction</code>, thereby ensuring that each <code class="literal">Prediction</code> has a unique <code class="literal">id</code>.</p><p>The remaining <code class="literal">Predictions</code> code is slightly changed, if at all, from the earlier version.
For example, the <code class="literal">populate</code> method is modified slightly to give each newly constructed
<code class="literal">Prediction</code> an <code class="literal">id</code>; but the method’s main job is still to read data from the text
file encapsulated in the WAR, data that contain the <code class="literal">who</code> and the <code class="literal">what</code> of each
<code class="literal">Prediction</code>.</p><p>The <code class="literal">PredictionServlet</code> (see <a class="xref" href="#Ex3" title="Example 3. The PredictionsServlet with full support for the CRUD operations.">Example 3, “The <code class="literal">PredictionsServlet</code> with full support for the CRUD operations.”</a>) replaces the JSP script and differs from this
script in supporting all of the CRUD operations. The servlet offers new functionality
by allowing the client to request JSON format for the response of any GET request. Further,
the earlier JSP script interpreted GET to mean <span class="emphasis"><em>read all</em></span> but the servlet allows the client to
request one specified <code class="literal">Prediction</code> or all of them. The code for the <code class="literal">PredictionServlet</code> is long enough
that it makes sense to isolate important code segments for clarification.</p><div class="example"><a id="Ex3"></a><p class="title"><b>Example 3. The <code class="literal">PredictionsServlet</code> with full support for the CRUD operations.</b></p><div class="example-contents"><pre class="screen">package predictions2;

import java.util.concurrent.ConcurrentMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.ws.http.HTTPException;
import java.util.Arrays;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.beans.XMLEncoder;
import org.json.JSONObject;
import org.json.XML;

public class PredictionsServlet extends HttpServlet {
    private Predictions predictions; // back-end bean

    // Executed when servlet is first loaded into container.
    // Create a Predictions object and set its servletContext
    // property so that the object can do I/O.
    @Override
    public void init() {
        predictions = new Predictions();
        predictions.setServletContext(this.getServletContext());
    }
    // GET /predictions2
    // GET /predictions2?id=1
    // If the HTTP Accept header is set to application/json (or an equivalent
    // such as text/x-json), the response is JSON and XML otherwise.
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String param = request.getParameter("id");
        Integer key = (param == null) ? null : new Integer(param.trim());
        // Check user preference for XML or JSON by inspecting
        // the HTTP headers for the Accept key.
        boolean json = false;
        String accept = request.getHeader("accept");
        if (accept != null &amp;&amp; accept.contains("json")) json = true;
        // If no query string, assume client wants the full list.
        if (key == null) {
            ConcurrentMap&lt;Integer, Prediction&gt; map = predictions.getMap();
            // Sort the map's values for readability.
            Object[] list = map.values().toArray();
            Arrays.sort(list);
            String xml = predictions.toXML(list);
            sendResponse(response, xml, json);
        }
        // Otherwise, return the specified Prediction.
        else {
            Prediction pred = predictions.getMap().get(key);

            if (pred == null) { // no such Prediction
                String msg = key + " does not map to a prediction.\n";
                sendResponse(response, predictions.toXML(msg), false);
            }
            else { // requested Prediction found
                sendResponse(response, predictions.toXML(pred), json);
            }
        }
    }
    // POST /predictions2
    // HTTP body should contain two keys, one for the predictor ("who") and
    // another for the prediction ("what").
    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) {
        String who = request.getParameter("who");
        String what = request.getParameter("what");
        // Are the data to create a new prediction present?
        if (who == null || what == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
        // Create a Prediction.
        Prediction p = new Prediction();
        p.setWho(who);
        p.setWhat(what);
        // Save the ID of the newly created Prediction.
        int id = predictions.addPrediction(p);
        // Generate the confirmation message.
        String msg = "Prediction " + id + " created.\n";
        sendResponse(response, predictions.toXML(msg), false);
    }
    // PUT /predictions
    // HTTP body should contain at least two keys: the prediction's id
    // and either who or what.
    @Override
    public void doPut(HttpServletRequest request, HttpServletResponse response) {
        /* A workaround is necessary for a PUT request because neither Tomcat
           nor Jetty generates a workable parameter map for this HTTP verb. */
        String key = null;
        String rest = null;
        boolean who = false;
        /* Let the hack begin. */
        try {
            BufferedReader br =
                new BufferedReader(new InputStreamReader(request.getInputStream()));
            String data = br.readLine();
            /* To simplify the hack, assume that the PUT request has exactly
               two parameters: the id and either who or what. Assume, further,
               that the id comes first. From the client side, a hash character
               # separates the id and the who/what, e.g.,
                  id=33#who=Homer Allision
            */
            String[] args = data.split("#");      // id in args[0], rest in args[1]
            String[] parts1 = args[0].split("="); // id = parts1[1]
            key = parts1[1];
            String[] parts2 = args[1].split("="); // parts2[0] is key
            if (parts2[0].contains("who")) who = true;
            rest = parts2[1];
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
        // If no key, then the request is ill formed.
        if (key == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
        // Look up the specified prediction.
        Prediction p = predictions.getMap().get(new Integer(key.trim()));
        if (p == null) { // not found?
            String msg = key + " does not map to a Prediction.\n";
            sendResponse(response, predictions.toXML(msg), false);
        }
        else { // found
            if (rest == null) {
                throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
            }
            // Do the editing.
            else {
                if (who) p.setWho(rest);
                else p.setWhat(rest);
                String msg = "Prediction " + key + " has been edited.\n";
                sendResponse(response, predictions.toXML(msg), false);
            }
        }
    }
    // DELETE /predictions2?id=1
    @Override
    public void doDelete(HttpServletRequest request, HttpServletResponse response) {
        String param = request.getParameter("id");
        Integer key = (param == null) ? null : new Integer(param.trim());
        // Only one Prediction can be deleted at a time.
        if (key == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
        try {
            predictions.getMap().remove(key);
            String msg = "Prediction " + key + " removed.\n";
            sendResponse(response, predictions.toXML(msg), false);
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
    // Method Not Allowed
    @Override
    public void doTrace(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Method Not Allowed
    @Override
    public void doHead(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Method Not Allowed
    @Override
    public void doOptions(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Send the response payload to the client.
    private void sendResponse(HttpServletResponse response, String payload, boolean json) {
        try {
            // Convert to JSON?
            if (json) {
                JSONObject jobt = XML.toJSONObject(payload);
                payload = jobt.toString(3); // 3 is indentation level for nice look
            }
            OutputStream out = response.getOutputStream();
            out.write(payload.getBytes());
            out.flush();
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
}</pre></div></div><br class="example-break" /><p>Recall that each of the <span class="emphasis"><em>do</em></span>-methods in an <code class="literal">HttpServlet</code> takes the same arguments: an
<code class="literal">HttpServletRequest</code>, a map that contains the information encapsulated in the HTTP request, and an
<code class="literal">HttpServletRespose</code>, which encapsulates an output stream for communicating back with the client.
Here is the start of <code class="literal">doGet</code> method:</p><pre class="screen">public void doGet(HttpServletRequest request, HttpServletResponse response) {</pre><p>The <code class="literal">HttpServletRequest</code> has a <code class="literal">getParameter</code> method that expects a string argument, a
key into the request map, and returns either <code class="literal">null</code> if there is no such key or the
key’s value as a string otherwise. The <code class="literal">getParameter</code> method is agnostic about whether the
key/value pairs are in the body of, for example, a POST request or in the
query string of, for example, a GET request. The method works the same in either case.
There is also a <code class="literal">getParameters</code> method that returns the parameter collection as a whole.</p><p>In the case of <code class="literal">PredictionsServlet</code>, the <code class="literal">doGet</code> method needs to answer two questions
about the incoming request:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Does the body-less GET request include a key named <code class="literal">id</code> whose value identifies a particular <code class="literal">Prediction</code>?
</p><p class="simpara">If the <code class="literal">id</code> is present, the <code class="literal">doGet</code> method uses the <code class="literal">id</code> to perform a lookup against the <code class="literal">ConcurrentMap</code>, which
holds references to all of the <code class="literal">Prediction</code> objects. If the lookup fails, then the <code class="literal">doGet</code> method
method returns an XML message to that effect:</p><pre class="screen">Prediction pred = predictions.getMap().get(key);
if (pred == null) { // no such Prediction
    String msg = key + " does not map to a prediction.\n";
    sendResponse(response, predictions.toXML(msg), false);
}</pre><p class="simpara">The last argument to the <code class="literal">sendResponse</code> method indicates whether JSON rather than XML should be
sent back to the client. In this example, XML is returned because the JSON flag is <code class="literal">false</code>.
If the <code class="literal">id</code> parameter is not present, the <code class="literal">doGet</code> method assumes that the client wants to read a
list of all <code class="literal">Predictions</code> and returns this list in either JSON or XML format:</p><pre class="screen">ConcurrentMap&lt;String, Prediction&gt; map = predictions.getMap();
// Sort the map's values for readability.
Object[] list = map.values().toArray();
Arrays.sort(list); // other ways to sort shown later
...</pre></li><li class="listitem"><p class="simpara">
Does the client prefer JSON over XML?
</p><p class="simpara">In an HTTP request, the requester can express a preference for the MIME type of the
returned representation. For example, the header element</p><pre class="screen">Accept: text/html</pre><p class="simpara">expresses a preference for the MIME type <code class="literal">text/html</code>. Among the MIME combinations is
<code class="literal">application/json</code> that, together with several variants, expresses a preference for JSON. The <code class="literal">doGet</code>
method therefore uses the <code class="literal">getHeader</code> method in the <code class="literal">HttpServletRequest</code> to inspect the HTTP header
element with <code class="literal">Accept</code> as its key:</p><pre class="screen">boolean json = false;
String accept = request.getHeader("accept");
if (accept != null &amp;&amp; accept.contains("json")) json = true;</pre><p class="simpara">This check determines whether the client prefers JSON over XML. (Recall that HTTP is case insensitive; hence,
the key could be <code class="literal">Accept</code>, <code class="literal">accept</code>, <code class="literal">ACCEPT</code>, and so on.) The <code class="literal">json</code> flag is the third argument
to the <code class="literal">sendResponse</code> method:</p><pre class="screen">private void sendResponse(HttpServletResponse res,
                          String payload,
                          boolean json) { // json format?
   try {
      if (json) {
        JSONObject jobt = XML.toJSONObject(payload);
        payload = jobt.toString(3); // 3 is indentation level
      }
      OutputStream out = res.getOutputStream();
      out.write(payload.getBytes());
      out.flush();
   }
   catch(Exception e) {
      throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
   }
}</pre><p class="simpara">Details about generating the JSON are considered next.</p></li></ul></div><p>The deployed WAR file <span class="emphasis"><em>predictions2.war</em></span> includes a lightweight, third-party JSON library in the
JAR file <span class="emphasis"><em>json.jar</em></span> (see <span class="emphasis"><em>www.json.org/java</em></span>). If the client prefers JSON over XML, then the response <code class="literal">payload</code>
is converted to JSON. If anything goes awry in sending the response back to the client,
the servlet throws an <code class="literal">HTTPException</code>, which in this case generates a response with
HTTP status code 500 for <span class="emphasis"><em>Internal Server Error</em></span>, a catch-all for request-processing errors on
the server.</p><p>The <code class="literal">doPost</code> and <code class="literal">doPut</code> operations are similar in that <code class="literal">doPost</code> creates an altogether new <code class="literal">Prediction</code>
using data in the body of a POST request, whereas <code class="literal">doPut</code> updates an existing <code class="literal">Prediction</code> from
data in the body of a PUT request. The main difference is that a PUT request needs to include
the <code class="literal">id</code> of the <code class="literal">Prediction</code> to be updated, whereas a POST request creates a new
<code class="literal">Prediction</code> and then sets its <code class="literal">id</code> to an auto-incremented integer. In implementation, however,
<code class="literal">doPost</code> and <code class="literal">doPut</code> differ significantly because the servlet container’s run-time does not generate a
usable parameter map, the <code class="literal">HttpServletRequest</code>, on a PUT request; on a POST request, the
map is usable. (This is the case in both Tomcat and Jetty.) As a result, the <code class="literal">doPut</code> implementation
extracts the data directly from an input stream.</p><p>To begin, here is the <code class="literal">doPost</code> implementation, without the comments:</p><pre class="screen">public void doPost(HttpServletRequest request, HttpServletResponse response) {
   String who = request.getParameter("who");                           <a id="CO1-2"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   String what = request.getParameter("what");                         <a id="CO1-3"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
   if (who == null || what == null)
      throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
   Prediction p = new Prediction();                                    <a id="CO1-4"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
   p.setWho(who);                                                      <a id="CO1-5"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
   p.setWhat(what);                                                    <a id="CO1-6"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
   int id = predictions.addPrediction(p);                              <a id="CO1-7"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
   String msg = "Prediction " + id + " created.\n";
   sendResponse(response, predictions.toXML(msg), false);              <a id="CO1-8"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
}</pre><p>The two calls to the <code class="literal">getParameter</code> method extract the required data (lines 1 and 2).
A new <code class="literal">Prediction</code>
is then constructed, its <code class="literal">who</code> and <code class="literal">what</code> properties are set, and a confirmation is
generated for the client (lines 3 through 7).</p><p>In the <code class="literal">doPut</code> method, the <code class="literal">getParameter</code> method does not work correctly because neither
Tomcat nor Jetty builds a usable parameter map in <code class="literal">HttpServletRequest</code>.
The workaround is to access directly the input stream encapsulated in the
request structure:</p><pre class="screen">BufferedReader br =
  new BufferedReader(new InputStreamReader(request.getInputStream()));
String data = br.readLine();
...</pre><p>The next step is to extract the <code class="literal">data</code> from this stream. The code, though not pretty, gets
the job done. The point of interest is that the <code class="literal">HttpServletRequest</code> does provide
access to the underlying input stream from which the PUT data can be extracted. Using
the <code class="literal">getParameter</code> method is, of course, much easier.</p><p>The body of <code class="literal">doDelete</code> method has simple logic:</p><pre class="screen">String key = request.getParameter("id");
if (key == null)
   throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
try {
   predictions.getMap().remove(key);                         <a id="CO1-9"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   String msg = "Prediction " + key + " removed.\n";
   sendResponse(response, predictions.toXML(msg), false);
}
catch(Exception e) {
   throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
}</pre><p>If the <code class="literal">id</code> for the <code class="literal">Prediction</code> can be extracted from the parameter map, the
prediction is effectively removed from the collection by removing the lookup key
from the <code class="literal">ConcurrentMap</code> (line 1).</p><p>The <code class="literal">PredictionsServlet</code> also implements three other <span class="emphasis"><em>do</em></span>-methods and all in the same way. Here, for example,
is the implementation of <code class="literal">doHead</code>:</p><pre class="screen">public void doHead(HttpServletRequest request, HttpServletResponse response) {
     throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
}</pre><p>Throwing the <code class="literal">HTTPException</code> signals to the client that the underlying HTTP
verb, in this case <code class="literal">HEAD</code>, is not supported. The numeric status code for
<code class="literal">Method Not Allowed</code> is 405. The web service designer thus has an idiomatic
way to reject particular HTTP verbs: throw a <code class="literal">Method Not Allowed</code> exception.</p><div class="sidebar" title="Servlets and thread synchronization"><p class="title"><b>Servlets and thread synchronization</b></p><p>A web server such as Tomcat can instantiate arbitrarily many instances of a servlet, although the number is
typically small, for example, 1 through 4. The web server
itself makes the decision. For example, Tomcat by default loads one instance of a servlet to begin but may load
more instances thereafter if simultaneous requests for the servlet are sufficient in number. Whatever the
number of servlet instances, the number of client requests per instance is typically greater—and significantly
so. For example, one servlet instance might handle tens of simultaneous requests. For reasons of efficiency, a web server
such as Tomcat keeps the number of servlet instances as small as possible while supporting reasonable
response time per request. A high-volume web server might have to handle hundreds of
requests per second, distributed across many servlet instances; and one servlet instance per request is out of the question in
this real-world scenario. The upshot is that Java-based web servers rely on multithreading to handle simultaneous requests.
The model is sometimes described as <span class="emphasis"><em>one thread per request</em></span>.</p><p>For reasons of performance, a web server such as Tomcat creates a thread pool at startup; as requests come
in, each is dispatched to a thread from the pool, which then handles the request and returns to the pool
afterwards. The pooling amortizes the relatively
expensive cost of thread-creation across the web server’s uptime. There are, of course, various ways to
measure how well a web server is performing. One critical measure is response time. For example, a web site
might require that the upper bound on response time for 90% of all requests be, say, 10 <span class="emphasis"><em>ms</em></span>.</p><p>The one-thread-per-request model poses challenges for the servlet/JSP programmer, in particular the
challenge of thread coordination or <span class="emphasis"><em>synchronization</em></span>. For example, if there are a dozen
concurrent requests against the <code class="literal">PredictionsServlet</code> of the <span class="emphasis"><em>predictions2</em></span> service, then each of
these requests is implemented as a thread that executes the appropriate <span class="emphasis"><em>do</em></span>-method in the servlet.
On a multi-core server (that is, a server with more than CPU), one thread could be
executing the <code class="literal">doGet</code> method at exactly the same time as another is executing the <code class="literal">doPut</code> method: the
result is a simultaneous <span class="emphasis"><em>read</em></span> and <span class="emphasis"><em>write</em></span> operation on the same resource. There are various
other concurrency scenarios, any one of which requires proper thread synchronization to avoid so-called
<span class="emphasis"><em>race conditions</em></span>; and the programmer
rather than the servlet container must ensure that these scenarios remain thread safe.</p><p>A servlet container such as Catalina or Jetty, in contrast to an EJB container, does <span class="emphasis"><em>not</em></span> ensure
thread safety; instead, the programmer is responsible for proper thread coordination. A servlet must be
programmed so that, for example, two requests—each executing as a separate thread—cannot simultaneously
update the same resource such as a <code class="literal">Prediction</code>. In earlier Java versions, the mainstay of thread coordination was the
<code class="literal">synchronized</code> block; later versions of Java have added higher-level constructs, many in the
<code class="literal">java.util.concurrent</code> package, for managing
thread-based concurrency.</p><p>The <span class="emphasis"><em>predictions2</em></span> service uses a thread-safe <code class="literal">ConcurrentMap</code> to coordinate
simultaneous thread access to the <code class="literal">Predictions</code>.
A <code class="literal">ConcurrentMap</code> segments its entries; as a result, the map
usually needs to lock only a portion of its total entries to enforce synchronization. In any case, the
<code class="literal">ConcurrentMap</code> synchronizes access to the <code class="literal">Predictions</code> collection and does so in an
efficient manner. The <code class="literal">java.util.concurrent</code> package offers other thread-safe data structures; a
later example in this chapter, the JAX-RS <span class="emphasis"><em>predictions3</em></span> service, uses one of these data structures,
the thread-safe <code class="literal">CopyOnWriteArrayList</code>.
Finally, the <span class="emphasis"><em>predictions2</em></span> service uses an integer counter to set the <code class="literal">id</code> for each newly created prediction.
The counter is implemented with a thread-safe <code class="literal">AtomicInteger</code>.</p></div></div><div class="section" title="1.2.2. Sample Client Calls against the predictions2 Service"><div class="titlepage"><div><div><h4 class="title"><a id="_sample_client_calls_against_the_emphasis_predictions2_emphasis_service"></a>1.2.2. Sample Client Calls against the <span class="emphasis"><em>predictions2</em></span> Service</h4></div></div></div><p>Example 2-4 is a list of <span class="emphasis"><em>curl</em></span> calls against the service. These calls serve as a very preliminary test
of the service. Two semi-colons introduce comments that explain the purpose of
the <span class="emphasis"><em>curl</em></span> call. Recall that the Ant script can be used to deploy the <span class="emphasis"><em>predictions2</em></span> service under Tomcat:</p><pre class="screen">% ant -Dwar.name=predictions2 deploy</pre><div class="example"><a id="Ex4"></a><p class="title"><b>Example 4. A suite of <span class="emphasis"><em>curl</em></span> calls against the <span class="emphasis"><em>predictions</em></span> RESTful service.</b></p><div class="example-contents"><pre class="screen">;; GET all predictions (XML response)
% curl localhost:8080/predictions2/   ;; curl --request GET...
;; GET a specified saying (XML response)
% curl localhost:8080/predictions2?id=31
;; GET all predictions (JSON response)
% curl --header "Accept: application/json" localhost:8080/predictions2/
;; GET a specified saying (JSON response)
% curl --header "Accept: application/json" localhost:8080/predictions2?id=31
;; POST a new saying
% curl --request POST --data "who=TSEliot&amp; \
           what=This is the way the world ends" localhost:8080/predictions2/
;; GET all predictions to confirm the POST (new saying is at the end)
% curl localhost:8080/predictions2/
;; PUT new data into an existing saying
% curl --request PUT --data "id=33#what=This is an update" localhost:8080/predictions2/
;; GET all predictions to confirm the PUT (edited saying is at the end)
% curl localhost:8080/predictions2/
;; DELETE a specificed saying
% curl --request DELETE localhost:8080/predictions2?id=33
;; GET all predictions to confirm the DELETE
% curl localhost:8080/predictions2/</pre></div></div><br class="example-break" /><p>The XML responses from the <span class="emphasis"><em>predictions2</em></span> service are formatted exactly the same as in the
original version, which did not support JSON responses. Here is a sample JSON response from a GET
request on the <code class="literal">Prediction</code> with <code class="literal">id</code> 31:</p><pre class="screen">{"java": {"class": "java.beans.XMLDecoder", "object": {"void": [
         {"int": 31, "property": "id"},
         {"string": "Balanced clear-thinking utilisation
                     will expedite collaborative initiatives.",
          "property": "what"}, {"string": "Deven Blanda", "property": "who"}],
 "class": "predictions2.Prediction"},
 "version": "1.7.0_17"}}</pre></div></div><div class="section" title="1.3. A RESTful Web Service as a JAX-RS Resource"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_web_service_as_a_jax_rs_resource"></a>1.3. A RESTful Web Service as a JAX-RS Resource</h3></div></div></div><p>The servlet API, the grizzled workhorse for producing Java web sites, is still nimble enough to support RESTful web services as well.
There are more recent APIs, among them JAX-RS (Java API for XML-RESTful Web Services). JAX-RS relies upon Java annotations to
advertise the RESTful role that a class and its encapsulated methods play. Jersey (<span class="emphasis"><em>jersey-java.net</em></span>) is the
<span class="emphasis"><em>reference implementation</em></span> (RI) of JAX-RS. RESTEasy, a JBoss project (<span class="emphasis"><em>www.jboss.org/resteasy</em></span>),
Apache Wink (<span class="emphasis"><em>incubator.apache.org/wink/</em></span>), and Apache CXF (<span class="emphasis"><em>cxf.apache.org</em></span>) are other implementations.
JAX-RS has APIs for programming RESTful services and clients
against such services; and the two APIs can be used independently. This section focuses on the service-side API. The first
JAX-RS example supports only GET requests but the second JAX-RS example supports all of the CRUD operations.</p><div class="section" title="1.3.1. A First JAX-RS Web Service using Jersey"><div class="titlepage"><div><div><h4 class="title"><a id="_a_first_jax_rs_web_service_using_jersey"></a>1.3.1. A First JAX-RS Web Service using Jersey</h4></div></div></div><p>JAX-RS web services are <span class="emphasis"><em>resources</em></span>
that can be published with the Tomcat and Jetty web servers (see the sidebar). The first example has
one resource, the class <code class="literal">Adages</code>, and two supporting Java classes: the
deployment class <code class="literal">RestfulApplication</code> and the POJO class <code class="literal">Adage</code>. Exactly how these three classes
interact is covered next.</p><p>The <code class="literal">RestfulAdage</code> class (see <a class="xref" href="#Ex5" title="Example 5. The JAX-RS Application subclass that lists Adages.class as a resource.">Example 5, “The JAX-RS <code class="literal">Application</code> subclass that lists <code class="literal">Adages.class</code> as a resource.”</a>) extends the
JAX-RS <code class="literal">Application</code> class (line 2), which implements a <code class="literal">getClasses</code> method that enumerates the individual resources
deployed in the WAR file (line 3). In this example, there is but one such resource, <code class="literal">Adages</code>, but there
could be arbitrarily many (line 4).</p><div class="example"><a id="Ex5"></a><p class="title"><b>Example 5. The JAX-RS <code class="literal">Application</code> subclass that lists <code class="literal">Adages.class</code> as a resource.</b></p><div class="example-contents"><pre class="screen">package adages;

import java.util.Set;
import java.util.HashSet;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/resourcesA")                        <a id="CO1-10"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
public class RestfulAdage extends Application {        <a id="CO1-11"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {                <a id="CO1-12"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        Set&lt;Class&lt;?&gt;&gt; set = new HashSet&lt;Class&lt;?&gt;&gt;();
        set.add(Adages.class);                         <a id="CO1-13"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        return set;
    }
}</pre></div></div><br class="example-break" /><p>Recall that any web site or web service deployed under Tomcat has a URI that begins with the
name of the deployed WAR file. In the <code class="literal">RestfulAdage</code> class, the annotation <code class="literal">ApplicationPath</code>  (line 1)
spells out how the URI continues. For example, assuming that the deployed WAR file is named
<span class="emphasis"><em>adages.war</em></span>, the <code class="literal">ApplicationPath</code> annotation indicates that the URI part of the URL
continues with <span class="emphasis"><em>resourcesA</em></span>:</p><pre class="screen">http://localhost:8080/adages/resourcesA</pre><p>The next part is tricky so the low-level details are explained in a sidebar. At issue is how the
programmer-defined <code class="literal">RestfulAdage</code> class interacts with the Jersey JAX-RS implementation under a Tomcat
deployment. For context,
recall that the <code class="literal">getClasses</code> method (line 3), a callback invoked when the <code class="literal">RestfulAdage</code> instance is loaded into the
servlet container, specifies the JAX-RS resources available in the WAR file. Once again, there
is but a single resource <code class="literal">Adages</code> (see <a class="xref" href="#Ex7" title="Example 7. The Adages class as a JAX-RS resource.">Example 7, “The <code class="literal">Adages</code> class as a JAX-RS resource.”</a>) in the example.
The
<code class="literal">RestfulAdage</code> class is a Jersey <code class="literal">Application</code> because the programmer-defined <code class="literal">RestfulAdage</code> class extends the
JAX-RS <code class="literal">Application</code> class.
If multiple JAX-RS resources were to be
made available in the deployed WAR file, then the class name of each would occur in a
<code class="literal">set.add</code> call in <code class="literal">RestfulAdage</code>. In the current example, there is only</p><pre class="screen">set.add(Adages.class);</pre><p>because <code class="literal">Adages</code> is the only resource.</p><div class="sidebar" title="Publishing JAX-RS resources with a Java Application"><p class="title"><b>Publishing JAX-RS resources with a Java Application</b></p><p>A later sidebar explains how a JAX-RS resource can be published with production-grade web server such
as Tomcat; the sidebar also explains how the JAX-RS libraries can be downloaded. For now, the
point of interest is that the Jersey implementation of JAX-RS offers other ways to publish, which may be better
suited for development. Here is a standalone Java application that publishes the <span class="emphasis"><em>adages</em></span> service:</p><pre class="screen">package adages;

import java.net.InetSocketAddress;
import javax.ws.rs.ext.RuntimeDelegate;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

public class AdagesPublisher{
    private static final int port = 9876;                                  <a id="CO1-14"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    private static final String uri = "/resourcesA/";                      <a id="CO1-15"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    private static final String url = "http://localhost:" + port + uri;
    public static void main(String[ ] args) {
        new AdagesPublisher().publish();
    }
    private void publish() {
        HttpServer server = getServer();
        HttpHandler requestHandler =
            RuntimeDelegate.getInstance().createEndpoint(new RestfulAdage(),
                                                         HttpHandler.class);
        server.createContext(uri, requestHandler);
        server.start();
        msg(server);
    }
    private HttpServer getServer() {
        HttpServer server = null;
        int backlog = 8;
        try {
            server =
              HttpServer.create(new InetSocketAddress("localhost", port),
                                backlog);
        }
        catch(Exception e) { throw new RuntimeException(e); }
        return server;
    }

    private void msg(HttpServer server) {
        String out = "Publishing RestfulAdage on " + url +
                                                 ". Hit any key to stop.";
        System.out.println(out);
        try {
            System.in.read();
        } catch(Exception e) { }
        server.stop(0); // normal termination
    }
}</pre><p>For convenience, this <code class="literal">AdagesPublisher</code> class is in the <code class="literal">adages</code> package together with
<code class="literal">Adage</code>, <code class="literal">Adages</code>, and <code class="literal">RestfulAdage</code>. To compile, the JAR file <span class="emphasis"><em>jersey-core.jar</em></span> must be on the
classpath; to run, that file and <span class="emphasis"><em>jersey-server.jar</em></span> must be on the classpath. The ZIP that
contains the sample code has an executable JAR file <span class="emphasis"><em>AdagesPublish.jar</em></span> that includes all of the
dependencies. The JAR can be executed from the command line:</p><pre class="screen">% java -jar AdagesPublish.jar</pre><p>The <code class="literal">AdagesPublisher</code> awaits connections on port 9876 (line 1) and the URI (line 2) is
<code class="literal">/resourcesA</code>. Accordingly, the base URL is:</p><pre class="screen">http://localhost:9876/resourcesA/</pre><p>The JAX-RS utility publisher uses classes such as <code class="literal">HttpServer</code> and <code class="literal">HttpHandler</code>, which
come with core Java. Later examples will put these and related classes to use. The point for
now is that there are options for publishing JAX-RS services, including a very lightweight
option. The <span class="emphasis"><em>adages</em></span> web service performs the same way regardless of how it is published.
The Jersey
implementation does a nice job of cleanly separating JAX-RS services from their publication.</p></div><div class="sidebar" title="Publishing JAX-RS resources with Tomcat"><p class="title"><b>Publishing JAX-RS resources with Tomcat</b></p><p>The JAX-RS and Jersey packages do not come with the core Java JDK; instead, the relevant JAR files can be
found at <span class="emphasis"><em>jersey.java.net</em></span>. There is a Maven repository from which a Maven script can install
Jersey and its dependencies but the standalone JAR files are available as well. The Maven approach deliberately
hides the deployment details to make life easier for the developer. The goal here, however, is to
understand how things work under the hood. In any case,
working directly with the JARs is straightforward.</p><p>JAX-RS resources can be published as usual with the Ant <span class="emphasis"><em>build.xml</em></span> script.
For example, the command to deploy a JAX-RS resource in the WAR file named <span class="emphasis"><em>adages</em></span>
is</p><pre class="screen">% ant -Dwar.name=adages deploy</pre><p>As usual, the relevant files would be in a <span class="emphasis"><em>src</em></span> directory. In this example, the three <span class="emphasis"><em>.java</em></span> files
are in the <span class="emphasis"><em>src/adages</em></span> subdirectory. The remaining files, including four Jersey JARs, are in
<span class="emphasis"><em>src</em></span>. The relevant JAR files, with approximate sizes, are</p><pre class="screen">asm.jar             ;;  43K bytes
jersey-core.jar     ;; 206K bytes
jersey-server.jar   ;; 595K bytes
jersey-servlet.jar  ;; 125K bytes</pre><p>The last three JARs are available, for convenience, in a <span class="emphasis"><em>jersey-bundle.jar</em></span>.</p><p>There are different ways to
make these four JARs accessible to Tomcat. The JAR files could be copied to <span class="emphasis"><em>TOMCAT_HOME/lib</em></span> and thereby
be made available to any WAR file deployed under Tomcat. (Recall that Tomcat must be restarted after
files are copied to its <span class="emphasis"><em>lib</em></span> directory in contrast to its <span class="emphasis"><em>webapps</em></span> directory.) The problem with
this approach is version control. Should new versions of the JARs be installed as they come out?
If so, will these new versions break already deployed web services? A more conservative approach is to
<span class="emphasis"><em>freeze</em></span> a deployed WAR file by packing the four JARs within the WAR file. This approach also
makes it easier to port the WAR from one web server to another, for instance, from Tomcat on one
machine to Tomcat on another machine, or from Tomcat to Jetty, and so on. The one downside to packing the JARs inside
the WAR is, of course, that the WAR file becomes larger. My preference is to include the required JARs
within the WAR file. With this approach, the contents of deployed WAR file <span class="emphasis"><em>adages.war</em></span> are:</p><pre class="screen">WEB-INF/web.xml
WEB-INF/classes/adages/Adage.class
WEB-INF/classes/adages/Adages.class
WEB-INF/classes/adages/RestfulAdage.class
WEB-INF/lib/asm.jar
WEB-INF/lib/jackson-annotations.jar
WEB-INF/lib/jackson-core.jar
WEB-INF/lib/jackson-databind.jar
WEB-INF/lib/jersey-core.jar
WEB-INF/lib/jersey-server.jar
WEB-INF/lib/jersey-servlet.jar</pre><p>The three JAR files that begin with <code class="literal">jackson</code> handle the generation of JSON documents. Jackson is a collection of
Java packages (<span class="emphasis"><em>jackson.codehaus.org</em></span>) for producing and consuming JSON documents. The main text
explains how Jackson works with the rest of the service.</p><p>The class <code class="literal">adages.RestfulAdage</code> (see <a class="xref" href="#Ex5" title="Example 5. The JAX-RS Application subclass that lists Adages.class as a resource.">Example 5, “The JAX-RS <code class="literal">Application</code> subclass that lists <code class="literal">Adages.class</code> as a resource.”</a>) encapsulates a <code class="literal">getClasses</code> method, whose role can be clarified
with reference to the deployment file <span class="emphasis"><em>web.xml</em></span>. A JAX-RS service deployed under Tomcat needs
a minimalist <span class="emphasis"><em>web.xml</em></span> to set up communication between the servlet container and the service.
Here is an example, which can be used with any Jersey JAX-RS service published with Tomcat (or Jetty):</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;jersey&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
       com.sun.jersey.spi.container.servlet.ServletContainer
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
&lt;/web-app&gt;</pre><p>The <code class="literal">load-on-startup</code> element prompts Tomcat to instantiate and
load an instance of the Jersey <code class="literal">ServletContainer</code> during the WAR bootstrap process; and the critical role of
the <code class="literal">ServletContainer</code> is to scan the deployed WAR file for Jersey <code class="literal">Application</code>
classes. Here is a slice of Tomcat’s <span class="emphasis"><em>catalina.out</em></span> log file, edited for readability:</p><pre class="screen">INFO: Deploying web application archive adages.war
INFO: Registering Jersey servlet application, named adages.RestfulAdage,  <a id="CO1-16"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
      at the servlet mapping, /resources/*, with the Application class
      of the same name
INFO: Scanning for root resource in the Web app resource paths:
INFO: Root resource classes found: class adages.Adages                    <a id="CO1-17"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
INFO: Instantiated the Application class adages.RestfulAdage</pre><p>The upshot of this log segment is that the Jersey <code class="literal">ServletContainer</code> finds the
class <code class="literal">RestfulAdage</code> (line 1), which in turn identifies the JAX-RS
resources in the WAR file (line 2). In this case, there is only one
such resource: <code class="literal">Adages</code>. By the way, if multiple JAX-RS services are
deployed to a servlet container, then each service should have a unique name for the
class that extends <code class="literal">Application</code>. In this first example, the class is named
<code class="literal">RestfulAdage</code>; in a later example, the name is <code class="literal">RestfulPrediction</code> to avoid
conflict.</p><p>The JAX-RS service in the deployed WAR file, <span class="emphasis"><em>adages.war</em></span>, is now ready to accept requests
such as</p><pre class="screen">% curl http://localhost:8080/adages/resourcesA/</pre></div><p>The <code class="literal">Adage</code> class (see <a class="xref" href="#Ex6" title="Example 6. The Adage POJO class annotated for XML generation through JAX-B.">Example 6, “The <code class="literal">Adage</code> POJO class annotated for XML generation through JAX-B.”</a>) has an <code class="literal">import</code> for the JAX-B (Java API for XML-Binding)
annotation <code class="literal">XmlRootElement</code>. The term <span class="emphasis"><em>binding</em></span> refers, in this context, to linking a
Java data type such as <code class="literal">String</code> to an XML type, in this case <code class="literal">xsd:string</code>.</p><div class="example"><a id="Ex6"></a><p class="title"><b>Example 6. The <code class="literal">Adage</code> POJO class annotated for XML generation through JAX-B.</b></p><div class="example-contents"><pre class="screen">package adages;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "adage")                              <a id="CO1-18"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
public class Adage {
    private String words;
    private int wordCount;

    public Adage() { }
    @Override
    public String toString() {
        return words + " -- " + wordCount + " words";
    }
    public void setWords(String words) {
        this.words = words;
        this.wordCount = words.trim().split("\\s+").length;
    }
    public String getWords() { return this.words; }
    public void setWordCount(int wordCount) { }
    public int getWordCount() { return this.wordCount; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">@XmlRootElement</code> annotation (line 1) signals that an <code class="literal">Adage</code> object can be transformed into an XML document
whose <span class="emphasis"><em>document</em></span> or <span class="emphasis"><em>root</em></span> (that is, outermost) element is named <code class="literal">adage</code>.
For example, the XML document</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;adage&gt;
  &lt;wordCount&gt;7&lt;/wordCount&gt;
  &lt;words&gt;What can be shown cannot be said.&lt;/words&gt;
&lt;/adage&gt;</pre><p>results from the JAX-B transformation of an in-memory <code class="literal">Adage</code> object.</p><p>The <code class="literal">Adages</code> class (see <a class="xref" href="#Ex7" title="Example 7. The Adages class as a JAX-RS resource.">Example 7, “The <code class="literal">Adages</code> class as a JAX-RS resource.”</a>) is a JAX-RS <span class="emphasis"><em>resource</em></span> that accepts RESTful requests, in
this case only GET requests, and responds with payloads of these three MIME types: <code class="literal">text/plain</code>,
<code class="literal">application/json</code>, and <code class="literal">application/xml</code>.</p><div class="example"><a id="Ex7"></a><p class="title"><b>Example 7. The <code class="literal">Adages</code> class as a JAX-RS resource.</b></p><div class="example-contents"><pre class="screen">package adages;

import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.JAXBElement;
import javax.xml.namespace.QName;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.util.Random;
import com.fasterxml.jackson.databind.ObjectMapper;

@Path("/")
public class Adages {
    // Add aphorisms to taste...
    private String[ ] aphorisms =
       {"What can be shown cannot be said.",
        "If a lion could talk, we could not understand him.",
        "Philosophy is a battle against the bewitchment of " +
        "our intelligence by means of language.",
        "Ambition is the death of thought.",
        "The limits of my language mean the limits of my world."};
    public Adages() { }
    @GET
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml"
    public JAXBElement&lt;Adage&gt; getXml() {
        return toXml(createAdage());
    }
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public String getJson() {
        return toJson(createAdage());
    }
    @GET
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/plain")
    public String getPlain() {
        return createAdage().toString() + "\n";
    }
    // Create an Adage and set the words property, which
    // likewise sets the wordCount property. The adage is
    // randomly selected from the array, aphorisms.
    private Adage createAdage() {
        Adage adage = new Adage();
        adage.setWords(aphorisms[new Random().nextInt(aphorisms.length)]);
        return adage;
    }
    // Java Adage --&gt; XML document
    @XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
    private JAXBElement&lt;Adage&gt; toXml(Adage adage) {
        return new JAXBElement&lt;Adage&gt;(new QName("adage"), Adage.class, adage);
    }
    // Java Adage --&gt; JSON document
    // Jersey provides automatic conversion to JSON using the Jackson
    // libraries. In this example, the conversion is done manually
    // with the Jackson libraries just to indicate how straightforward it is.
    private String toJson(Adage adage) {
        String json = "If you see this, there's a problem.";
        try {
            json = new ObjectMapper().writeValueAsString(adage);
        }
        catch(Exception e) { }
        return json;
    }
}</pre></div></div><br class="example-break" /><p>Perhaps the best way to clarify how the three Java classes interact is through sample
client calls. To begin, consider the request</p><pre class="screen">% curl localhost:8080/adages/resourcesA/plain</pre><p>On a sample run, the output was:</p><pre class="screen">What can be shown cannot be said. -- 7 words</pre><p>The RESTful routing of the client’s request works as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
In the URI <span class="emphasis"><em>/adages/resources/plain</em></span>, the initial segment <span class="emphasis"><em>/adages</em></span> specifies the deployed WAR file <span class="emphasis"><em>adages.war</em></span>.
</li><li class="listitem">
The next sub-segment <span class="emphasis"><em>/resourcesA</em></span> represents the JAX-RS <code class="literal">ApplicationPath</code>, information that the WAR file’s <code class="literal">RestfulAdage</code> provides to the web server.
</li><li class="listitem"><p class="simpara">
The next sub-segment is <span class="emphasis"><em>/</em></span>. Recall that the RESTful resource in this web service is the <code class="literal">Adages</code> class, which begins:
</p><pre class="screen">@Path("/")
public class Adages {
...</pre><p class="simpara">The <code class="literal">@Path("/")</code> annotation represents the last slash in the URI <span class="emphasis"><em>adages/resources/</em></span>. Accordingly, this URI maps to the <code class="literal">Adages</code> class, which is
the one and only JAX-RS resource in the deployed WAR file <span class="emphasis"><em>adages.war</em></span>.</p></li><li class="listitem"><p class="simpara">
The final sub-segment in the URI is <span class="emphasis"><em>plain</em></span> so that full URI is
</p><pre class="screen">/adages/resources/plain</pre><p class="simpara">The <code class="literal">Adages</code> method <code class="literal">getPlain</code> is</p><pre class="screen">@GET
@Produces({MediaType.TEXT_PLAIN})
@Path("/plain")
public String getPlain() {
   return createAdage().toString() + "\n";
}</pre><p class="simpara">The <code class="literal">@GET</code> annotation signals that the method/operation <code class="literal">getPlain</code>, an arbitrary name, is accessible through a GET request only.
The <code class="literal">@Produces</code> annotation promises, in effect,
to respond with the MIME type <code class="literal">text/plain</code>. This is a promise rather than a guarantee. The <code class="literal">@Path</code> annotation indicates the URI sub-segment
<span class="emphasis"><em>/plain</em></span> completes the path to this service operation.</p></li></ul></div><p>The RESTful routing idioms used in JAX-RS follow the spirit, if not the exact syntax, of those from the Rails framework.
These idioms support clear, terse URIs such as</p><pre class="screen">/adages/resourcesA/plain</pre><p>and</p><pre class="screen">adages/resourcesA/json</pre></div><div class="section" title="1.3.2. JAX-RS Generation of XML and JSON Responses"><div class="titlepage"><div><div><h4 class="title"><a id="_jax_rs_generation_of_xml_and_json_responses"></a>1.3.2. JAX-RS Generation of XML and JSON Responses</h4></div></div></div><p>The interaction between the JAX-RS resource class <code class="literal">Adages</code> and the POJO class <code class="literal">Adage</code> needs clarification.  Recall that class <code class="literal">Adage</code> begins</p><pre class="screen">@XmlRootElement(name = "adage")
public class Adage {
...</pre><p>and that the annotation <code class="literal">@XmlRootElement</code> allows an <code class="literal">Adage</code> instance to be serialized into an XML document with <code class="literal">&lt;adage&gt;</code> as its document-level
start tag. In the language of JAX-RS, the <code class="literal">Adage</code> class is a <span class="emphasis"><em>provider</em></span> of XML.
(See the sidebar for details about how JAX-B uses an XML Schema to generate the XML.) <code class="literal">Adage</code> is likewise a POJO class
with the familiar <span class="emphasis"><em>get/set</em></span> methods for two properties, <code class="literal">words</code> and <code class="literal">wordCount</code>. The only unusual
detail is that the <code class="literal">setWords</code> method also sets the <code class="literal">wordCount</code> for the adage</p><pre class="screen">public void setWords(String words) {
   this.words = words;
   this.wordCount = words.trim().split("\\s+").length; // word count
}</pre><p>because this is a convenient way to do so.</p><div class="sidebar" title="How JAX-B can transform a Java object into an XML document"><p class="title"><b>How JAX-B can transform a Java object into an XML document</b></p><p>The <span class="emphasis"><em>adages</em></span> JAX-RS service uses the JAX-B library, under the hood, to transform a Java object, an <code class="literal">Adage</code> instance, into an
XML document such as:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;adage&gt;
  &lt;wordCount&gt;14&lt;/wordCount&gt;
  &lt;words&gt;
    Philosophy is a battle against the bewitchment of our intelligence
    by means of language.
  &lt;/words&gt;
&lt;/adage&gt;</pre><p>The <code class="literal">@XmlRootElement</code> annotation on the <code class="literal">Adage</code> class guides the transformation by indicating
that the outermost XML element is to be named <code class="literal">adage</code>; and the return data type <code class="literal">JAXBElement&lt;Adage&gt;</code> in the <code class="literal">getXml</code>
method represents, in Java, an XML element—including an entire XML document. This sidebar delves into the
details.</p><p>The core Java JDK has a <span class="emphasis"><em>schemagen</em></span> utility <sup>[<a id="idp5921584" href="#ftn.idp5921584" class="footnote">1</a>]</sup>
that, when applied to a POJO source file such as <span class="emphasis"><em>Adage.java</em></span>,
generates an XML Schema. The utility can be invoked from the command-line:</p><pre class="screen">% schemagen Adage.java</pre><p>The resulting XML Schema document is:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:complexType name="Adage"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="words" type="xs:string"/&gt;
      &lt;xs:element name="wordCount" type="xs:int"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre><p>This XML Schema document has all of the information that JAX-B utilities would need to go from an
XML <code class="literal">adage</code> document to a Java <code class="literal">Adage</code> instance:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The XML Schema indicates that the data type, an XML <code class="literal">complexType</code>, is named <code class="literal">Adage</code>. In this
context, a <code class="literal">complexType</code> is contrasted with a simple, built-in type such as <code class="literal">xsd:string</code>.
The <code class="literal">Adage</code> class is programmer-defined rather than built-in as well.
When an <code class="literal">Adage</code> instance is constructed, its two properties, <code class="literal">words</code> and <code class="literal">wordCount</code>, are
available for setting.
</li><li class="listitem">
The XML Schema specifies an element named <code class="literal">words</code> and another element named <code class="literal">wordCount</code>, with the data type
of each: a <code class="literal">word</code> in XML is an <code class="literal">xs:string</code>, which binds to a Java <code class="literal">String</code>; and a <code class="literal">wordCount</code> is
in XML is an <code class="literal">xs:int</code>, which binds to a Java <code class="literal">int</code>. JAX-B thus works from the convention that
the <code class="literal">Adage</code> elements in the XML Schema correspond to Java properties, with the corresponding
<span class="emphasis"><em>set</em></span>-methods, in this case <code class="literal">setWords</code> and <code class="literal">setWordCount</code>.
</li></ul></div><p>In summary, the JDK <span class="emphasis"><em>schemagen</em></span> utility can generate an XML Schema instance from a Java class.
A second JDK utility, <span class="emphasis"><em>xjc</em></span>, works in the other direction. Given an XML Schema, <span class="emphasis"><em>xjc</em></span> can generate Java
classes to represent the XML types in the schema. Such processing details, which remain hidden in the Jersey
implementation of JAX-RS, will be investigated carefully in Chapter 3. This first look at the
Java-to-XML transformation sketches the kind of processing that Jersey must perform to transform an
<code class="literal">Adage</code> into an XML document.</p></div><p>The <code class="literal">Adages</code> resource has three methods that define the web service operations, the methods named <code class="literal">getJson</code>, <code class="literal">getPlain</code>,
and <code class="literal">getXml</code>. The
operation names are arbitrary. The important routing information for each operation comes from the annotations that
describe the HTTP verb (in this case, only GET) and the <code class="literal">@Path</code>. The  <code class="literal">getXml</code> operation has no <code class="literal">@Path</code> annotation, which
means that the path for the resource, the <code class="literal">Adages</code> class, is the the path for this operation; and the path is
<span class="emphasis"><em>/adages/resourcesA/</em></span>. In effect, <code class="literal">getXml</code> is the default operation.</p><p>The <code class="literal">getJson</code> and <code class="literal">getXml</code> operations could be combined into a single operation</p><pre class="screen">@GET
@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
...</pre><p>because Jersey can coordinate directly with the Jackson libraries to process JSON. My implementation uses Jackson explicitly to show
just how simple the API is. Further, if the two operations were combined into one, then a client would have to disambiguate the request by
adding the HTTP header</p><pre class="screen">Accept: application/json</pre><p>to the HTTP request. It seems cleaner to use two different URIs: <span class="emphasis"><em>/adages/resourcesA/</em></span>
maps to the default <code class="literal">getXml</code> operation, whereas <span class="emphasis"><em>/adages/resourcesA/json</em></span> maps to the <code class="literal">getJson</code> operation. Here for review is the utility method
that <code class="literal">getJson</code> calls to produce the JSON:</p><pre class="screen">private String toJson(Adage adage) {
   String json = "If you see this, there's a problem.";
   try {
      json = new ObjectMapper().writeValueAsString(adage); <a id="CO1-19"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   } catch(Exception e) { }
   return json;
}</pre><p>The Jackson <code class="literal">ObjectMapper</code> encapsulates the method <code class="literal">writeValueAsString</code> (line 1),
which serializes an <code class="literal">Adage</code> into a JSON document.
The response for a sample request against the <code class="literal">toJson</code> operation,
formatted for readability, would look like this:</p><pre class="screen">{"words":    "The limits of my language mean the limits of my world.",
 "wordCount":11
}</pre><p>Similar serialization occurs with respect to an <code class="literal">Adage</code> converted into an XML document.
The default operation <code class="literal">getXml</code></p><pre class="screen">@GET
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public JAXBElement&lt;Adage&gt; getXml() {
   return toXml(createAdage());
}</pre><p>returns a <code class="literal">JAXBElement&lt;Adage&gt;</code>, an XML document that represents an <code class="literal">Adage</code>. Under the hood the JAX-B
processor converts an <code class="literal">Adage</code> instance into an XML document. On a sample run the output was</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;adage&gt;
  &lt;wordCount&gt;10&lt;/wordCount&gt;
  &lt;words&gt;If a lion could talk, we could not understand him.&lt;/words&gt;
&lt;/adage&gt;</pre><p>The POJO class <code class="literal">Adage</code> currently has but one annotation, <code class="literal">@XmlRootElement</code>. A variety of others could
be used to refine the XML output. Here is a sample refinement:</p><pre class="screen">package adages;
...
@XmlRootElement(name = "adage")
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(propOrder = {"words", "wordCount"})  <a id="CO1-20"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
public class Adage {
    @XmlElement(required = true)
    protected String words;
    @XmlElement(required = true)
    protected int wordCount;
    ...</pre><p>The <code class="literal">@XmlType</code> (line 1) is particularly useful if the order of elements in the generated XML document matters.
In the current implementation, the <code class="literal">wordCount</code> element precedes the <code class="literal">words</code> element; but this order
could be reversed through the <code class="literal">propOrder</code> attribute in the <code class="literal">@XmlType</code> annotation (line 1).</p><p>This first JAX-RS example illustrates the style of implementing a RESTful web service as a
JAX-RS resource. The deployment under Tomcat is uncomplicated; and the <span class="emphasis"><em>adages.war</em></span> file also can
be deployed, as is, under Jetty.
The <span class="emphasis"><em>adages</em></span> service supports only GET requests. The forthcoming <span class="emphasis"><em>adages2</em></span> service, implemented as a set of
Restlet resources, supports all of the CRUD operations. The next section also shows, with a different
example, how JAX-RS nicely
supports all of the CRUD operations.</p></div><div class="section" title="1.3.3. Porting the predictions Web Service to JAX-RS"><div class="titlepage"><div><div><h4 class="title"><a id="_porting_the_emphasis_predictions_emphasis_web_service_to_jax_rs"></a>1.3.3. Porting the <span class="emphasis"><em>predictions</em></span> Web Service to JAX-RS</h4></div></div></div><p>The servlet-based <span class="emphasis"><em>predictions2</em></span> service supports the four CRUD operations; hence, the port from the servlet/JSP implementations to
JAX-RS is an opportunity to show the <code class="literal">@POST</code>, <code class="literal">@PUT</code>, and <code class="literal">@DELETE</code> annotations and to illustrate
parametrized versions of the <code class="literal">@GET</code> and <code class="literal">@DELETE</code> operations. This revision highlights again the JAX-RS idioms
for RESTful URIs. The revised service is called <span class="emphasis"><em>predictions3</em></span>.</p><p>The JAX-RS <span class="emphasis"><em>predictions3</em></span> service has four Java classes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The <code class="literal">RestfulPrediction</code> class extends the JAX-RS <code class="literal">Application</code> class. When the service WAR file is loaded into Tomcat or Jetty, the Jersey
<code class="literal">ServletContainer</code> finds the <code class="literal">RestfulPrediction</code> instance and invokes its <code class="literal">getClasses</code> method to identify the RESTful
resources in the WAR file. In the case of the <code class="literal">RestfulPrediction</code> service, there is only one resource: the
<code class="literal">PredictionsRS</code> class.
</li><li class="listitem">
The <code class="literal">PredictionsRS</code> class is the RESTful resource, a POJO class whose methods carry annotations such as <code class="literal">@GET</code> and <code class="literal">@POST</code> in
support of the standard CRUD operations. This resource supports MIME-typed requests for XML, JSON, and plain text. A
GET request can ask for all predictions or for a specific one.
</li><li class="listitem">
The <code class="literal">Prediction</code> class is a also a POJO class with two properties from before: <code class="literal">who</code> is the author of the prediction and
<code class="literal">what</code> is the prediction itself. There is still an <code class="literal">id</code> property whose value uniquely identifies each <code class="literal">Prediction</code> instance;
prediction instances are stored, in ascending order by <code class="literal">id</code>, in a <code class="literal">PredictionsList</code>, explained in the next bullet point.
The <code class="literal">Prediction</code> class is annotated as an <code class="literal">@XmlRootElement</code> so that Jersey can automatically convert
a single prediction into an XML document. The <span class="emphasis"><em>get</em></span>-methods of the properties are annotated with
<code class="literal">@XmlElement</code> for emphasis. A <code class="literal">Prediction</code> instance can be transformed into an XML or a JSON document; the <code class="literal">Prediction</code> override
of the <code class="literal">toString</code> method supports a plain-text format as well. The <code class="literal">Prediction</code> class still implements the
<code class="literal">Comparable</code> interface in case sorting is needed. The implementation logic of <span class="emphasis"><em>predictions3</em></span> ensures, however, that the
predictions are always sorted by <code class="literal">id</code> in ascending order; hence, additional sorting might put the predictions in descending order
by <code class="literal">id</code>, ascending order by <code class="literal">who</code>, and so on.
</li><li class="listitem">
The <code class="literal">PredictionsList</code> is a class that represents a collection of <code class="literal">Prediction</code> instances, with the collection implemented as
a thread-safe <code class="literal">CopyOnWriteArrayList</code>. The integer <code class="literal">id</code> of each prediction added to the list is generated with a thread-safe
<code class="literal">AtomicInteger</code>.
The class <code class="literal">PredictionsList</code> is annotated as an <code class="literal">@XmlRootElement</code> so that Jersey
automatically serializes a list of predictions, as well as a single prediction, into XML. The <code class="literal">PredictionsList</code> class likewise
overrides the <code class="literal">toString</code> method, yet again a convenient way to support a plain-text representation of a predictions list.
</li></ul></div><p>The <code class="literal">RestfulPrediction</code> class (see <a class="xref" href="#Ex8" title="Example 8. Registering the PredictionsRS class as a JAX-RS resource">Example 8, “Registering the <code class="literal">PredictionsRS</code> class as a JAX-RS resource”</a>) is the JAX-RS <code class="literal">Application</code> class. To ensure that the <span class="emphasis"><em>adages</em></span>
JAX-RS service of Section 3.1 and this
JAX-RS service can co-exist in the same servlet container, the names of the two <code class="literal">Application</code> classes must differ:
in the case of <span class="emphasis"><em>adages</em></span>, the <code class="literal">Application</code> class is <code class="literal">RestfulAdage</code>; and in this case, the <code class="literal">Application</code> class is
<code class="literal">RestfulPrediction</code>.</p><div class="example"><a id="Ex8"></a><p class="title"><b>Example 8. Registering the <code class="literal">PredictionsRS</code> class as a JAX-RS resource</b></p><div class="example-contents"><pre class="screen">package predictions3;

import java.util.Set;
import java.util.HashSet;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/resourcesP")
public class RestfulPrediction extends Application {
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        Set&lt;Class&lt;?&gt;&gt; set = new HashSet&lt;Class&lt;?&gt;&gt;();
        set.add(PredictionsRS.class);
        return set;
    }
}</pre></div></div><br class="example-break" /><p>The back-end support for the <code class="literal">PredictionsRS</code> source consists of two POJO classes, <code class="literal">Prediction</code> (see <a class="xref" href="#Ex9" title="Example 9. The Prediction class with properties who, what, and id">Example 9, “The <code class="literal">Prediction</code> class with properties <code class="literal">who</code>, <code class="literal">what</code>, and <code class="literal">id</code>”</a>) and
<code class="literal">PredictionsList</code> (see <a class="xref" href="#Ex10" title="Example 10. The PredictionsList class">Example 10, “The <code class="literal">PredictionsList</code> class”</a>). The class <code class="literal">Prediction</code> is mostly unchanged from the <span class="emphasis"><em>predictions2</em></span> version except for
the added <code class="literal">@XmlRootElement</code> annotation, which means that the run-time can automatically convert a
<code class="literal">Prediction</code> instance into an XML document. Details follow shortly.</p><div class="example"><a id="Ex9"></a><p class="title"><b>Example 9. The <code class="literal">Prediction</code> class with properties <code class="literal">who</code>, <code class="literal">what</code>, and <code class="literal">id</code></b></p><div class="example-contents"><pre class="screen">package predictions3;

import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;

@XmlRootElement(name = "prediction")
public class Prediction implements Comparable&lt;Prediction&gt; {
    private String who;   // person
    private String what;  // his/her prediction
    private int    id;    // identifier used as lookup-key

    public Prediction() { }
    @Override
    public String toString() {
        return String.format("%2d: ", id) + who + " ==&gt; " + what + "\n";
    }
    public void setWho(String who) { this.who = who; }
    @XmlElement
    public String getWho() { return this.who; }
    public void setWhat(String what) { this.what = what; }
    @XmlElement
    public String getWhat() { return this.what; }
    public void setId(int id) { this.id = id; }
    @XmlElement
    public int getId() { return this.id; }
    public int compareTo(Prediction other) { return this.id - other.id; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PredictionsList</code> POJO class (see <a class="xref" href="#Ex10" title="Example 10. The PredictionsList class">Example 10, “The <code class="literal">PredictionsList</code> class”</a>) in the <span class="emphasis"><em>predictions3</em></span> service is simpler overall than the
<code class="literal">Predictions</code> from class of <span class="emphasis"><em>predictions2</em></span> because methods such as <code class="literal">populate</code> have moved into the core JAX-RS class.
In any case, the <code class="literal">PredictionsList</code> class has a <code class="literal">find</code> method to search for a particular <code class="literal">Prediction</code>; and the
data structure used to store the predictions is now a thread-safe <code class="literal">CopyOnWriteArrayList</code>.</p><div class="example"><a id="Ex10"></a><p class="title"><b>Example 10. The <code class="literal">PredictionsList</code> class</b></p><div class="example-contents"><pre class="screen">package predictions3;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "predictionsList")
public class PredictionsList {
    private List&lt;Prediction&gt; preds;
    private AtomicInteger predId;

    public PredictionsList() {
        preds = new CopyOnWriteArrayList&lt;Prediction&gt;();
        predId = new AtomicInteger();
    }
    @XmlElement
    @XmlElementWrapper(name = "predictions")
    public List&lt;Prediction&gt; getPredictions() {
        return this.preds;
    }
    public void setPredictions(List&lt;Prediction&gt; preds) {
        this.preds = preds;
    }
    @Override
    public String toString() {
        String s = "";
        for (Prediction p : preds) s += p.toString();
        return s;
    }
    public Prediction find(int id) {
        Prediction pred = null;
        // Search the list -- for now, the list is short enough that
        // a linear search is ok but binary search would be better if the
        // list got to be an order-of-magnitude larger in size.
        for (Prediction p : preds) {
            if (p.getId() == id) {
                pred = p;
                break;
            }
        }
        return pred;
    }
    public int add(String who, String what) {
        int id = predId.incrementAndGet();
        Prediction p = new Prediction();
        p.setWho(who);
        p.setWhat(what);
        p.setId(id);
        preds.add(p);
        return id;
    }
}</pre></div></div><br class="example-break" /><div class="example"><a id="Ex11"></a><p class="title"><b>Example 11. The JAX-RS resource <code class="literal">PredictionsRS</code></b></p><div class="example-contents"><pre class="screen">package predictions3;

import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.DELETE;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.FormParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Context;
import javax.servlet.ServletContext;
import com.fasterxml.jackson.databind.ObjectMapper;

@Path("/")
public class PredictionsRS {
    @Context
    private ServletContext sctx;          // dependency injection
    private static PredictionsList plist; // set in populate()

    public PredictionsRS() { }

    @GET
    @Path("/xml")
    @Produces({MediaType.APPLICATION_XML})
    public Response getXml() {
        checkContext();
        return Response.ok(plist, "application/xml").build();
    }
    @GET
    @Path("/xml/{id: \\d+}")
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
    public Response getXml(@PathParam("id") int id) {
        checkContext();
        return toRequestedType(id, "application/xml");
    }
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public Response getJson() {
        checkContext();
        return Response.ok(toJson(plist), "application/json").build();
    }
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json/{id: \\d+}")
    public Response getJson(@PathParam("id") int id) {
        checkContext();
        return toRequestedType(id, "application/json");
    }
    @GET
    @Path("/plain")
    @Produces({MediaType.TEXT_PLAIN})
    public String getPlain() {
        checkContext();
        return plist.toString();
    }
    @POST
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/create")
    public Response create(@FormParam("who") String who,
                           @FormParam("what") String what) {
        checkContext();
        String msg = null;
        // Require both properties to create.
        if (who == null || what == null) {
            msg = "Property 'who' or 'what' is missing.\n";
            return Response.status(Response.Status.BAD_REQUEST).
                                                   entity(msg).
                                                   type(MediaType.TEXT_PLAIN).
                                                   build();
        }
        // Otherwise, create the Prediction and add it to the collection.
        int id = addPrediction(who, what);
        msg = "Prediction " + id + " created: (who = " + who + " what = " + what + ").\n";
        return Response.ok(msg, "text/plain").build();
    }
    @PUT
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/update")
    public Response update(@FormParam("id") int id,
                           @FormParam("who") String who,
                           @FormParam("what") String what) {
        checkContext();
        // Check that sufficient data are present to do an edit.
        String msg = null;
        if (who == null &amp;&amp; what == null)
            msg = "Neither who nor what is given: nothing to edit.\n";
        Prediction p = plist.find(id);
        if (p == null)
            msg = "There is no prediction with ID " + id + "\n";

        if (msg != null)
            return Response.status(Response.Status.BAD_REQUEST).
                                                   entity(msg).
                                                   type(MediaType.TEXT_PLAIN).
                                                   build();
        // Update.
        if (who != null) p.setWho(who);
        if (what != null) p.setWhat(what);
        msg = "Prediction " + id + " has been updated.\n";
        return Response.ok(msg, "text/plain").build();
    }
    @DELETE
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/delete/{id: \\d+}")
    public Response delete(@PathParam("id") int id) {
        checkContext();
        String msg = null;
        Prediction p = plist.find(id);
        if (p == null) {
            msg = "There is no prediction with ID " + id + ". Cannot delete.\n";
            return Response.status(Response.Status.BAD_REQUEST).
                                                   entity(msg).
                                                   type(MediaType.TEXT_PLAIN).
                                                   build();
        }
        plist.getPredictions().remove(p);
        msg = "Prediction " + id + " deleted.\n";
        return Response.ok(msg, "text/plain").build();
    }
    private void checkContext() {
        if (plist == null) populate();
    }
    private void populate() {
        plist = new PredictionsList();
        String filename = "/WEB-INF/data/predictions.db";
        InputStream in = sctx.getResourceAsStream(filename);
        // Read the data into the array of Predictions.
        if (in != null) {
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                int i = 0;
                String record = null;
                while ((record = reader.readLine()) != null) {
                    String[] parts = record.split("!");
                    addPrediction(parts[0], parts[1]);
                }
            }
            catch (Exception e) {
                throw new RuntimeException("I/O failed!");
            }
        }
    }
    private int addPrediction(String who, String what) {
        int id = plist.add(who, what);
        return id;
    }
    // Prediction --&gt; JSON document
    private String toJson(Prediction prediction) {
        String json = "If you see this, there's a problem.";
        try {
            json = new ObjectMapper().writeValueAsString(prediction);
        }
        catch(Exception e) { }
        return json;
    }
    // PredictionsList --&gt; JSON document
    private String toJson(PredictionsList plist) {
        String json = "If you see this, there's a problem.";
        try {
            json = new ObjectMapper().writeValueAsString(plist);
        }
        catch(Exception e) { }
        return json;
    }
    // Generate an HTTP error response or typed OK response.
    private Response toRequestedType(int id, String type) {
        Prediction pred = plist.find(id);
        if (pred == null) {
            String msg = id + " is a bad ID.\n";
            return Response.status(Response.Status.BAD_REQUEST).
                                                   entity(msg).
                                                   type(MediaType.TEXT_PLAIN).
                                                   build();
        }
        else if (type.contains("json"))
            return Response.ok(toJson(pred), type).build();
        else
            return Response.ok(pred, type).build(); // toXml is automatic
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PredictionsRS</code> class (see <a class="xref" href="#Ex11" title="Example 11. The JAX-RS resource PredictionsRS">Example 11, “The JAX-RS resource <code class="literal">PredictionsRS</code>”</a>) is the JAX-RS resource with annotations that define the CRUD operations. The
class is long enough that inspecting the code in chunks may be helpful. A summary of the major parts follows.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
There are five operations annotated with <code class="literal">@GET</code>.
</p><p class="simpara">Three of the <code class="literal">@GET</code> operations return the entire list of predictions: in
XML, in JSON, and in plain-text format. In addition, there is a parametrized GET</p><pre class="screen">@GET
@Path("/xml/{id: \\d+}")
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public Response getXml(@PathParam("id") int id) {
...</pre><p class="simpara">that, if successful, returns a single prediction in XML. There is a similarly parametrized GET that,
if successful, returns a
single prediction in JSON. The <code class="literal">@Path</code> annotation</p><pre class="screen">@Path("/xml/{id: \\d+}")</pre><p class="simpara">contains a parameter, <code class="literal">id</code>, together with a regular expression that restricts the values of the
parameter to one or more decimal digits. The regular expression also could be written as</p><pre class="screen">@Path("/xml/{id: [0-9]+}")</pre><p class="simpara">In either case, the regular expression requires at least one but perhaps more decimal digits.
A request such as</p><pre class="screen">% curl http://localhost:8080/predictions3/resourcesP/xml/13</pre><p class="simpara">would succeed and return, as an XML document, the <code class="literal">Prediction</code> with <code class="literal">id</code> 13 because <code class="literal">13</code> matches the
specified pattern. However, a request such as</p><pre class="screen">% curl http://localhost:8080/predictions3/resourcesP/xml/foo</pre><p class="simpara">would result in an HTTP 404 (Not Found) error because <code class="literal">foo</code> does not match the one-or-more-decimal-digits pattern.
The JAX-RS support for precise data validation through regular expressions is, of course, convenient; the only
complication comes in the regular expressions themselves.</p><p class="simpara">The methods that implement parametrized GET operations use the <code class="literal">@PathParam</code> annotation to
identify which argument in a method corresponds to the URI parameter. For example, the <code class="literal">getJson</code>
method begins</p><pre class="screen">@GET
@Produces({MediaType.APPLICATION_JSON})
@Path("/json/{id: \\d+}")
public Response getJson(@PathParam("id") int id) { <a id="CO1-21"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
...</pre><p class="simpara">The <code class="literal">@PathParam</code> named <code class="literal">id</code> (line 1) corresponds, in this example, to the <code class="literal">int</code> parameter named
<code class="literal">id</code> as well. The two names could differ. If a URI had multiple parameters</p><pre class="screen">http://...:8080/greetings/resourcesG/msg/fred/Hi</pre><p class="simpara">then the order of the Java method’s parameters</p><pre class="screen">...
@Path("/msg/{who}/{what}
public Response echoMessage(@PathParam("what") String p1,
                            @PathParam("who") String p2) {
...</pre><p class="simpara">could differ from the order in the URI.</p></li></ul></div><div class="sidebar" title="Why does the predictions3 RESTful service use static class members?"><p class="title"><b>Why does the <span class="emphasis"><em>predictions3</em></span> RESTful service use <code class="literal">static</code> class members?</b></p><p>In a production-grade service, the data typically would be persisted in a database of some kind.
As the <code class="literal">PredictionsRS</code> resource in the <span class="emphasis"><em>predictions3</em></span> service changes through POST, PUT, and DELETE operations,
however, these changes are not persisted in a back-end database; instead, a <code class="literal">static</code> collection is used
to store—in memory—the changing data. My goal is to keep the focus on the APIs for RESTful services,
minimizing distractions wherever possible; and database access would be one such distraction. In a
production-grade service, of course, a persistent data store almost surely would be the way to go. Two later
examples illustrate how the JPA (Java Persistence API) can be used to persist <code class="literal">Predictions</code> with two different
relational database systems.</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
The operations annotated with <code class="literal">@POST</code>, <code class="literal">@PUT</code>, and <code class="literal">@DELETE</code> implement the remaining CRUD operations:
<span class="emphasis"><em>create</em></span>, <span class="emphasis"><em>update</em></span>, and <span class="emphasis"><em>delete</em></span>, respectively.
</p><p class="simpara">In the <span class="emphasis"><em>predictions3</em></span> service, most of the RESTfully annotated operations return the JAX-RS type <code class="literal">Response</code>. This
gives the operations a common look-and-feel that accentuates critical features of an HTTP response: the
HTTP status code together with the content-type of the response. For simplicity, the <code class="literal">getPlain</code> method
returns a <code class="literal">String</code>.
Here is the <code class="literal">return</code> statement from the
non-parametrized <code class="literal">getXml</code> operation, which returns all of the predictions in XML format:</p><pre class="screen">return Response.ok(predictions, "application/xml").build();</pre><p class="simpara">Consider the contrast between this <code class="literal">return</code> statement and its counterpart in the <span class="emphasis"><em>adages</em></span> JAX-RS service:</p><pre class="screen">@GET
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public JAXBElement&lt;Adage&gt; getXml() {
    return toXml(createAdage());
}</pre><p class="simpara">In the <span class="emphasis"><em>adages</em></span> case, the return type is <code class="literal">JAXBElement</code> and there is an explicit call to the <code class="literal">toXml</code>
method to convert an <code class="literal">Adage</code> instance into an XML document:</p><pre class="screen">@XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
private JAXBElement&lt;Adage&gt; toXml(Adage adage) {
   return new JAXBElement&lt;Adage&gt;(new QName("adage"), Adage.class, adage);
}</pre><p class="simpara">By contrast, the <span class="emphasis"><em>predictions3</em></span> service simply returns a <code class="literal">Predictions</code> instance as the <code class="literal">Response</code> without
wrapping the <code class="literal">predictions</code> reference in a call to <code class="literal">toXml</code>:</p><pre class="screen">//**** No need to invoke toXml on the predictions!
return Response.ok(toXml(predictions), "application/xml").build();</pre><p class="simpara">The reason for this simplification is that, with <code class="literal">Response</code> as the return type of the <code class="literal">getXml</code> method, the
JAX-RS run-time automatically generates the XML; and JAX-RS run-time does so because the
<code class="literal">@Produces</code> annotation gives <code class="literal">application/xml</code> as the MIME type of the HTTP response. Recall
that the <code class="literal">Prediction</code> and <code class="literal">PredictionsList</code> POJO classes are annotated with <code class="literal">@XmlRootElement</code>. The
combination of this annotation and the <code class="literal">@Produces</code> annotation together automate the XML
generation.</p></li></ul></div><p>The <span class="emphasis"><em>predictions3</em></span> service still has a <code class="literal">toJson</code> utility method to convert one <code class="literal">Prediction</code> or
a collection of these into JSON. This is a design decision, not a necessity. The JAX-RS run-time also generates
JSON automatically if the relevant Jackson libraries are included and if the HTTP request contains
the header element <code class="literal">Accept: application/json</code>. The conversion to JSON is simple enough that
<span class="emphasis"><em>predictions3</em></span> does it manually, thereby sparing the client the responsibility of adding a specific header element
to the HTTP request.</p><p>The request pattern in the <span class="emphasis"><em>predictions3</em></span> service is uniform as there is no default URI, that is,
a URI consisting solely of the slash <code class="literal">/</code>.
A request for an XML document ends with <code class="literal">/xml</code> for all predictions in XML or, for instance,
<code class="literal">/xml/7</code> to get prediction 7 in XML; a request for JSON ends with <code class="literal">/json</code> or, for example,
<code class="literal">/json/13</code>; and a request for plain text ends with <code class="literal">/plain</code>. The JAX-RS patterns for URIs can adhere
to the Rails URI patterns, now widely imitated, as closely as the programmer likes.</p></div></div><div class="section" title="1.4. A RESTful Web Service as Restlet Resources"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_web_service_as_restlet_resources"></a>1.4. A RESTful Web Service as Restlet Resources</h3></div></div></div><p>The Restlet web framework supports RESTful web services and the API is similar to JAX-RS; indeed,
a Restlet application can use JAX-RS annotations such as <code class="literal">@Produces</code> instead of or in addition to
Restlet annotations. This section adapts the earlier JAX-RS <span class="emphasis"><em>adages</em></span> service to a Restlet
implementation, which is published both with a web server and with a standalone Java application
The revised service, <span class="emphasis"><em>adages2</em></span>, implements the four CRUD operations.</p><div class="sidebar" title="Downloading and using the Restlet framework"><p class="title"><b>Downloading and using the Restlet framework</b></p><p>The Restlet JAR files are available for download at <span class="emphasis"><em>www.restlet.org</em></span>. The current version is
2.x. There are
editions for core and enterprise Java together with tutorials, documentation, and examples.
Restlet, like JAX-RS, provides HTTP-method annotations for <span class="emphasis"><em>resources</em></span>. Restlet has a
client-side and a service-side API.
A Restlet resource published under Tomcat or Jetty can be published, with little change, using
a standard command-line application and a single Restlet JAR file. The framework does a
first-rate job of decoupling the service-as-a-resource from its publication.</p><p>The Restlet framework includes JAR files to interoperate with other popular Java frameworks
such as Spring and the Google Web Toolkit. Restlet even supports, through an extension,
JAX-RS annotations such as <code class="literal">@POST</code> and <code class="literal">@Produces</code>.
There are libraries for Apache’s Velocity templating engine (<span class="emphasis"><em>velocity.apache.org</em></span>),
email, SSL (Secure Sockets Layer), OAuth (<span class="emphasis"><em>oauth.net</em></span>), and various other technologies. Anyone versatile in
either JAX-RS or Restlet should have little trouble adapting to the other; and both approaches are worth
a look.</p></div><p>A Restlet web service has three main parts, each of which consists has one or more Java classes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A programmer-defined class, in this example <code class="literal">AdagesApplication</code>, extends the Restlet <code class="literal">Application</code> class.
The purpose of the extended class is to set up a <span class="emphasis"><em>routing table</em></span>, which maps request URIs to resources.
The resources are named or anonymous Java classes; and the current example illustrates both approaches. The
spirit of Restlet development is to have very simple resource classes.
</li><li class="listitem">
There are arbitrarily many resource classes, any mix of named or anonymous. In best practices, a resource
implementation supports a very small number of operations on the resource, in the current example only one
operation per resource. For example, the <span class="emphasis"><em>adages2</em></span> service has seven resources: six of these are named classes that
extend the Restlet <code class="literal">ServerResource</code> class and the other is an anonymous class that implements the
<code class="literal">Restlet</code> interface. The named classes are <code class="literal">CreateResource</code>, the target of a POST request; <code class="literal">UpdateResource</code>, the
target of a PUT request; <code class="literal">XmlAllResource</code>, the target of a GET request for all <code class="literal">Adages</code> in XML; <code class="literal">JsonAllResource</code>,
the target of a GET request for all <code class="literal">Adages</code> in JSON; <code class="literal">XmlOneResource</code>, the target of a GET request for a
specified <code class="literal">Adage</code>; and so on.
</li><li class="listitem">
The back-end POJO classes are <code class="literal">Adage</code> and <code class="literal">Adages</code>, each slightly redefined from the earlier <span class="emphasis"><em>adages</em></span>
web service.
</li></ul></div><p>If the Restlet service is deployed with a web server such as Tomcat or Jetty, then the Restlet <code class="literal">ServerServlet</code>
acts as an interceptor for requests against the Restlet service. The interceptor servlet interacts with the
Restlet <code class="literal">Application</code>, which contains the routing table, so that a properly formatted request winds up at the
correct Restlet resource. The architecture is simple and clean. Deployment of <span class="emphasis"><em>adages2</em></span> service requires a
<span class="emphasis"><em>web.xml</em></span> document (see <a class="xref" href="#Ex12" title="Example 12. The web.xml file for the adages2 Restlet service">Example 12, “The <span class="emphasis"><em>web.xml</em></span> file for the <span class="emphasis"><em>adages2</em></span> Restlet service”</a>) that sets up the Restlet interceptor (line 1) and links the
interceptor to the Restlet <code class="literal">Application</code> (line 2).</p><div class="example"><a id="Ex12"></a><p class="title"><b>Example 12. The <span class="emphasis"><em>web.xml</em></span> file for the <span class="emphasis"><em>adages2</em></span> Restlet service</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
   &lt;!-- Restlet adapter --&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;RestletServlet&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.restlet.ext.servlet.ServerServlet&lt;/servlet-class&gt;  <a id="CO1-22"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
      &lt;init-param&gt;
        &lt;!-- Application class name --&gt;
        &lt;param-name&gt;org.restlet.application&lt;/param-name&gt;
        &lt;param-value&gt;adages2.AdagesApplication&lt;/param-value&gt;                <a id="CO1-23"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
      &lt;/init-param&gt;
   &lt;/servlet&gt;
   &lt;!-- Dispach all requests to the Restlet servlet. --&gt;
   &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;RestletServlet&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><br class="example-break" /><div class="sidebar" title="The included JAR files for the Restlet adages2 web service"><p class="title"><b>The included JAR files for the Restlet <span class="emphasis"><em>adages2</em></span> web service</b></p><p>The <span class="emphasis"><em>adages2</em></span> service can be deployed to Tomcat in the usual way:</p><pre class="screen">% ant -Dwar.name=adages2 deploy</pre><p>The deployed WAR file includes these JAR files:</p><pre class="screen">org.json.jar
org.restlet.ext.json.jar
org.restlet.ext.servlet.jar
org.restlet.ext.xml.jar
org.restlet.jar</pre><p>The two main files are <span class="emphasis"><em>org.restlet.jar</em></span> and  <span class="emphasis"><em>org.restlet.servlet.jar</em></span>. The remaining
three files support formatting in XML and JSON. Restlet has various options for formatting responses; the
current example illustrates two of these.</p></div><p>The <code class="literal">Adage</code> class (see <a class="xref" href="#Ex13" title="Example 13. The Adage POJO class in the adages2 Restlet service">Example 13, “The <code class="literal">Adage</code> POJO class in the <span class="emphasis"><em>adages2</em></span> Restlet service”</a>) is mostly unchanged from the earlier version of the
service. There is now an <code class="literal">id</code> property (line 1) to support searching for a specified <code class="literal">Adage</code> on a GET, PUT, or DELETE request.</p><div class="example"><a id="Ex13"></a><p class="title"><b>Example 13. The <code class="literal">Adage</code> POJO class in the <span class="emphasis"><em>adages2</em></span> Restlet service</b></p><div class="example-contents"><pre class="screen">package adages2;

public class Adage {
    private String words;
    private int wordCount;
    private int id;

    public Adage() { }
    @Override
    public String toString() {
        return String.format("%2d: ", id) + words + " -- " + wordCount + " words";
    }
    public void setWords(String words) {
        this.words = words;
        this.wordCount = words.trim().split("\\s+").length;
    }
    public String getWords() { return this.words; }
    public void setWordCount(int wordCount) { }
    public int getWordCount() { return this.wordCount; }

    public void setId(int id) { this.id = id; }            <a id="CO1-24"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public int getId() { return this.id; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">Adages</code> class (see <a class="xref" href="#Ex14" title="Example 14. The POJO class Adages in the adages2 Restlet service">Example 14, “The POJO class <code class="literal">Adages</code> in the <span class="emphasis"><em>adages2</em></span> Restlet service”</a>) has a <code class="literal">static</code> list (line 1), of the thread-safe type
<code class="literal">CopyOnWriteArrayList</code>, that substitutes for a persistence store such as database. The
class has a <code class="literal">toPlain</code> method (line 2) to support a <code class="literal">text/plain</code> response on a GET request to
the <span class="emphasis"><em>adages2</em></span> service. The <code class="literal">find</code> method (line 3) supports GET, PUT, and DELETE requests for a specified
<code class="literal">Adage</code> in the list <code class="literal">adages</code>; and the <code class="literal">add</code> method (line 4) supports POST requests by adding a
newly created <code class="literal">Adage</code> to the list.</p><div class="example"><a id="Ex14"></a><p class="title"><b>Example 14. The POJO class <code class="literal">Adages</code> in the <span class="emphasis"><em>adages2</em></span> Restlet service</b></p><div class="example-contents"><pre class="screen">package aphorism2;

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

public class Adages {
    private static CopyOnWriteArrayList&lt;Adage&gt; adages;        <a id="CO1-25"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    private static AtomicInteger id;

    static {
        String[ ] aphorisms =
            {"What can be shown cannot be said.",
             "If a lion could talk, we could not understand him.",
             "Philosophy is a battle against the bewitchment of
              our intelligence by means of language.",
             "Ambition is the death of thought.",
             "The limits of my language mean the limits of my world."};
        adages = new CopyOnWriteArrayList&lt;Adage&gt;();
        id = new AtomicInteger();
        for (String str : aphorisms) add(str);
    }

    public static String toPlain() {                          <a id="CO1-26"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        String retval = "";
        int i = 1;
        for (Adage adage : adages) retval += adage.toString() + "\n";
        return retval;
    }
    public static CopyOnWriteArrayList&lt;Adage&gt; getList() { return adages; }
    public static Adage find(int id) {                        <a id="CO1-27"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        Adage adage = null;
        for (Adage a : adages) {
            if (a.getId() == id) {
                adage = a;
                break;
            }
        }
        return adage;
    }
    public static void add(String words) {                    <a id="CO1-28"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        int localId = id.incrementAndGet();
        Adage adage = new Adage();
        adage.setWords(words);
        adage.setId(localId);
        adages.add(adage);
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">AdagesApplication</code> class (see <a class="xref" href="#Ex15" title="Example 15. The Restlet Application class with the routing table">Example 15, “The Restlet <code class="literal">Application</code> class with the routing table”</a>) extends the Restlet <code class="literal">Application</code> class (line 1) and interacts
with the service’s publisher. In the case of a
web server such as Tomcat, this class  works with the Restlet <code class="literal">ServerServlet</code> to dispatch incoming
service requests to the proper resource. The dispatching is done through a pattern-driven routing table
at the end of the class.</p><div class="example"><a id="Ex15"></a><p class="title"><b>Example 15. The Restlet <code class="literal">Application</code> class with the routing table</b></p><div class="example-contents"><pre class="screen">package adages2;

import org.restlet.Application;
import org.restlet.Restlet;
import org.restlet.Request;
import org.restlet.Response;
import org.restlet.routing.Router;
import org.restlet.data.Status;
import org.restlet.data.MediaType;

public class AdagesApplication extends Application {                           <a id="CO1-29"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    @Override
    public synchronized Restlet createInboundRoot() {
        // To illustrate the different API possibilities, implement the
        // DELETE operation as an anonymous Restlet class. For the
        // remaining operations, follow Restlet best practices and
        // implement each as a Java class.

        // DELETE handler
        Restlet janitor = new Restlet(getContext()) {                          <a id="CO1-30"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                public void handle(Request request, Response response) {
                    String msg = null;
                    String sid = (String) request.getAttributes().get("id");
                    if (sid == null) msg = badRequest("No ID given.\n");
                    Integer id = null;
                    try {
                        id = Integer.parseInt(sid.trim());
                    }
                    catch(Exception e) { msg = badRequest("Ill-formed ID.\n"); }
                    Adage adage = Adages.find(id);
                    if (adage == null)
                        msg = badRequest("No adage with ID " + id + "\n");
                    else {
                        Adages.getList().remove(adage);
                        msg = "Adage " + id + " removed.\n";
                    }
                    // Generate HTTP response.
                    response.setEntity(msg, MediaType.TEXT_PLAIN);
                }
            };
        // Create the routing table.
        Router router = new Router(getContext());
        router.attach("/",            PlainResource.class);                     <a id="CO1-31"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        router.attach("/xml",         XmlAllResource.class);                    <a id="CO1-32"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        router.attach("/xml/{id}",    XmlOneResource.class);
        router.attach("/json",        JsonAllResource.class);                   <a id="CO1-33"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        router.attach("/create",      CreateResource.class);                    <a id="CO1-34"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        router.attach("/update",      UpdateResource.class);
        router.attach("/delete/{id}", janitor); // instance of anonymous class
        return router;
    }
    private String badRequest(String msg) {
        Status error = new Status(Status.CLIENT_ERROR_BAD_REQUEST, msg);
        return error.toString();
    }
}</pre></div></div><br class="example-break" /><p>Each <span class="emphasis"><em>adages2</em></span> resource could be written as an anonymous class encapsulated inside the <code class="literal">Application</code>
class; but, under Restlet best practices, these resources should be implemented as relatively small,
individual classes such as <code class="literal">PlainResource</code> (line 3), <code class="literal">XmlAllResource</code> (line 4), <code class="literal">JsonAllResource</code> (line 5),
<code class="literal">CreateResource</code> (line 6),
and so on. For illustration, however, the <code class="literal">AdagesApplication</code> class does include an
anonymous class that implements the <code class="literal">Restlet</code> interface by defining the <code class="literal">handle</code> method, which
has <code class="literal">Request</code> and <code class="literal">Response</code> parameters; the <code class="literal">Response</code> and <code class="literal">Request</code> types are quite similar to the servlet
<code class="literal">HttpServletRequest</code> and <code class="literal">HttpServletResponse</code> types, respectively.
The reference to an instance of this anonymous class is
named <code class="literal">janitor</code> (line 2) because the class handles DELETE requests by removing a specified <code class="literal">Adage</code> from the
list of adages.</p><p>The routing table at the end of <code class="literal">AdagesApplication</code> class follows a popular idiom for
RESTful frameworks such as Restlet: a URI
pattern maps to a specified resource. A routing-table entry such as</p><pre class="screen">router.attach("/", PlainResource.class);</pre><p>maps the URI <code class="literal">/</code>, the single slash, to the <code class="literal">PlainResource</code>, thereby making this resource the
default one.
By contrast, the entry</p><pre class="screen">router.attach("/xml/{id}", XmlOneResource.class); // {id} is a parameter</pre><p>includes the parameter <code class="literal">id</code> in braces, where the numerical <code class="literal">id</code> identifies the desired <code class="literal">Adage</code>.
The URI for the <code class="literal">UpdateResource</code> does not include the identifier for the <code class="literal">Adage</code> in question
because this information is supplied in the body of the PUT request.</p><p>The resource classes are quite short because each has very specialized, hence limited,
functionality. For example, the <code class="literal">XmlAllResource</code> is <a class="xref" href="#xml_all" title="Example 16. The XmlAllResource Restlet resource.">Example 16, “The <code class="literal">XmlAllResource</code> Restlet resource.”</a>.</p><div class="example"><a id="xml_all"></a><p class="title"><b>Example 16. The <code class="literal">XmlAllResource</code> Restlet resource.</b></p><div class="example-contents"><pre class="screen">package adages2;

import org.restlet.resource.Get;
import org.restlet.resource.ServerResource;
import org.restlet.representation.Representation;
import org.restlet.ext.xml.DomRepresentation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.restlet.data.Status;
import org.restlet.data.MediaType;
import java.util.List;

public class XmlAllResource extends ServerResource {
    public XmlAllResource() { }
    @Get                                                      <a id="CO1-35"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public Representation toXml() {
        List&lt;Adage&gt; list = Adages.getList();
        DomRepresentation dom = null;                         <a id="CO1-36"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        try {
            dom = new DomRepresentation(MediaType.TEXT_XML);
            dom.setIndenting(true);
            Document doc = dom.getDocument();

            Element root = doc.createElement("adages");
            for (Adage adage : list) {
                Element next = doc.createElement("adage");
                next.appendChild(doc.createTextNode(adage.toString()));
                root.appendChild(next);
            }
            doc.appendChild(root);
        }
        catch(Exception e) { }
        return dom;
    }
}</pre></div></div><br class="example-break" /><p>There are various Java ways to generate XML, including the DOM (Document Object Model) or tree-based method shown in the
<code class="literal">XmlAllResource</code> (line 2), which builds the XML tree out of the <code class="literal">Adages</code>. This resource is reachable, as the <code class="literal">@Get</code> annotation
signals (line 1), only with a GET request.</p><p>The <code class="literal">CreateResource</code> class (see <a class="xref" href="#Ex16" title="Example 17. The CreateResource class in the adages2 service">Example 17, “The <code class="literal">CreateResource</code> class in the <span class="emphasis"><em>adages2</em></span> service”</a>) highlights some nice features of the Restlet API. The argument to the
<code class="literal">create</code> method, of Restlet type <code class="literal">Representation</code> (line 1), represents the HTTP request body. The Restlet class <code class="literal">Form</code> (line 2) makes it
easy to search for specified keys, in this case <code class="literal">words</code>, with which the corresponding values can be accessed, in this
case the text for the new <code class="literal">Adage</code>.</p><div class="example"><a id="Ex16"></a><p class="title"><b>Example 17. The <code class="literal">CreateResource</code> class in the <span class="emphasis"><em>adages2</em></span> service</b></p><div class="example-contents"><pre class="screen">package adages2;

import org.restlet.resource.Post;
import org.restlet.resource.ServerResource;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.data.Status;
import org.restlet.data.MediaType;
import org.restlet.data.Form;

public class CreateResource extends ServerResource {
    public CreateResource() { }
    @Post
    public Representation create(Representation data) {       <a id="CO1-37"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        Status status = null;
        String msg = null;
        // Extract the data from the POST body.
        Form form = new Form(data);                           <a id="CO1-38"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        String words = form.getFirstValue("words");
        if (words == null) {
            msg = "No words were given for the adage.\n";
            status = Status.CLIENT_ERROR_BAD_REQUEST;
        }
        else {
            Adages.add(words);
            msg = "The adage '" + words + "' has been added.\n";
            status = Status.SUCCESS_OK;
        }
        setStatus(status);
        return new StringRepresentation(msg, MediaType.TEXT_PLAIN);
    }
}</pre></div></div><br class="example-break" /><p>A JAX-RS resource typically encapsulates several methods, each annotated with a distinct combination of
HTTP verb (for instance, <code class="literal">@GET</code> or <code class="literal">@POST</code>) and URI (that is, <code class="literal">@Path</code>). In this sense, a JAX-RS resource
class is multi-purpose: its various methods handle various HTTP requests. The Restlet approach differs.
Each resource class is, in best practices, single purpose: one annotated method is the callback for
an HTTP request targeted at a particular URI. The Restlet resource classes thus tend to be small, as
the <span class="emphasis"><em>adages2</em></span> service illustrates.</p><div class="section" title="1.4.1. Sample Calls against the adages2 Service"><div class="titlepage"><div><div><h4 class="title"><a id="_sample_calls_against_the_emphasis_adages2_emphasis_service"></a>1.4.1. Sample Calls against the <span class="emphasis"><em>adages2</em></span> Service</h4></div></div></div><p>The RESTful <span class="emphasis"><em>adages2</em></span> service can be deployed to Tomcat in the usual way:</p><pre class="screen">% ant -Dwar.name=adages2 deploy</pre><p>Once the service is deployed, some <span class="emphasis"><em>curl</em></span> calls can be used to confirm that the service is
behaving correctly. Here is a series of test calls. Each begins with a comment, introduced
with two semicolons, followed by the <span class="emphasis"><em>curl</em></span> call itself, and ending with the output, which
is formatted for readability.</p><pre class="screen">;; GET all in plain text
% curl --request GET http://localhost:8080/adages2/
 1: What can be shown cannot be said. -- 7 words
 2: If a lion could talk, we could not understand him. -- 10 words
 ...

;; GET all in XML
% curl --request GET http://localhost:8080/adages2/xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;adages&gt;
&lt;adage&gt; 1: What can be shown cannot be said. -- 7 words&lt;/adage&gt;
&lt;adage&gt; 2: If a lion could talk, we could not understand him. -- 10 words&lt;/adage&gt;
...

;; GET all in JSON
% curl --request GET http://localhost:8080/adages2/json
[ 1: What can be shown cannot be said. -- 7 words,
  2: If a lion could talk, we could not understand him. -- 10 words,
...

;; GET Adage with id of 2 in XML
% curl --request GET http://localhost:8080/adages2/xml/2
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;adage&gt;
   2: If a lion could talk, we could not understand him. -- 10 words
&lt;/adage&gt;

;; Create a new adage
% curl --request POST --data "words=This is a test" \
  http://localhost:8080/adages2/create
The adage 'This is a test' has been added.

;; Delete the newly added Adage
% curl --request DELETE http://localhost:8080/adages2/delete/6
Adage 6 removed.</pre></div><div class="section" title="1.4.2. Publishing the adages2 Restlet Service without a Web Server"><div class="titlepage"><div><div><h4 class="title"><a id="_publishing_the_emphasis_adages2_emphasis_restlet_service_without_a_web_server"></a>1.4.2. Publishing the <span class="emphasis"><em>adages2</em></span> Restlet Service without a Web Server</h4></div></div></div><p>Restlet is excellent at separating concerns: the web service is one concern and its publication is quite another. The
<span class="emphasis"><em>adages2</em></span> service can be deployed with Tomcat or Jetty but also—and with ease—using a standard Java application
(see <a class="xref" href="#Ex17" title="Example 18. A Java application to publish the Restlet adages2 web service">Example 18, “A Java application to publish the Restlet <span class="emphasis"><em>adages2</em></span> web service”</a>).</p><div class="example"><a id="Ex17"></a><p class="title"><b>Example 18. A Java application to publish the Restlet <span class="emphasis"><em>adages2</em></span> web service</b></p><div class="example-contents"><pre class="screen">package adages2;

import org.restlet.Component;                                                  <a id="CO1-39"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
import org.restlet.data.Protocol;                                              <a id="CO1-40"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />

public class Main {
    public static void main(String[ ] args) throws Exception {
        // Create a new Component.
        Component component = new Component();
        // Add a new HTTP server listening on port 8182.
        component.getServers().add(Protocol.HTTP, 8182);                       <a id="CO1-41"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        // Attach the application.
        component.getDefaultHost().attach("/adages", new AdagesApplication()); <a id="CO1-42"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        // Start the web server.
        component.start();
    }
}</pre></div></div><br class="example-break" /><p>The two <code class="literal">import</code> statements (lines 1 and 2)in <code class="literal">Main</code> require only the <span class="emphasis"><em>org.restlet.jar</em></span> file to compile and
run; but the various Restlet resource classes such as <code class="literal">XmlAllResource</code> and
<code class="literal">JsonAllResource</code> require other JARs. The command-line server listens for HTTP
connections on port 8182 (line 3) for requests against the URI that begins with <span class="emphasis"><em>/adages</em></span> (line 4).</p><p>The ZIP file with the sample applications includes <span class="emphasis"><em>Main.jar</em></span>, an executable JAR file
that can be used instead of Tomcat or Jetty to publish the service:</p><pre class="screen">% java -jar Main</pre><p>The built-in server listens for requests indefinitely and the functionality of the <span class="emphasis"><em>adages2</em></span> service
is unchanged in this command-line option for publication. For example, here is a request for
the adages in plain text together with the response:</p><pre class="screen">% curl localhost:8182/adages/

 1: What can be shown cannot be said. -- 7 words
 2: If a lion could talk, we could not understand him. -- 10 words
 3: Philosophy is a battle against the bewitchment of our intelligence
    by means of language. -- 14 words
 4: Ambition is the death of thought. -- 6 words
 5: The limits of my language mean the limits of my world. -- 11 words</pre><p>The URI begins with <span class="emphasis"><em>/adages</em></span>, in effect the counterpart of the WAR file name under Tomcat or Jetty.
The URI ends with the slash, giving <span class="emphasis"><em>/adages/</em></span>, which maps to the <code class="literal">PlainResource</code> in the <span class="emphasis"><em>adages2</em></span> service.</p><p>The command-line option for publishing is nicely suited for development. In a production
environment, a web servers such as Tomcat and Jetty or application servers such as
GlassFish and WebSphere provide levels of support that a standalone Java application simply cannot
match.</p></div></div><div class="section" title="1.5. A RESTful Service as a @WebServiceProvider"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_service_as_a_literal_webserviceprovider_literal"></a>1.5. A RESTful Service as a <code class="literal">@WebServiceProvider</code></h3></div></div></div><p>JAX-WS (Java API for XML-Web Services) includes APIs for RESTful and SOAP-based web services, although JAX-WS
seems to be used mostly for the latter. The reference implementation is Metro (<span class="emphasis"><em>metro.java.net</em></span>), which is part of
the GlassFish project. Although JAX-WS technically belongs to enterprise rather than core Java, the core Java JDK (1.6 or
greater) includes enough of the Metro distribution to compile and to publish RESTful and SOAP-based services. JAX-RS and
Restlet are state-of-the-art, high-level APIs for developing RESTful services; by contrast, the JAX-WS API for RESTful services is low
level. Nonetheless, JAX-WS support for RESTful services deserves a look; and the JAX-WS API for SOAP-based services will be the
centerpiece in Chapters 4 and 5.</p><p>The JAX-WS stack reflects the view that SOAP-based services over HTTP are refinements of RESTful services. The JAX-WS API has two
main annotations. A POJO class annotated as a <code class="literal">@WebService</code> delivers a SOAP-based service, whereas
a POJO class annotated as a <code class="literal">@WebServiceProvider</code> usually delivers a RESTful one; however, a class annotated as
a <code class="literal">@WebServiceProvider</code> can deliver
a SOAP-based service as well. Yet another revision of the <span class="emphasis"><em>adages</em></span> RESTful service, <span class="emphasis"><em>adages3</em></span>, introduces the JAX-WS API for
RESTful services.</p><p>In the revised <span class="emphasis"><em>adages3</em></span> service, the <code class="literal">Adage</code> and <code class="literal">Adages</code> classes are mostly unchanged from the <span class="emphasis"><em>adages2</em></span> version. One small change
is that the package name goes from <code class="literal">adages2</code> to <code class="literal">adages3</code>; another change is that the <code class="literal">Adage</code> list is returned as array, which
then is serialized into XML.
The <code class="literal">toPlain</code> method in the <code class="literal">Adages</code> class could be dropped because the revised service deals only in <code class="literal">application/xml</code> and not
in <code class="literal">text/plain</code> HTTP payloads.
The <code class="literal">AdagesProvider</code> class (see <a class="xref" href="#Ex18" title="Example 19. The AdagesProvider class that supports the CRUD operations.">Example 19, “The <code class="literal">AdagesProvider</code> class that supports the CRUD operations.”</a>) supports the four CRUD operations against the RESTful service.</p><div class="example"><a id="Ex18"></a><p class="title"><b>Example 19. The <code class="literal">AdagesProvider</code> class that supports the CRUD operations.</b></p><div class="example-contents"><pre class="screen">package adages3;

import java.beans.XMLEncoder;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import javax.annotation.Resource;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.WebServiceProvider;
import javax.xml.ws.Provider;
import javax.xml.ws.BindingType;
import javax.xml.ws.http.HTTPBinding;
import javax.xml.ws.ServiceMode;
import javax.xml.ws.http.HTTPException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import org.xml.sax.InputSource;

@WebServiceProvider                             // generic service provider          <a id="CO1-43"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
@ServiceMode(javax.xml.ws.Service.Mode.MESSAGE) // entire message available          <a id="CO1-44"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
@BindingType(HTTPBinding.HTTP_BINDING)          // versus SOAP binding               <a id="CO1-45"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
public class AdagesProvider implements Provider&lt;Source&gt; {
    @Resource
    protected WebServiceContext wctx;  // dependency injection

    public AdagesProvider() { }
    // Implement the Provider interface by defining invoke, which expects an XML
    // source (perhaps null) and returns an XML source (perhaps null).
    public Source invoke(Source request) {                                           <a id="CO1-46"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        if (wctx == null) throw new RuntimeException("Injection failed on wctx.");
        // Grab the message context and extract the request verb.
        MessageContext mctx = wctx.getMessageContext();                              <a id="CO1-47"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        String httpVerb = (String) mctx.get(MessageContext.HTTP_REQUEST_METHOD);
        httpVerb = httpVerb.trim().toUpperCase();
        // Dispatch on verb to the handler method. POST and PUT have non-null
        // requests so only these two get the Source request.
        if      (httpVerb.equals("GET"))    return doGet(mctx);                      <a id="CO1-48"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        else if (httpVerb.equals("POST"))   return doPost(request);
        else if (httpVerb.equals("PUT"))    return doPut(request);
        else if (httpVerb.equals("DELETE")) return doDelete(mctx);
        else throw new HTTPException(405);  // bad verb
    }
    private Source doGet(MessageContext mctx) {
        // Parse the query string.
        String qs = (String) mctx.get(MessageContext.QUERY_STRING);
        // Get all Adages.
        if (qs == null) return adages2Xml();
        // Get a specified Adage.
        else {
            int id = getId(qs);
            if (id &lt; 0) throw new HTTPException(400); // bad request
            Adage adage = Adages.find(id);
            if (adage == null) throw new HTTPException(404); // not found
            return adage2Xml(adage);
        }
    }
    private Source doPost(Source request) {
        if (request == null) throw new HTTPException(400); // bad request
        InputSource in = toInputSource(request);
        String pattern = "//words/text()"; // find the Adage's "words"
        String words = findElement(pattern, in);
        if (words == null) throw new HTTPException(400); // bad request
        Adages.add(words);
        String msg = "The adage '" + words + "' has been created.";
        return toSource(toXml(msg));
    }
    private Source doPut(Source request) {
        if (request == null) throw new HTTPException(400); // bad request
        InputSource in = toInputSource(request);
        String pattern = "//words/text()";  // find the Adage's "words"
        String words = findElement(pattern, in);
        if (words == null) throw new HTTPException(400); // bad request
        // Format in XML is: &lt;words&gt;!&lt;id&gt;
        String[ ] parts = words.split("!");
        if (parts[0].length() &lt; 1 || parts[1].length() &lt; 1)
            throw new HTTPException(400); // bad request
        int id = -1;
        try {
            id = Integer.parseInt(parts[1].trim());
        }
        catch(Exception e) { throw new HTTPException(400); } // bad request
        // Find and edit.
        Adage adage = Adages.find(id);
        if (adage == null) throw new HTTPException(404); // not found
        adage.setWords(parts[0]);
        String msg = "Adage " + adage.getId() + " has been updated.";
        return toSource(toXml(msg));
    }
    private Source doDelete(MessageContext mctx) {
        String qs = (String) mctx.get(MessageContext.QUERY_STRING);
        // Disallow the deletion of all teams at once.
        if (qs == null) throw new HTTPException(403); // illegal operation
        else {
            int id = getId(qs);
            if (id &lt; 0) throw new HTTPException(400); // bad request
            Adage adage = Adages.find(id);
            if (adage == null) throw new HTTPException(404); // not found
            Adages.remove(adage);
            String msg = "Adage " + id + " removed.";
            return toSource(toXml(msg));
        }
    }
    private int getId(String qs) {
        int badId = -1; // bad ID
        String[ ] parts = qs.split("=");
        if (!parts[0].toLowerCase().trim().equals("id")) return badId;
        int goodId = badId; // for now
        try {
            goodId = Integer.parseInt(parts[1].trim());
        }
        catch(Exception e) { return badId; }
        return goodId;
    }
    private StreamSource adages2Xml() {
        String str = toXml(Adages.getListAsArray());
        return toSource(str);
    }
    private StreamSource adage2Xml(Adage adage) {
        String str = toXml(adage);
        return toSource(str);
    }
    private String toXml(Object obj) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        XMLEncoder enc = new XMLEncoder(out);
        enc.writeObject(obj);
        enc.close();
        return out.toString();
    }
    private StreamSource toSource(String str) {
        return new StreamSource(new StringReader(str));
    }
    private InputSource toInputSource(Source source) {
        InputSource input = null;
        try {
            Transformer trans = TransformerFactory.newInstance().newTransformer();
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            StreamResult result = new StreamResult(bos);
            trans.transform(source, result);
            input = new InputSource(new ByteArrayInputStream(bos.toByteArray()));
        }
        catch(Exception e) { throw new HTTPException(500); } // internal server error
        return input;
    }
    private String findElement(String expression, InputSource source) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        String retval = null;
        try {
            retval = (String) xpath.evaluate(expression, source, XPathConstants.STRING);
        }
        catch(Exception e) { throw new HTTPException(400); } // bad request
        return retval;
    }
}</pre></div></div><br class="example-break" /><p>Even at a glance at the <code class="literal">AdagesProvider</code> code looks low level. Much of this code transforms one type
to another, for example, a <code class="literal">Source</code> to an <code class="literal">InputSource</code> or an <code class="literal">Adage</code> to a
<code class="literal">StreamSource</code>. The <code class="literal">Source</code> types are <span class="emphasis"><em>sources of XML</em></span>. The JAX-P (Java API for XML-Processing)
packages, used in the the <span class="emphasis"><em>adages3</em></span> service, support <span class="emphasis"><em>transforms</em></span> that convert a <span class="emphasis"><em>source</em></span> into a <span class="emphasis"><em>result</em></span> (see <a class="xref" href="#transform" title="Example 20. A JAX-P transform.">Example 20, “A JAX-P transform.”</a>).</p><div class="example"><a id="transform"></a><p class="title"><b>Example 20. A JAX-P transform.</b></p><div class="example-contents"><pre class="screen">                 +-----------+
Source of XML---&gt;| transform |---&gt;Result
                 +-----------+</pre></div></div><br class="example-break" /><p>For example, a generic <code class="literal">Source</code> might be
transformed into a specific type such as <code class="literal">StreamResult</code>. The need for such transformations in the <span class="emphasis"><em>adages3</em></span> service is
explained shortly.
First, however, it will helpful to consider the overall structure of the <code class="literal">AdagesProvider</code>.</p><p>Three annotations adorn the <code class="literal">AdagesProvider</code> class:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">@WebServiceProvider</code> (line 1) indicates that the <code class="literal">AdagesProvider</code> class implements a templated <code class="literal">Provider</code> interface,
in this case a <code class="literal">Provider&lt;Source&gt;</code> interface, where <code class="literal">Source</code> is a source precisely of XML. The templated
<code class="literal">Provider</code> interface requires that the implementing class define the method
</p><pre class="screen">public Source invoke(Source input) { /*...*/ }</pre><p class="simpara">This method expects a <code class="literal">Source</code> of XML as an argument and returns a <code class="literal">Source</code> of XML.
The <code class="literal">AdagesProvider</code> class defines the <code class="literal">invoke</code> method (line 2), which is the target of every HTTP request against the
<span class="emphasis"><em>adages3</em></span> service. The <code class="literal">invoke</code> method implements a simple routing table. After extracting the HTTP
verb from the incoming request, using the <code class="literal">MessageContext</code> map (line 5) that the run-time provides, the <code class="literal">invoke</code>
method calls one of four <code class="literal">AdagesProvider</code> methods (line 6), each of which
returns a <code class="literal">Source</code> of XML for the HTTP response body:</p><pre class="screen">// mctc --&gt; MessageContext, request --&gt; Source
if      (httpVerb.equals("GET"))    return doGet(mctx);
else if (httpVerb.equals("POST"))   return doPost(request);
else if (httpVerb.equals("PUT"))    return doPut(request);
else if (httpVerb.equals("DELETE")) return doDelete(mctx);
else throw new HTTPException(405);  // bad verb</pre><p class="simpara">This table mimics, in the method names, an <code class="literal">HttpServlet</code> with its encapsulated <code class="literal">doGet</code>, <code class="literal">doPost</code>,
<code class="literal">doPut</code>, and <code class="literal">doDelete</code> methods. The difference here is that each <span class="emphasis"><em>do</em></span> method takes only one argument. The
GET and DELETE have no bodies, which means that the incoming <code class="literal">Source</code> is empty. In any case, the
<code class="literal">doGet</code> and <code class="literal">doDelete</code> methods need only information in the query string, which is stored in the
HTTP headers; hence, <code class="literal">doGet</code> and <code class="literal">doDelete</code> are passed the <code class="literal">MessageContext</code> as the argument. By contrast,
the <code class="literal">doPost</code> and <code class="literal">doPut</code> methods require information in the HTTP request body, a non-empty <code class="literal">Source</code>; and
these methods therefore are passed the request <code class="literal">Source</code> as their single argument.</p></li><li class="listitem">
The <code class="literal">@ServiceMode</code> annotation (line 2) has two possible values: <code class="literal">MESSAGE</code> (the entire request message) or
<code class="literal">PAYLOAD</code> (the body, if any, of the request message). The <span class="emphasis"><em>adages3</em></span> service needs access to both
the HTTP headers and, for POST and PUT requests, the HTTP body; hence, the service mode is
<code class="literal">MESSAGE</code>.
</li><li class="listitem">
The <code class="literal">@BindingType</code> (line 3) refers to the type of payload in an HTTP message. The default type is
SOAP, which means that the body of an HTTP message (for instance, a POST request or any response)
is a SOAP document. The <code class="literal">AdagesProvider</code> specifies an HTTP binding, which means that the
HTTP payload is to be arbitrary XML, not exclusively the SOAP variant of XML. Even with this
binding type, however, a SOAP document could be a payload because SOAP still counts as XML.
</li></ul></div><p>This overview should help in the more detailed analysis that follows. In the <span class="emphasis"><em>adages3</em></span> service,
the <code class="literal">doGet</code> method needs to handle two cases:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
If there is no query string, this method assumes that the client means <span class="emphasis"><em>read all</em></span> with the
GET request. In this case, the entire list of adages, encoded as XML using the <code class="literal">XMLEncoder</code>,
is returned.
</li><li class="listitem"><p class="simpara">
If there is a query string, it should have a key/value pair such as
</p><pre class="screen">id=4</pre><p class="simpara">where 4 is then interpreted as the <code class="literal">id</code> of the single message to be returned. Here, for quick review,
is the <code class="literal">doGet</code> method:</p><pre class="screen">private Source doGet(MessageContext mctx) {
    // Parse the query string.
    String qs = (String) mctx.get(MessageContext.QUERY_STRING);
    if (qs == null) return adages2Xml(); // all adages                  <a id="CO1-49"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    else {                               // one adage
        int id = getId(qs);
        if (id &lt; 0) throw new HTTPException(400); // bad request
        Adage adage = Adages.find(id);
        if (adage == null) throw new HTTPException(404); // not found
        return adage2Xml(adage);
    }
}</pre><p class="simpara">Utility methods such as <code class="literal">adages2Xml</code> (line 1) handle the transformation of <code class="literal">Adage</code> objects
into XML documents (text), which in turn are transformed into <code class="literal">StreamSource</code> instances sent back
to the client.</p></li></ul></div><p>The <code class="literal">doPost</code> method</p><pre class="screen">private Source doPost(Source request) {
    if (request == null) throw new HTTPException(400); // bad request
       InputSource in = toInputSource(request);                         <a id="CO1-50"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
       String pattern = "//words/text()"; // find the Adage's "words"   <a id="CO1-51"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
       String words = findElement(pattern, in);
       if (words == null) throw new HTTPException(400); // bad request
       Adages.add(words);
       String msg = "The adage '" + words + "' has been created.";
       return toSource(toXml(msg));
}</pre><p>also relies on utility methods, in this case on the tricky <code class="literal">toInputSource</code> method (line 1) that
transforms a <code class="literal">Source</code> request, which is likely but not necessarily a <code class="literal">StreamSource</code>,
into an <code class="literal">InputSource</code>. The reason is that, for convenience, the <code class="literal">doPost</code> method uses
an <code class="literal">XPath</code> instance to search the incoming XML document for the <code class="literal">words</code> in the <code class="literal">Adage</code>
to be created. For example, the XMl document might look like this in a POST request:</p><pre class="screen">&lt;ns1:foo xmlns:ns1='http://sample.org'&gt;
   &lt;words&gt;This is the way the world ends.&lt;/words&gt;
&lt;/ns1:foo&gt;</pre><p>An <code class="literal">XPath</code> search requires a pattern, in this example (line 2):</p><pre class="screen">//words/text()</pre><p>The two opening slashes mean <span class="emphasis"><em>anywhere in the document</em></span> and the specific search term is
the literal <code class="literal">words</code>. The <code class="literal">text()</code> at the end signals <code class="literal">XPath</code> to return the text node in the
XML document that contains the new adage, in this case the phrase</p><pre class="screen">This is the way the world ends.</pre><p>The search is flexible in that the XML tag <span class="emphasis"><em>words</em></span> could be anywhere in the document, in
this example nested inside the root element named <span class="emphasis"><em>ns1:foo</em></span>. Now let me get back to the
point about needing to transform a <code class="literal">Source</code> into an <code class="literal">InputSource</code>. The <code class="literal">XPath</code> method
<code class="literal">evaluate</code> searches an XML document for a pattern such as <span class="emphasis"><em>//words</em></span> but requires, as
a second argument, an <code class="literal">InputSource</code>; hence, the transformation of the incoming but
generic <code class="literal">Source</code> to an <code class="literal">InputSource</code> sets up the <code class="literal">XPath</code> search. There are other ways in
which the <code class="literal">XPath</code> search might be supported but any of these would require a
transformation of some kind.</p><p>The <code class="literal">doPut</code> method in the <code class="literal">AdagesProvider</code> class is
similar in structure to the <code class="literal">doPost</code> method because, of course, creating a new
<code class="literal">Adage</code> (POST) and updating an existing one (PUT) are similar operations. However, the
<code class="literal">doPut</code> implementation allows only the <code class="literal">words</code> of the <code class="literal">Adage</code> to be changed; the <code class="literal">id</code>
property, which the <code class="literal">Adages</code> class manages, cannot be changed through a PUT operation.</p><div class="sidebar" title="Publishing the adages3 service with Tomcat and Endpoint"><p class="title"><b>Publishing the <span class="emphasis"><em>adages3</em></span> service with Tomcat and <code class="literal">Endpoint</code></b></p><p>With core Java 1.6 or greater, publishing a <code class="literal">@WebServiceProvider</code> service (and, for that
matter, a SOAP-based <code class="literal">@WebService</code>) from the command-line requires very little code. Here is a sample
publisher, included in the ZIP with the sample code:</p><pre class="screen">package adages3;

import javax.xml.ws.Endpoint;
public class Publisher {
   public static void main(String[ ] args) {
      int port = 8888;
      String url = "http://localhost:" + port + "/";
      System.out.println("Restfully publishing on port " + port);
      Endpoint.publish(url, new AdagesProvider());
   }
}</pre><p>Once published, the <code class="literal">AdagesProvider</code> service awaits requests indefinitely on port 8888. For
example, the request</p><pre class="screen">% curl localhost:8888/?id=3</pre><p>elicits the response</p><pre class="screen">&lt;java version="1.7.0" class="java.beans.XMLDecoder"&gt;
 &lt;object class="adages3.Adage"&gt;
  &lt;void property="id"&gt;
   &lt;int&gt;3&lt;/int&gt;
  &lt;/void&gt;
  &lt;void property="wordCount"&gt;
   &lt;int&gt;14&lt;/int&gt;
  &lt;/void&gt;
  &lt;void property="words"&gt;
   &lt;string&gt;
     Philosophy is a battle against the bewitchment of our intelligence
     by means of language.
   &lt;/string&gt;
  &lt;/void&gt;
 &lt;/object&gt;
&lt;/java&gt;</pre><p>Publishing with Tomcat or Jetty is likewise straightforward, although two configuration files
are needed: the usual <span class="emphasis"><em>web.xml</em></span> and the additional <span class="emphasis"><em>sun-jaxws.xml</em></span>. Here is the <span class="emphasis"><em>web.xml</em></span> for the <span class="emphasis"><em>adages3</em></span>
service:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServletContextListener   <a id="CO1-52"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;jaxws&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServlet
    &lt;/servlet-class&gt;                                                   <a id="CO1-53"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;jaxws&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>The Metro classes <code class="literal">WSServletContextListener</code> (line 1) and <code class="literal">WSServlet</code> (line 2) are in the JAR file
currently named <span class="emphasis"><em>webservices-rt.jar</em></span>, which can be downloaded with the rest of Metro
JARs from <span class="emphasis"><em>metro.java.net</em></span>. The JAR in question should be in the <span class="emphasis"><em>src</em></span> directory so that
the Ant script can package this JAR in the deployed WAR file. In any case, the
<code class="literal">WSServletContextListener</code> parses the <span class="emphasis"><em>sun-jaxws.xml</em></span> file, with more details shortly.
The <code class="literal">WSServlet</code> acts the interceptor: the servlet receives incoming requests and
dispatches these to the <code class="literal">AdagesProvider</code> service. This architecture is quite similar
to the Restlet version.</p><p>The second configuration file, <span class="emphasis"><em>sun-jaxws.xml</em></span>, is:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;endpoints version="2.0"
           xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"&gt; <a id="CO1-54"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
  &lt;endpoint implementation="adages3.AdagesProvider"              <a id="CO1-55"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            name="AdagesProvider"
            url-pattern="/*"/&gt;
&lt;/endpoints&gt;</pre><p>This file completes the routing by notifying the <code class="literal">WSServletContextListener</code> that
the <code class="literal">WSServlet</code> should dispatch requests to an <code class="literal">AdagesProvider</code> instance (line 2). By the
way, the <code class="literal">xmlns</code> attribute in the <code class="literal">endpoints</code> element (line 1) is important and should not
be changed or omitted.</p><p>With the two configuration files and the Metro library JAR in the <span class="emphasis"><em>src</em></span>
directory, the <span class="emphasis"><em>adages3</em></span> service can be deployed to Tomcat in the usual way:</p><pre class="screen">% ant -Dwar.name=adages3 deploy</pre><p>Sample requests then can be sent to the service</p><pre class="screen">% curl localhost:8080/adages3?id=3</pre></div><p>The JAX-WS <code class="literal">@WebServiceProvider</code> is a low-level, XML-centric API. Java is well known for providing
options; and this API is among the Java options for delivering REST-style services. Chapter 7 introduces
the client-side API, based on the <code class="literal">Dispatch</code> interface, for RESTful services implemented with
<code class="literal">@WebServiceProvider</code>.</p></div><div class="section" title="1.6. What’s Next?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_8217_s_next"></a>1.6. What’s Next?</h3></div></div></div><p>This chapter has focused on programming and publishing RESTful services; the next chapter focuses on
the client side, that is, on consuming such services. Some of the sample clients make requests
against major RESTful sites such as Amazon and Twitter, whereas others make requests against the services developed
in this chapter. Once again the goal is to illustrate, with working code, the various client-side APIs
at the Java programmer’s disposal.</p><p>Four different APIs were considered in this chapter but these APIs fall into three general groups:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The <code class="literal">HttpServlet</code> API, which has been around since the late 1990s, remains an excellent way to
implement RESTful services. Servlets are HTTP-aware and provide convenient filtering of requests by
HTTP verb. Programmers accustomed to implementing web sites with servlets, JSP and related scripting
languages such as JSF or Struts, should find servlets a natural and appealing way to deliver web
services as well. The servlet API is at once uncomplicated and powerful.
</li><li class="listitem">
The JAX-RS and Restlet APIs take full advantage of Java annotations to advertise the RESTful
aspects of implemented services. These frameworks integrate well with JAX-B technologies to
automate the conversion of Java types into XML and JSON documents. JAX-RS and Restlet services,
like servlet-based servlets, can be published with production-grade web servers such as Tomcat
and Jetty. These APIs also mimic the routing idioms that have become so popular because of
frameworks such as Rails and Sinatra.
</li><li class="listitem">
The JAX-WS API, with the <code class="literal">@WebServiceProvider</code> at its center, is lower level than the other
options but well suited for programmers who need to be close to the HTTP and XML metal.
This API is sufficiently rich to deliver real-world RESTful services; but the rival APIs are
more appealing in that they hide many of the details that a JAX-WS service must handle
explicitly. For SOAP-based services, the JAX-WS API is as good as any and will be the
focus in Chapters 4 and 5.
</li></ul></div></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp5921584" href="#idp5921584" class="simpara">1</a>] </sup>In core Java 8, the functionality of the <span class="emphasis"><em>schemagen</em></span> utility
will give way to general annotation processing through <span class="emphasis"><em>javac</em></span>.</p></div></div></div></body></html>

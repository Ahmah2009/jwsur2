<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#jwsur_2nd_chapter_2">1. Implementing and Publishing RESTful Web Services</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_java_options">1.1. The Java Options</a></span></dt><dt><span class="section"><a href="#_a_restful_service_as_an_literal_httpservlet_literal">1.2. A RESTful Service as an <code class="literal">HttPServlet</code></a></span></dt><dt><span class="section"><a href="#_a_restful_web_service_as_a_jax_rs_resource">1.3. A RESTful Web Service as a JAX-RS Resource</a></span></dt></dl></dd></dl></div><div class="section" title="1. Implementing and Publishing RESTful Web Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="jwsur_2nd_chapter_2"></a>1. Implementing and Publishing RESTful Web Services</h2></div></div></div><div class="section" title="1.1. The Java Options"><div class="titlepage"><div><div><h3 class="title"><a id="_the_java_options"></a>1.1. The Java Options</h3></div></div></div><p>Java offers more than way to implement and to publish RESTful web services. This chapter explores some options.
On the publishing side, the choices range from very basic, development-oriented tools such as the Grizzly RESTful container
and the core <code class="literal">Endpoint</code> class; through lightweight, Java-centric web servers such as Tomcat and Jetty; and up to full-blown Java
application servers (JAS) such as Glassfish, JBoss, and WebSphere. There are also various APIs for implementing RESTful services, both
standard and third-party. Here is a short list:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The <code class="literal">HttpServlet</code> and JSP APIs, introduced briefly in Chapter 1 and examined more thoroughly in this chapter.
</li><li class="listitem">
The JAX-RS (Java API for XML-Restful Services) API.
</li><li class="listitem">
The JAX-WS (Java API for XML-Web Services) API, in particular the <code class="literal">WebServiceProvider</code> interface.
</li><li class="listitem">
The third-party <span class="emphasis"><em>restlet</em></span> API.
</li></ul></div><p>For the most part, the API used to implement the web service does not constrain how this service can be published.
The exception is the servlet API, as servlets need to be
deployed in a servlet container such as Tomcat’s Catalina or Jetty. (Jetty is the name of both the web server
and its servlet container.) This chapter uses Tomcat and Jetty to publish servlet-based services. There are shotcuts for
publishing JAX-RS and JAX-WS services but these, too, can be published with Tomcat or Jetty. Services based on the
restlet API are meant to be published with a servlet container.</p><p>The decision of how to publish a service depends on many
factors, of course. For example, if service deployment requires wire-level security in the form of HTTPS together with
user authentication/authorization, then a web server such as Tomcat is the obvious starting point. If the published
web services are to interact with EJBs, which are deployed in an EJB container, then a souped-up web server such as TomEE (Tomcat
with EE support) or a full JAS is the better choice. In development, simpler options such as Grizzly or <code class="literal">Endpoint</code> are
attractive. This chapter introduces various options for publication; and Chapter 6 covers web services deployed in a JAS.</p></div><div class="section" title="1.2. A RESTful Service as an HttPServlet"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_service_as_an_literal_httpservlet_literal"></a>1.2. A RESTful Service as an <code class="literal">HttPServlet</code></h3></div></div></div><p>Chapter 1 has a sample RESTful service implemented as a JSP script and a pair of back-end classes, <code class="literal">Prediction</code> and
<code class="literal">Predictions</code>. The JSP-based service supported only GET requests. This section revises the example to provide an
<code class="literal">HttpServlet</code> implementation with support for the four CRUD operations:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A new <code class="literal">Prediction</code> can be created with a POST request whose body has two key/value pairs: a <code class="literal">who</code> key whose value
is the name of the predictor and a <code class="literal">what</code> key whose value is the prediction.
</li><li class="listitem"><p class="simpara">
The <code class="literal">Prediction</code> objects can be read one at a time or all together with a GET request.
</p><p class="simpara">If the GET request has a query string with an <code class="literal">id</code> key, then the corresponding <code class="literal">Prediction</code>, if any, is returned.
If the GET request has no query string, then the list of <code class="literal">Predictions</code> is returned. On any GET request,
the client can indicate a preference for JSON rather than the default XML format.</p></li><li class="listitem">
A specified <code class="literal">Prediction</code> can be updated with a PUT request that provides the <code class="literal">Prediction</code> identifier and either
a new <code class="literal">who</code> or a new <code class="literal">what</code>. (The reason for this restriction, explained in detail later, is that Tomcat has
trouble with PUT requests.)
</li><li class="listitem">
A specified <code class="literal">Prediction</code> can be deleted.
</li></ul></div><p>The structure of a servlet-based service differs from that of the earlier JSP-based service.
The obvious change is that
an <code class="literal">HttpServlet</code> replaces the JSP script. There are also changes in the details of the <code class="literal">Prediction</code> and
<code class="literal">Predictions</code> classes, which still provide back-end support. The details follow.</p><div class="sidebar" title="Deploying under Jetty instead of Tomcat"><p class="title"><b>Deploying under Jetty instead of Tomcat</b></p><p>The Jetty web server is available at <span class="emphasis"><em>http://jetty.codehaus.org</em></span> as a ZIP file. Assume that <span class="emphasis"><em>JETTY_HOME</em></span>
is the install directory. The subdirectories of <span class="emphasis"><em>JETTY_HOME</em></span> are similar to those of <span class="emphasis"><em>TOMCAT_HOME</em></span>. For
example, <span class="emphasis"><em>JETTY_HOME</em></span> has a <span class="emphasis"><em>webapps</em></span> subdirectory into which WAR files are deployed; a <span class="emphasis"><em>logs</em></span> subdirectory; a <span class="emphasis"><em>lib</em></span> subdirectory with various
JAR files, including a versioned counterpart
of Tomcat’s <span class="emphasis"><em>servlet-api.jar</em></span>; and others. Jetty ships with an executable JAR file <span class="emphasis"><em>start.jar</em></span>; hence,
Jetty can be started at the command line with the command</p><pre class="screen">% java -jar start.jar</pre><p>A standard WAR file deployable under Tomcat is deployable under Jetty and vice-versa. (A <span class="emphasis"><em>standard</em></span> WAR
file contains only the regular deployment descriptor <span class="emphasis"><em>web.xml</em></span> and not any product-specific
configuration files.) The Jetty web
server, like Tomcat, listens by default on port 8080. Jetty is a first-rate web server that
has a lighter feel than does Tomcat; and Jetty’s simplicity makes embedding this web server in other
systems relatively straightforward. In the end, it is hard to make a bad choice between Tomcat and
Jetty.</p></div><div class="section" title="1.2.1. Implementation Details"><div class="titlepage"><div><div><h4 class="title"><a id="_implementation_details"></a>1.2.1. Implementation Details</h4></div></div></div><p>There are small but important changes to the <code class="literal">Prediction</code> class (see Example 1), which now includes an <code class="literal">id</code> property, an
an auto-incremented integer that the service sets when a new <code class="literal">Prediction</code> object is constructed. The <code class="literal">id</code>
property is used to sort the <code class="literal">Prediction</code> objects, which explains why the <code class="literal">Prediction</code> class implements
the <code class="literal">Comparable</code> interface used in sorting:</p><pre class="screen">public class Prediction implements Serializable, Comparable&lt;Prediction&gt; {</pre><p>Implementing the <code class="literal">Comparable</code> interface requires that the <code class="literal">compareTo</code> method be defined:</p><pre class="screen">public int compareTo(Prediction other) {
    return this.id - other.id;
}</pre><p>The <code class="literal">compareTo</code> method uses the comparison semantics of the age-old C function <code class="literal">qsort</code>. For illustration,
suppose that <code class="literal">this.id</code> in the code above is 7 and <code class="literal">other.id</code> is 12, where <code class="literal">this</code> is the current object
and <code class="literal">other</code> is another <code class="literal">Prediction</code> object against which the current <code class="literal">Prediction</code> object is to be
compared. The difference <span class="emphasis"><em>7 - 12</em></span> is the negative integer -5, which signals that the current <code class="literal">Prediction</code>
<span class="emphasis"><em>precedes</em></span> the other <code class="literal">Prediction</code> because 7 precedes 12. In general,</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
a returned negative integer signals that the current object <span class="emphasis"><em>precedes</em></span> the other object
</li><li class="listitem">
a returned positive integer signals that the current object <span class="emphasis"><em>succeeds</em></span> the other object
</li><li class="listitem">
a returned zero signals that the two objects are to be treated as equals with respect to sorting
</li></ul></div><p>The implementation of the <code class="literal">compareTo</code> method means the sort is to be in ascending order. Were the <code class="literal">return</code>
statement changed to</p><pre class="screen">return other.id - this.id;</pre><p>the sort would be in descending order. The <code class="literal">Prediction</code> objects are sorted for ease of confirming that
the CRUD operations work correctly. For example, if a new <code class="literal">Prediction</code> object is created with the
appropriate POST request, then the newly created <code class="literal">Prediction</code> occurs at the <span class="emphasis"><em>end</em></span> of the
<code class="literal">Prediction</code> list. In similar fashion, it is straightword to confirm that the other destructive CRUD
opertions—PUT (update) and DELETE—work as intended by inspecing the resulting sorted list of <code class="literal">Prediction</code>
objects.</p><div class="example"><a id="Ex1"></a><p class="title"><b>Example 1. The back-end <code class="literal">Prediction</code> class</b></p><div class="example-contents"><pre class="screen">package cliches2;

import java.io.Serializable;

// An array of Predictions is to be serialized
// into an XML or JSON document, which is returned to
// the consumer on a request.
public class Prediction implements Serializable, Comparable&lt;Prediction&gt; {
    private String who;   // person
    private String what;  // his/her prediction
    private int    id;    // identifier used as lookup-key

    public Prediction() { }

    public void setWho(String who) {
        this.who = who;
    }
    public String getWho() {
        return this.who;
    }

    public void setWhat(String what) {
        this.what = what;
    }
    public String getWhat() {
        return this.what;
    }

    public void setId(int id) {
        this.id = id;
    }
    public int getId() {
        return this.id;
    }

    // implementation of Comparable interface
    public int compareTo(Prediction other) {
        return this.id - other.id;
    }
}</pre></div></div><br class="example-break" /><p>A <code class="literal">Prediction</code> is still <code class="literal">Serializable</code> so that a list of these can be serialized into
XML. An added feature is that this list also can be formatted in JSON if the client so requests.</p><p>The utility class <code class="literal">Predictions</code> has changed as well (see Example 2). As explained in the
sidebar about thread synchronization and servlets, the <code class="literal">Map</code> of the earlier JSP
implementation gives way to a <code class="literal">ConcurrentMap</code> so that the code can avoid explicit
locks in the form of <code class="literal">synchronized</code> blocks. The <code class="literal">Predictions</code> class now has an <code class="literal">addPrediction</code> method</p><pre class="screen">public int addPrediction(Prediction p) {
   p.setId(mapKey);
   predictions.put(String.valueOf(mapKey), p);
   return mapKey++;
}</pre><p>to support POST requests. The servlet’s <code class="literal">doPost</code> method creates a new <code class="literal">Prediction</code>, sets
the <code class="literal">who</code> and <code class="literal">what</code> properties with data from the POST message’s body, and then
invokes <code class="literal">addPrediction</code> to add the newly constructed <code class="literal">Prediction</code> to the map whose
object reference is <code class="literal">predictions</code>. The <code class="literal">mapKey</code> is an integer that gets incremented
with each new <code class="literal">Prediction</code>; this integer becomes the <code class="literal">id</code> newly constructed
<code class="literal">Prediction</code>.</p><div class="example"><a id="Ex2"></a><p class="title"><b>Example 2. The back-end <code class="literal">Predictions</code> class</b></p><div class="example-contents"><pre class="screen">package cliches2;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;
import java.beans.XMLEncoder; // simple and effective
import javax.servlet.ServletContext;

public class Predictions {
    private ConcurrentMap&lt;String, Prediction&gt; predictions;
    private ServletContext sctx;
    private static int mapKey = 1;

    public Predictions() {
        predictions = new ConcurrentHashMap&lt;String, Prediction&gt;();
    }

    //** properties

    // The ServletContext is required to read the data from
    // a text file packaged inside the WAR file
    public void setServletContext(ServletContext sctx) {
        this.sctx = sctx;
    }
    public ServletContext getServletContext() { return this.sctx; }

    public void setMap(ConcurrentMap&lt;String, Prediction&gt; predictions) {
        // no-op for now
    }
    public ConcurrentMap&lt;String, Prediction&gt; getMap() {
        // Has the ServletContext been set?
        if (getServletContext() == null) return null;

        // Have the data been read already?
        if (predictions.size() &lt; 1) populate();

        return this.predictions;
    }

    public String toXML(Object obj) {
        String xml = null;

        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            XMLEncoder encoder = new XMLEncoder(out);
            encoder.writeObject(obj); // serialize to XML
            encoder.close();
            xml = out.toString(); // stringify
        }
        catch(Exception e) { }
        return xml;
    }

    public int addPrediction(Prediction p) {
        p.setId(mapKey);
        predictions.put(String.valueOf(mapKey), p);
        return mapKey++;
    }

    //** utility
    private void populate() {
        String filename = "/WEB-INF/data/predictions.db";
        InputStream in = sctx.getResourceAsStream(filename);

        // Read the data into the array of Predictions.
        if (in != null) {
            try {
                InputStreamReader isr = new InputStreamReader(in);
                BufferedReader reader = new BufferedReader(isr);

                int i = 0;
                String record = null;
                while ((record = reader.readLine()) != null) {
                    String[] parts = record.split("!");
                    Prediction p = new Prediction();
                    p.setWho(parts[0]);
                    p.setWhat(parts[1]);
                    p.setId(mapKey);

                    predictions.put(String.valueOf(mapKey++), p);
                }
            }
            catch (IOException e) { }
        }
    }
}</pre></div></div><br class="example-break" /><p>The remaining <code class="literal">Predictions</code> code is slightly changed, if at all, from the earlier version.
For example, the <code class="literal">populate</code> method is modified slightly to give each newly constructed
<code class="literal">Prediction</code> an <code class="literal">id</code>; but the method’s main job is still to read data from the text
file encapsulated in the WAR, data that represent the <code class="literal">who</code> and the <code class="literal">what</code> of each
<code class="literal">Prediction</code>.</p><p>The <code class="literal">PredictionServlet</code> (see Example 3) replaces the JSP script and differs from this
script in supporting all of the CRUD operations. The servlet offers new functionality
by allowing the client to request JSON format for the response of any GET request. Further,
the JSP script interpreted GET to mean <span class="emphasis"><em>read all</em></span> but the servlet allows the client to
request a read for a single <code class="literal">Prediction</code> or for them all.</p><div class="example"><a id="Ex3"></a><p class="title"><b>Example 3. The <code class="literal">PredictionsServlet</code> with full support for the CRUD operations</b></p><div class="example-contents"><pre class="screen">package cliches2;

import java.util.concurrent.ConcurrentMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.ws.http.HTTPException;
import java.util.Arrays;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.beans.XMLEncoder;
import org.json.JSONObject;
import org.json.XML;

public class PredictionsServlet extends HttpServlet {
    private Predictions predictions; // back-end bean

    // Executed when servlet is first loaded into container.
    // Create a Predictions object and set its servletContext
    // property so that the object can do I/O.
    public void init() {
        predictions = new Predictions();
        predictions.setServletContext(this.getServletContext());
    }

    // GET /cliches2
    // GET /cliches2?id=1
    // If the HTTP Accept header is set to application/json (or an equivalent
    // such as text/x-json), the response is JSON and XML otherwise.
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        String key = request.getParameter("id");

        // Check user preference for XML or JSON by inspecting
        // the HTTP headers for the Accept key.
        String accept = request.getHeader("accept");
        boolean json = accept.contains("json") ? true : false;

        // If no query string, assume client wants the full list.
        if (key == null) {
            ConcurrentMap&lt;String, Prediction&gt; map = predictions.getMap();

            // Sort the map's values for readability.
            Object[] list = map.values().toArray();
            Arrays.sort(list);

            String xml = predictions.toXML(list);
            sendResponse(response, xml, json);
        }
        // Otherwise, return the specified Prediction.
        else {
            Prediction pred = predictions.getMap().get(key);

            if (pred == null) { // no such Prediction
                String msg = key + " does not map to a prediction.\n";
                sendResponse(response, predictions.toXML(msg), false);
            }
            else { // requested Prediction found
                sendResponse(response, predictions.toXML(pred), json);
            }
        }
    }

    // POST /cliches2
    // HTTP body should contain two keys, one for the predictor ("who") and
    // another for the prediction ("what").
    public void doPost(HttpServletRequest request, HttpServletResponse response) {
        String who = request.getParameter("who");
        String what = request.getParameter("what");

        // Are the data to create a new prediction present?
        if (who == null || what == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);

        // Create a Prediction.
        Prediction p = new Prediction();
        p.setWho(who);
        p.setWhat(what);

        // Save the ID of the newly created Prediction.
        int id = predictions.addPrediction(p);

        // Generate the confirmation message.
        String msg = "Prediction " + id + " created.\n";
        sendResponse(response, predictions.toXML(msg), false);
    }

    // PUT /cliches
    // HTTP body should contain at least two keys: the prediction's id
    // and either who or what.
    public void doPut(HttpServletRequest request, HttpServletResponse response) {
        /* A workaround is necessary for a PUT request because neither Tomcat
           nor Jetty generates a workable parameter map for this HTTP verb. */
        String key = null;
        String rest = null;
        boolean who = false;

        /* Let the hack begin. */
        try {
            BufferedReader br =
                new BufferedReader(new InputStreamReader(request.getInputStream()));
            String data = br.readLine();
            /* To simplify the hack, assume that the PUT request has exactly
               two parameters: the id and either who or what. Assume, further,
               that the id comes first. From the client side, a hash character
               # separates the id and the who/what, e.g.,

                  id=33#who=Homer Allision
            */
            String[] args = data.split("#");      // id in args[0], rest in args[1]
            String[] parts1 = args[0].split("="); // id = parts1[1]
            key = parts1[1];

            String[] parts2 = args[1].split("="); // parts2[0] is key
            if (parts2[0].contains("who")) who = true;
            rest = parts2[1];
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }

        // If no key, then the request is ill formed.
        if (key == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);

        // Look up the specified prediction.
        Prediction p = predictions.getMap().get(key);
        if (p == null) { // not found?
            String msg = key + " does not map to a Prediction.\n";
            sendResponse(response, predictions.toXML(msg), false);
        }
        else { // found
            if (rest == null) {
                throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
            }
            // Do the editing.
            else {
                if (who) p.setWho(rest);
                else p.setWhat(rest);

                String msg = "Prediction " + key + " has been edited.\n";
                sendResponse(response, predictions.toXML(msg), false);
            }
        }
    }

    // DELETE /cliches2?id=1
    public void doDelete(HttpServletRequest request, HttpServletResponse response) {
        String key = request.getParameter("id");
        // Only one Prediction can be deleted at a time.
        if (key == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
        try {
            predictions.getMap().remove(key);
            String msg = "Prediction " + key + " removed.\n";
            sendResponse(response, predictions.toXML(msg), false);
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }

    // Method Not Allowed
    public void doInfo(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }

    // Method Not Allowed
    public void doHead(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }

    // Method Not Allowed
    public void doOptions(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }

    // Send the response payload to the client.
    private void sendResponse(HttpServletResponse response, String payload, boolean json) {
        try {
            // Convert to JSON?
            if (json) {
                JSONObject jobt = XML.toJSONObject(payload);
                payload = jobt.toString(3); // 3 is indentation level for nice look
            }

            OutputStream out = response.getOutputStream();
            out.write(payload.getBytes());
            out.flush();
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
}</pre></div></div><br class="example-break" /><div class="sidebar" title="The challenge of thread synchronization in servlets"><p class="title"><b>The challenge of thread synchronization in servlets</b></p><p>A web server such as Tomcat can instantiate arbitrarily many instances of a servlet, although the number is
typically small, for example, 1 through 4. Although the <span class="emphasis"><em>web.xml</em></span> deployment file can recommend how
many instances of a servlet should be loaded into the servlet container at startup, the web server
itself makes the decision. For example, Tomcat by default loads one instance of a servlet to begin but may load
more instances thereafter if simultaneous requests for the servlet are sufficient in number. Whatever the
number of servlet instances, the number of client requests per instance is typically greater—and significantly
so. For example, one servlet instance might handle tens of simultaneous requests. For reasons of efficiency, a web server
such as Tomcat keeps the number of servlet instances as small as possible in supporting reasonable
response time per request. A high-volume web server might have to handle hundreds or even thousands of
requests per second, distributed across many servlets; and one servlet per request is out of the question in
this real-world scenario. The upshot is that Java-based web servers rely on multithreading to handle simultaneous requests.
The model is sometimes described as <span class="emphasis"><em>one thread per request</em></span>.</p><p>For reasons of performance, a web server such as Tomcat creates a thead pool at startup; as requests come
in, each is dispatched to a thread from the pool, which then handles the request and returns to the pool
afterwards. The pooling amortizes the relatively
expensive cost of thread creation across the web server’s uptime. There are, of course, various ways to
measure how well a web server is performing. One critical measure is response time. For example, a web site
might require that the average response time per request be no more than, say, 10 <span class="emphasis"><em>ms</em></span>.</p><p>The one-thread-per-request model poses challenges for the servlet/JSP programmer, in particular the
challenge of thread coordination or <span class="emphasis"><em>synchronization</em></span>. For example, if there are a dozen
concurrent requests against the <code class="literal">PredictionsServlet</code> of the revised <span class="emphasis"><em>sayings</em></span> service, then each of
these requests is implemented as a thread that executes the appropriate <span class="emphasis"><em>do</em></span>-method in the servlet.
On a multi-core server (that is, a server with more than CPU), one thread could be
executing the <code class="literal">doGet</code> method at exactly the same time as another is executing the <code class="literal">doPut</code> method: the
result is a simultaneous <span class="emphasis"><em>read</em></span> and <span class="emphasis"><em>write</em></span> operation on the same resource. There are various
other concurrency scenarios, any one of which requires proper thread synchronization; and the programmer
rather than the servlet container must ensure that these scenarios maintain thread safety.</p><p>A servlet container such as Catalina or Jetty, in contrast to an EJB container, does <span class="emphasis"><em>not</em></span> ensure
thread safety; instead, the programmer is responsible for proper thread coordination. A servlet must be
programmed so that, for example, two requests—each implemented as a separate thread—cannot simultaneously
update the same resource such as a <code class="literal">Prediction</code>. In earlier Java versions, the mainstay of thread coordination was the
<code class="literal">synchronized</code> block; later versions of Java have added higher-level constructs, many in the
<code class="literal">java.util.concurrent</code> package, for managing
thread-based concurrency. The revised <span class="emphasis"><em>sayings</em></span> service uses a <code class="literal">ConcurrentMap</code> from this package to coordinate
simultaneous thread access to the <code class="literal">Predictions</code>.
A <code class="literal">ConcurrentMap</code> segments its entries; as a result, the map
usually needs to lock only a portion of its total entries to enforce synchronization. In summary, the
<code class="literal">ConcurrentMap</code> synchronizes request access to the <code class="literal">Predictions</code> collection and does so in an
efficient manner.</p></div><p>Recall that each of the <span class="emphasis"><em>do</em></span>-methods in an <code class="literal">HttpServlet</code> takes the same arguments: an
<code class="literal">HttpServletRequest</code>, a map that contains the information encapsulated in the HTTP request, and an
<code class="literal">HttpServletRespose</code>, which encapsulates an output stream for communicating back with the client.
Here is the start of <code class="literal">doGet</code> method:</p><pre class="screen">public void doGet(HttpServletRequest request, HttpServletResponse response) {</pre><p>The <code class="literal">HttpServletRequest</code> has a <code class="literal">getParameter</code> method that expects a string argument, a
key into the request map, and returns either <code class="literal">null</code> if there is no such key or the
key’s value otherwise. The <code class="literal">getParameter</code> method is agnostic about whether the
key/value pairs are in the body of, for example, a POST request or in the
query string of, for example, a GET request. The method works the same in either case.
There is also a <code class="literal">getParameters</code> method that returns the parameter collection as a whole.</p><p>In the case of <code class="literal">PredictionsServlet</code>, the <code class="literal">doGet</code> method needs to answer two questions
about the incoming request:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Does the body-less GET request include a key named <code class="literal">id</code> whose value identifies a particular <code class="literal">Prediction</code>?
</p><p class="simpara">If the <code class="literal">id</code> is present, the <code class="literal">doGet</code> method uses this value as a lookup key in the <code class="literal">ConcurrentMap</code>, which
holds references to all of the <code class="literal">Prediction</code> objects. If the lookup fails, then the <code class="literal">doGet</code> method
method returns an XML message to that effect:</p></li></ul></div><pre class="screen">Prediction pred = predictions.getMap().get(key);
if (pred == null) { // no such Prediction
    String msg = key + " does not map to a prediction.\n";
    sendResponse(response, predictions.toXML(msg), false);
}</pre><p>The last argument to the <code class="literal">sendResponse</code> method indicates whether JSON rather than XML should be
sent back to the client. In this case, XML only is returned.
If the <code class="literal">id</code> parameter is not present, the <code class="literal">doGet</code> method assumes that the client wants to read a
list of all <code class="literal">Predictions</code> and returns this list in either JSON or XML format:</p><pre class="screen">ConcurrentMap&lt;String, Prediction&gt; map = predictions.getMap();
// Sort the map's values for readability.
Object[] list = map.values().toArray();
Arrays.sort(list);
...</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Does the client prefer JSON over XML?
</p><p class="simpara">In an HTTP request, the requester can express a preference for the MIME type of the
returned representation. For example, the header element</p></li></ul></div><pre class="screen">Accept: text/html</pre><p>expresses a preference for the MIME type/subtype <code class="literal">text/html</code>. Among the MIME combinations is
<code class="literal">application/json</code> that, together with several variants, expresses a preference for JSON. The <code class="literal">doGet</code>
method therefore checks the HTTP header element with <code class="literal">Accept</code> as its key</p><pre class="screen">String accept = request.getHeader("accept");
boolean json = accept.contains("json") ? true : false;</pre><p>to determine whether the client prefers JSON to XML. (Recall that HTTP is case insensitive; hence,
the key could be <code class="literal">Accept</code>, <code class="literal">accept</code>, <code class="literal">ACCEPT</code>, and so on.) The <code class="literal">json</code> flag is the third argument
to the <code class="literal">sendResponse</code> method:</p><pre class="screen">private void sendResponse(HttpServletResponse res, String payload, boolean json) {
   try {
      if (json) {
        JSONObject jobt = XML.toJSONObject(payload);
        payload = jobt.toString(3); // 3 is indentation level for nice look
      }
      OutputStream out = res.getOutputStream();
      out.write(payload.getBytes());
      out.flush();
   }
   catch(Exception e) {
      throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
   }
}</pre><p>The deployed WAR file <span class="emphasis"><em>cliches2.war</em></span> includes a lightweight, third-party JSON library in the
JAR file <span class="emphasis"><em>json.jar</em></span> (see <span class="emphasis"><em>http://www.json.org/java</em></span>). If the client prefers JSON over XML, then the response <code class="literal">payload</code>
is converted to JSON. If anything goes awry in sending the response back to the client,
the servlet throws an <code class="literal">HTTPException</code>, which in this case generates a resonse with
HTTP status code 500 for <span class="emphasis"><em>Internal Server Error</em></span>, a catch-all for server-side
problems.</p><p>The <code class="literal">doPost</code> and <code class="literal">doPut</code> operations are similar in that the first creates a new <code class="literal">Prediction</code>
using data in the body of a POST request and the second edits an existing <code class="literal">Prediction</code> from
data in the body of a PUT request. The main difference is that a PUT request needs to include
the <code class="literal">id</code> of the <code class="literal">Prediction</code> to be updated, whereas a POST request creates a new
<code class="literal">Prediction</code> and then sets its <code class="literal">id</code> to an auto-incremented integer. In implementation, however,
<code class="literal">doPost</code> and <code class="literal">doPut</code> differ significantly because neither Tomcat nor Jetty generates a
usable parameter map, the <code class="literal">HttpServletRequest</code>, on a PUT request; both web servers do
generate a usable parameter map on a POST request. As a result, the <code class="literal">doPut</code> implementation
needs to get close to the HTTP metal.</p><p>To begin, here is the <code class="literal">doPost</code> implementation, without the comments:</p><pre class="screen">public void doPost(HttpServletRequest request, HttpServletResponse response) {
   String who = request.getParameter("who");
   String what = request.getParameter("what");

   if (who == null || what == null)
      throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);

   Prediction p = new Prediction();
   p.setWho(who);
   p.setWhat(what);
   int id = predictions.addPrediction(p);

   String msg = "Prediction " + id + " created.\n";
   sendResponse(response, predictions.toXML(msg), false);
}</pre><p>The two calls to the <code class="literal">getParameter</code> method extract the required data. A new <code class="literal">Prediction</code>
is then constructed, its <code class="literal">who</code> and <code class="literal">what</code> properties are set, and a confirmation is
generated for the client.</p><p>In the <code class="literal">doPut</code> method, the <code class="literal">getParameter</code> method does not work correctly because neither
Tomcat nor Jetty builds an appropriate parameter map inside of the <code class="literal">HttpServletRequest</code>.
The workaround is to access directly the input stream encapsulated in the
<code class="literal">HttpServletRequest</code></p><pre class="screen">BufferedReader br =
   new BufferedReader(new InputStreamReader(request.getInputStream()));
String data = br.readLine();
...</pre><p>and then to the parse the <code class="literal">data</code> from this stream. The code, though not pretty, gets
the job done. The point of interest is that the <code class="literal">HttpServletRequest</code> does provide
access to the underlying input stream from which the PUT data can be extracted. Using
the <code class="literal">getParameter</code> method is, of course, much easier.</p><p>The body of <code class="literal">doDelete</code> method has straightforward logic:</p><pre class="screen">String key = request.getParameter("id");
if (key == null)
   throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
try {
   predictions.getMap().remove(key);
   String msg = "Prediction " + key + " removed.\n";
   sendResponse(response, predictions.toXML(msg), false);
}
catch(Exception e) {
   throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
}</pre><p>If <code class="literal">id</code> for the <code class="literal">Prediction</code> can be extracted from the parameter map, then the
<code class="literal">Prediction</code> is effectively removed from the collection by removing the lookup key
from the <code class="literal">ConcurrentMap</code>.</p><p>The <code class="literal">PredictionsServlet</code> also implements three other <span class="emphasis"><em>do</em></span>-methods and all in the same way. Here, for example,
is the implementation of <code class="literal">doHead</code>:</p><pre class="screen">public void doHead(HttpServletRequest request, HttpServletResponse response) {
     throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
}</pre><p>Throwing the <code class="literal">HTTPException</code> signals to the client that the underlying HTTP
verb, in this case <code class="literal">HEAD</code>, is not supported. The numeric status code for
<code class="literal">Method Not Allowed</code> is 405.</p></div><div class="section" title="1.2.2. Sample Client Calls against the sayings Service"><div class="titlepage"><div><div><h4 class="title"><a id="_sample_client_calls_against_the_literal_sayings_literal_service"></a>1.2.2. Sample Client Calls against the <code class="literal">sayings</code> Service</h4></div></div></div><p>Example 4 is a list of <span class="emphasis"><em>curl</em></span> calls against the service. These calls serve as a very preliminary test
of the service. Two semi-colons introduce comments that explain the purpose of
the <span class="emphasis"><em>curl</em></span> call. Recall that the Ant script can be used to deploy the <span class="emphasis"><em>sayings</em></span> service under Tomcat:</p><pre class="screen">% ant -Dwar.name=cliches2 deploy</pre><div class="example"><a id="Ex4"></a><p class="title"><b>Example 4. A suite of <span class="emphasis"><em>curl</em></span> calls against the <span class="emphasis"><em>sayings</em></span> RESTful service</b></p><div class="example-contents"><pre class="screen">;; GET all sayings (XML response)
% curl localhost:8080/cliches2/   ;; shorthand for: curl --request GET localhost:8080/cliches2/

;; GET a specified saying (XML response)
% curl localhost:8080/cliches2?id=31

;; GET all sayings (JSON response)
% curl --header "Accept: application/json" localhost:8080/cliches2/

;; GET a specified saying (JSON response)
% curl --header "Accept: application/json" localhost:8080/cliches2?id=31

;; POST a new saying
% curl --request POST --data "who=TSEliot&amp;what=This is the way the world will end" localhost:8080/cliches2/

;; GET all sayings to confirm the POST (new saying is at the end)
% curl localhost:8080/cliches2/

;; PUT new data into an existing saying
% curl --request PUT --data "id=33#what=This is an update" localhost:8080/cliches2/

;; GET all sayings to confirm the PUT (edited saying is at the end)
% curl localhost:8080/cliches2/

;; DELETE a specificed saying
% curl --request DELETE localhost:8080/cliches2?id=33

;; GET all sayings to confirm the DELETE
% curl localhost:8080/cliches2/</pre></div></div><br class="example-break" /><p>The XML responses from the revised <span class="emphasis"><em>sayings</em></span> service are formatted exactly the same as in the
original version. Here is a sample JSON response from a GET request on the <code class="literal">Prediction</code> with
<code class="literal">id</code> 31:</p><pre class="screen">{"java": { "class": "java.beans.XMLDecoder",
   "object": {
      "void": [
         {
            "int": 31,
            "property": "id"
         },
         {
            "string": "Balanced clear-thinking utilisation will expedite collaborative initiatives.",
            "property": "what"
         },
         {
            "string": "Deven Blanda",
            "property": "who"
         }
      ],
      "class": "cliches2.Prediction"
   }, "version": "1.6.0_21"
}}</pre></div></div><div class="section" title="1.3. A RESTful Web Service as a JAX-RS Resource"><div class="titlepage"><div><div><h3 class="title"><a id="_a_restful_web_service_as_a_jax_rs_resource"></a>1.3. A RESTful Web Service as a JAX-RS Resource</h3></div></div></div><p>The servlet API, the grizzled workhorse for Java web sites, is still nimble enough to support RESTful web services as well.
There are more recent APIs, among them JAX-RS (Java API for XML-RESTful Web Services). JAX-RS relies upon Java annotations to
advertise the RESTful role that a class and its encapsulated methods play. Jersey (<span class="emphasis"><em>http://jersey-java.net</em></span>) is the
<span class="emphasis"><em>reference implementation</em></span> (RI) of JAX-RS and includes Grizzly, a development-oriented web server and
container that can be used to publish JAX-RS services. RESTEasy, a JBoss project (<span class="emphasis"><em>http://www.jboss.org/resteasy</em></span>), is
another implementation. JAX-RS works well with Tomcat and Jetty (see the sidebar).
The Jersey distribution can be download in various ways, including as a bundled JAR file for convenience. My examples
assume that Jersey is available as this single JAR file, at this writing <span class="emphasis"><em>jersey-bundle-1.17.jar</em></span>.</p><div class="sidebar" title="Deploying JAX-RS web services with Tomcat"><p class="title"><b>Deploying JAX-RS web services with Tomcat</b></p><p>The Jersey packages do not ship with core Java. These packages must be available to Tomcat (or Jetty)
in order for the web server to publish a JAX-RS service. Further, the service’s deployed WAR file
nees to link, through <span class="emphasis"><em>web.xml</em></span> entries, the service and the Jersey infrastructure. In effect, the
<span class="emphasis"><em>web.xml</em></span> tells Tomcat to do the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Any request for the JAX-RS service should be passed to a Jersey servlet, which in turn interacts
with the particular web service.
</li><li class="listitem">
Throughout the request/response cycle, the Jersey servlet as an intermediary between the service
and the servlet container.
</li></ul></div><p>At a practical level, two steps are required:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The Jersey bundle in a single JAR (or its equivalent) should be copied to <span class="emphasis"><em>TOMCAT_HOME/lib</em></span>. If Tomcat is
running, it needs to be restarted as Tomcat loads the JAR files in the <span class="emphasis"><em>lib</em></span> directory only at start-up.
</li><li class="listitem"><p class="simpara">
The deployed WAR file’s <span class="emphasis"><em>web.xml</em></span> links the web service to Jersey. Here is a minimalist example
of such a <span class="emphasis"><em>web.xml</em></span> with <span class="emphasis"><em>cliches3.war</em></span> as the name name of the WAR file:
</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
  &lt;servlet&gt;
     &lt;servlet-name&gt;jerseyServlet&lt;/servlet-name&gt;
     &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;jerseyServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/cliches3/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></li></ul></div><p>This <span class="emphasis"><em>web.xml</em></span> instructs Tomcat to forward any request whose URI begins with <span class="emphasis"><em>/cliches3/</em></span> to the
Jersey servlet, which then interacts with the web service deployed in <span class="emphasis"><em>cliches3.war</em></span>.</p></div><p>This section has two examples. The first example introduces the look and feel of JAX-RS; the second
example, a port of the <span class="emphasis"><em>sayings</em></span> service to JAX-RS, illustrates various service-side features of this API.</p><div class="section" title="1.3.1. A First JAX-RS Web Service"><div class="titlepage"><div><div><h4 class="title"><a id="_a_first_jax_rs_web_service"></a>1.3.1. A First JAX-RS Web Service</h4></div></div></div><p>Example 5 is the <code class="literal">Adage</code> class, which has an <code class="literal">import</code> for the JAX-B (Java API for XML-Binding)
annotation <code class="literal">XmlRootElement</code>. The term <span class="emphasis"><em>binding</em></span> refers, in this context, to linking a
Java data type such as <code class="literal">String</code> to an XML type, in this case <span class="emphasis"><em>xsd:string</em></span>.</p><div class="example"><a id="Ex5"></a><p class="title"><b>Example 5. The <code class="literal">Adage</code> class annotated for XML generation through JAX-B</b></p><div class="example-contents"><pre class="screen">package aphorism;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "adage")
public class Adage {
    private String words;
    private int wordCount;

    public Adage() { }

    // overrides
    @Override
    public String toString() {
        return words + " -- " + wordCount + " words";
    }

    // properties
    public void setWords(String words) {
        this.words = words;
        this.wordCount = words.trim().split("\\s+").length;
    }
    public String getWords() { return this.words; }

    public void setWordCount(int wordCount) { }
    public int getWordCount() { return this.wordCount; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">XmlRootElement</code> annotation signals that an <code class="literal">Adage</code> object can be transformed into an XML document
whose <span class="emphasis"><em>document</em></span> or <span class="emphasis"><em>root</em></span> (that is, outermost) element is named <code class="literal">adage</code>. For example,
the XML document</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;adage&gt;
  &lt;wordCount&gt;7&lt;/wordCount&gt;
  &lt;words&gt;What can be shown cannot be said.&lt;/words&gt;
&lt;/adage&gt;</pre><p>results from the JAX-B transformation of an in-memory <code class="literal">Adage</code> object to an XML document.</p><p>The <code class="literal">Adages</code> class (see Example 6) is a JAX-RS <span class="emphasis"><em>resource</em></span> that accepts RESTful requests, in
this case only GET requests, and responds with payloads of three MIME types: <code class="literal">text/plain</code>,
<code class="literal">application/json</code>, and <code class="literal">application/xml</code>.</p><div class="example"><a id="Ex6"></a><p class="title"><b>Example 6. The <span class="emphasis"><em>Adages</em></span> class as a JAX-RS resource</b></p><div class="example-contents"><pre class="screen">package aphorism;

import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.JAXBElement;
import javax.xml.namespace.QName;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.util.Random;

@Path("/")
public class Adages {
    // Add aphorisms to taste...
    private String[ ] aphorisms =
       {"What can be shown cannot be said.",
        "If a lion could talk, we could not understand him.",
        "Philosophy is a battle against the bewitchment of our intelligence by means of language.",
        "Ambition is the death of thought.",
        "The limits of my language mean the limits of my world."};

    public Adages() { }

    @GET
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
    public JAXBElement&lt;Adage&gt; getXml() {
        return transform2Document(createAdage());
    }

    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public String getJson() {
        return "json\n";
    }

    @GET
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/plain")
    public String getPlain() {
        return createAdage().toString() + "\n";
    }

    // Java object
    private Adage createAdage() {
        Adage adage = new Adage();
        adage.setWords(aphorisms[new Random().nextInt(aphorisms.length)]);
        return adage;
    }

    // Java object as XML/JSON document
    @XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
    private JAXBElement&lt;Adage&gt; transform2Document(Adage adage) {
        return new JAXBElement&lt;Adage&gt;(new QName("adage"), Adage.class, null, adage);
    }
}</pre></div></div><br class="example-break" /></div></div></div></div></body></html>

[[ch06webservicessecurity]]

== Web Services Security

Security for web services covers a lot of territory, which cannot be explored all at once. To make the exploration more
manageable, it seems best to analyze small chunks, one at a time, before pulling the exploration results together.
Here is a sketch of how this chapter breaks up the broad topic of security into smaller pieces:

Wire-level security:: Security begins at the transport or wire level, that is, with basic protocols that govern communications 
between a web service, whether SOAP-based or REST-style, and its clients. Security at this level typically provides three services. 
First, the client and service need transport-level assurance that each is communicating with the other rather than with some impostor. 
Second, the data sent from one side to the other need to be encrypted strongly enough so that an interceptor cannot decrypt the data 
and thus gain access to the confidential information carried therein. Third, each side needs assurance that the received 
message is the same as the sent 
message. This chapter covers the basics of wire-level security with code examples, most of which focus on HTTPS as a 
provider of wire-level security. 

User authentication and authorization:: Web services provide clients with access to resources. If a resource is secured, 
then a client needs the appropriate credentials to gain access. The credentials are presented and verified through a process 
that usually has two phases. In the first phase, a client (user) presents information such as a username together with a credential 
such as a password. 
If the credential is not accepted, access to the requested resource is denied. The first phase is known as 'user authentication'. 
The second phase, which is optional, consists of fine-tuning the authenticated subject's access rights. 
For example, a stock-picking web service might provide all paying customers with a username and password; but the service might divide the 
customers into categories, for instance, _regular_ and _premier_. Access to certain resources might be restricted 
to _premier_ clients. The second phase 
is known as 'role authorization'. This chapter introduces users-role security, a common name for the two-phase process.

WS-Security:: WS-Security, or WSS for short, is a collection of protocols that specify how different levels of 
security can be enforced within the SOAP-messaging infrastructure rather than through a particular transport (for instance,
HTTPS) or through a particular service container (for instance, Tomcat). For example, WSS specifies 
how digital signatures 
and encryption information can be inserted into SOAP headers. If SOAP-based services are to be 
transport-neutral, then various security features must be built into SOAP itself.
Accordingly, WSS is meant to provide comprehensive end-to-end security regardless of the 
underlying transport and regardless of the container that hosts the service. 
This chapter introduces WS-Security with an example.

=== Wire-Level Security

Consider a pay-for web service such as Amazon's S3 storage service. This service needs to authenticate 
requests to store and retrieve data so that only the paying clients have access to the service and that, moreover, 
a particular client has privileged access to its paid-for storage. In the RESTful version of S3, Amazon uses a customization 
of keyed HMAC (Hash Message Authentication Code) to authenticate client requests. Amazon allows the authentication
credential to be in either the query string (which is part of the HTTP headers) or in another header key/value pair 
with +Authorization+ as the key. In either case, the basic approach is the same:

* Parts of the request data are concatenated together to form a single string, which becomes the input value for a hash computation. 
This string is the _input message_.

* The AWS (Amazon Web Services) 'secretKey', a unique bit string that Amazon provides to each client and which has been discussed 
with respect to clients against the Amazon E-Commerce service, is used to 
compute the hash value of the _input message_ (see <<fig5_digest>>). A hash value is also called a _message digest_, 
which is a fixed-length digest of arbitrarily many input bits. For the S3 service Amazon uses the SHA-1 (Secure Hash Algorithm-1) 
version of HMAC, which produces a 160-bit digest no matter what the bit length of the input may be. Amazon calls this hash value 
the _signature_ because the value functions like a digital signature, although technically a digital signature is an _encrypted_ 
message digest. What Amazon calls the _signature_ is not encrypted but is encoded in base64.

[[fig5_digest]]
.A message digest
image::images/jwsu_0501.png[]

* The Amazon signature is added to the request in the HTTP 1.1 +Authorization+ header (or the query string).

* Upon receipt of the request, the Amazon S3 first validates the Amazon signature and then honors the request
only if the validation succeeds. Essentially this is the same validation process used in the 'predictionsSOAP' example of Chapter 5.

What prevents a client's request to Amazon S3 from being intercepted and the value of its 
+Authorization+ header, the Amazon authentication signature, from being pirated? Amazon assumes that the request is sent over the 
secure communications channel that HTTPS (HyperText Transport Protocol Secure) provides. HTTPS is HTTP 
with an added security layer. Netscape did the original work in the design and implementation of this security layer and called 
it SSL (Secure Sockets Layer). The IETF (International Engineering Task Force) has taken over SSL and renamed it to TLS 
(Transport Layer Security). Although SSL and TLS differ in version numbers and in some technical details, they will be
treated as basically the same here. In any case, it is common to use SSL, TLS, and SSL/TLS interchangeably.

Java has various packages that support SSL/TLS in general and HTTPS in particular. The JSSE (Java Secure Sockets Extension) API,
which covers the packages +javax.net+ and +javax.net.ssl+, has been 
part of core Java since JDK 1.4. Of interest here is that higher levels of security, such as user authentication, usually 
require wire-level security of the kind that HTTPS provides. Accordingly, the discussion of web services security begins with HTTPS
and the wire-level security that this protocol provides.

==== HTTPS Basics

HTTPS is easily the most popular among the secure versions of HTTP. HTTPS provides three critical 
security services over and above the transport services that HTTP provides. The following is a summary of 
the three (see <<fig_05_alicebob>>). In the figure, Alice needs to send a secret message to 
Bob. Eve, however, may be eavesdropping. Eve may try to dupe Alice and Bob into believing that they are 
communicating with one another when, in fact, each is communicating instead with Eve. This scenario is known as 
the MITM (Man In The Middle) attack. For secure communications, Alice and Bob thus need these three services:

Peer authentication:: Alice needs Bob to authenticate himself so that she is sure about who is on the receiving end before 
she sends the secret message. Bob, too, needs Alice to authenticate herself so that he knows that the secret message is 
from her rather than an impostor such as Eve. This step also is described as _mutual authentication_ or _mutual challenge_.

Confidentiality:: Once Alice and Bob have authenticated each other, Alice needs to encrypt the secret message in such a 
way that only Bob can decrypt it. Even if Eve intercepts the encrypted message, Eve should not be able to decrypt the 
message because doing so requires enormous computational power or incredibly good luck.

Integrity:: The message that Alice sends should be identical to the one that Bob receives. If not, an error condition 
should be raised. The received message might differ from the sent one for various reasons; for instance, noise in the 
communications channel or deliberate tampering on Eve's part. Any difference between the sent and the received message should be detected.

[[fig_05_alicebob]]
.A secret message from Bob to Alice despite Eve
image::images/jwsu_0502.png[]
These features can be implemented in different ways. Before considering how HTTPS implements the three features, 
it will be useful to look briefly at data encryption and decryption because 'confidentiality' is among the three
services that HTTPS provides.

==== Symmetric and Asymmetric Encryption/Decryption
Modern approaches to encryption follow two different approaches, symmetric and asymmetric. Under either approach, 
the bits to be encrypted (_plain bits_) are one input to an encryption engine and an encryption _key_ is the other 
input (see <<fig_05_encrypt>>). 
[[fig_05_encrypt]]
.Basic encryption and decryption
image::images/jwsu_0503.png[]
The encrypted bits are the _cipher bits_. If the input bits represent text, then they are the _plaintext_ and the output bits are 
the _ciphertext_. The cipher bits are one input to the decryption engine; and a decryption key is the other input. 
The decryption produces the original plain bits. In the symmetric approach, the _same_ key--called the _secret_  or the 
'single' key--is used to encrypt and to
decrypt (see <<fig_05_symmetric>>). The symmetric approach has the advantage of being relatively fast but the disadvantage
of what is known as the 'key distribution problem'. How is the secret key itself to be distributed to the sender and the receiver?
[[fig_05_symmetric]]
.Single key encryption and decryption
image::images/jwsu_0504.png[]

In the asymmetric approach, the starting point is a _key pair_, which consists of a _private key_ and a _public key_. 
As the names suggest, the private key should not be distributed but, rather, safeguarded by whoever generated the key pair. 
The public key can be distributed freely and publicly. If message bits are encrypted with the public key, they 
can be decrypted only with the private key--and vice-versa. <<fig_05_asymmetric>> illustrates. The asymmetric 
approach solves the key distribution problem; but asymmetric encryption and decryption are roughly a thousand times 
slower than their symmetric counterparts.
[[fig_05_asymmetric]]
.Public key encryption and decryption
image::images/jwsu_0505.png[]
The public key approach solves the confidentiality problem for Alice and Bob. If Alice encrypts the message with the public key 
from Bob's key pair, and Bob has the only copy of the private key from this pair, then only Bob can decrypt the message. 
Even if Eve intercepts Alice's message, she cannot decrypt the message with Bob's public key.

==== How HTTPS Provides the Three Security Services
Of the three required security services--peer authentication, confidentiality, and integrity--the last is the 
least complicated. The message sent over HTTPS includes a digest value, which the receiver recomputes. If the sent 
digest value differs from the digest value that the receiver computes, then the message was altered during transmission, 
either by accident or design. If the sent digest value itself is altered during transmission, this likewise counts as integrity failure.

HTTPS handles peer authentication through the exchange of digital certificates. In many cases, however, it is 
only the client that challenges the server. Consider a typical web-site application in which a shopper finalizes an order 
for the contents of his shopping cart by submitting a credit card number to the vendor. Here is a summary of what typically 
happens when the client-side browser and the web server negotiate to set up an HTTPS connection:

* The customer's browser challenges the vendor's web server to authenticate itself; and the server 
responds by sending one or more digital certificates to the browser.

* The browser checks the web server's digital certificates against the browser's _truststore_, 
which is a database of digital certificates that the browser trusts. The browser's validation of an 
incoming certificate can be and, for practical reasons, typically is indirect. For example, suppose that 
the browser receives a certificate from Amazon but does not have an Amazon certificate in its truststore. 
Suppose further that the Amazon certificate contains a vouching signature from VeriSign, a well-known 
certificate authority (CA). If the browser's truststore has a VeriSign certificate, then the browser 
can use the VeriSign certificate to validate the VeriSign signature on the Amazon certificate. 
+
How is the VeriSign certificate to be verified? For the verification process
to terminate, at least one certificate in the chain must be taken as verified.
For now the point of 
interest is that the browser's truststore is its repository of certificates that are used to verify 
incoming certificates. If the browser cannot validate an incoming certificate against its truststore, then 
the browser typically asks the human user whether the certificate should be trusted this time only or permanently. 
If the user selects _permanently_, the browser adds the certificate to its truststore.

* The web server typically does _not_ challenge the browser. For one thing, the web site is interested in 
the shopper's credit card rather than in the identity of the user agent (in this case, the browser) that 
the shopper happens to be using. In web services as opposed to web sites, two-way or peer authentication is
common.

The usually one-sided authentication challenge at play in web sites, with the client challenging the server 
but not the other way around, shows up in Tomcat's configuration file, 'TOMCAT_HOME/conf/server.xml'. Here is the entry for HTTPS:
----
<Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false"   <1>
           sslProtocol="TLS"/>
----
The +clientAuth+ attribute is set to +false+ (line 1), thereby indicating that Tomcat does not challenge the client. 
If the +clientAuth+ attribute were set to +true+, then Tomcat would challenge the client's user agent; and a setting
of +true+ might be of interest for web services in particular. In this configuration file,
there is no setting for a +serverAuth+ because the default client behavior is to challenge the server.

==== The HTTPS Handshake

For authentication and confidentiality, HTTPS relies on digital certificates, which are widely used in public key 
cryptography precisely because the exchange of secret keys is so difficult among many users. Here is a summary of how 
HTTPS authentication is intertwined with HTTPS confidentiality. The process is sometimes described as the _handshake_ 
between client and server that culminates in a secure network connection. In this scenario, the client might be a 
browser or an application functioning as a web service client. For convenience, the term _web server_ covers both a 
standard web-site server such as Tomcat or a full-bodied 
Java Application Server such as Oracle WebLogic, GlassFish, JBoss, or WebSphere:

* The client challenges the web server, which sends one or more digital certificates as authentication. Modern digital 
certificates usually have the X.509 format. The current X.509 version is named v3.

* An X.509 certificate is a _public key certificate_ that serves as an _identity certificate_ by binding the public key from 
a key pair to an identity such as a person (for instance, Alice) or an organization (for instance, Bob's employer). 
The certificate contains the digital signature of a CA such as a VeriSign, although certificates can be self-signed for 
testing purposes. In signing a digital certificate, a CA endorses the certificate and thereby verifies that the certificate's 
public key is bound to a particular identity. For instance, VeriSign signs Alice's certificate and thereby verifies that the
certificate's public key belongs to Alice's key pair.

* The client can determine whether to accept the server's digital certificates by checking these against its truststore.
The check can be direct or indirect. In a direct check, the received digital certificate is checked against a copy
in the truststore. In an indirect check, the CA's digital signature, which occurs as part of the certificate and vouches 
for its legitimacy, needs to be verified; and this verification, in turn, requires a digital certificate from the CA.

* The server has the option of challenging the client. For a web site, such a challenge is unusual; for a web service,
such a challenge can serve as a way of identifying and authenticating the web-service client.

* Once the challenge phase is over, the client begins the process of generating a secret key. The process begins with the 
client's generation of a _pre-master secret_, a string that is shared with the server. The pre-master is then used 
on each side to generate the same _master_ secret key, which is used to encrypt and decrypt the traffic between the 
client and the server. At issue here is how the pre-master secret is sent securely from the client to the server.

* In a common scenario, the client encrypts a 48-bit pre-master secret with the server's public key, available on the server's 
digital certificate downloaded during the peer authentication phase. The encrypted pre-master secret is sent to 
the server, which decrypts the secret. If everything is still in order, each side confirms that encryption of traffic 
between them is to begin. The 'public key'/'private key' pair is thus critical in solving the key distribution problem for secret keys.

* At any point, either the client or the server may insist on starting the entire process all over again. For example, 
if either Alice or Bob suspects that Eve is up to no good, either Alice or Bob can restart the handshake process.

A secret key is used to encrypt and decrypt traffic for several reasons. First, symmetric encryption has relatively high 
performance. Second, if the server does not challenge the client, then the server does not have the client's public 
key to encrypt messages to the client. The server cannot encrypt messages with its own private key, as any receiver (for instance, Eve) 
with access to the server's public key then could decrypt the message. Finally, encrypting and decrypting with two 
separate key pairs is inherently trickier--and significantly slower--than using a shared secret key.

The primary challenge is to get the pre-master secret securely from the client to the server; and the server's public key, 
available to the client in the server's digital certificate after the mutual challenge phase, fits the bill 
perfectly. The master secret key is generated only after the client and the server have agreed upon which _cipher suite_, or 
set of cryptographic algorithms, should 
be used. A cipher suite, including a key-pair algorithm and a hash algorithm, will be examined through a code example shortly.

Although digital certificates now play a dominant role in mutual challenge scenarios, they are not the only game in town. 
For example, SRP (Secure Remote Protocol) implements mutual challenge but without digital certificates. For more on SRP, see 
'srp.stanford.edu'.

==== The +HttpsURLConnection+ Class

It is time to flesh out these architectural sketches with a code example. The class +HttpsURLConnection+, which extends the
+HttpURLConnection+ class, supports HTTPS connections. The +GoogleClient+ application (see <<google_client>>) uses this class 
to issue a GET request under HTTPS against Google's home site. Note that the port number in the 
URL is 443 (line 1), the standard 
port for HTTPS connections.

[[google_client]]
.A client that makes an HTTPS connection to Google.
====
----
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import java.net.MalformedURLException;
import java.security.cert.Certificate;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class GoogleClient {
    private static final String endpoint = "https://www.google.com:443/";         <1>

    // Send a GET request and print the response status code.
    public static void main(String[ ] args) {
	new GoogleClient().doIt();
    }
    private void doIt() {
	try {
	    URL url = new URL(endpoint);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();  <2>
            conn.setDoInput(true);
	    conn.setRequestMethod("GET");                                         <3>  
	    conn.connect();
	    dumpDetails(conn);
	}
	catch(MalformedURLException e) { System.err.println(e); }
	catch(IOException e) { System.err.println(e); }
    }
    private void dumpDetails(HttpsURLConnection conn) {
	try {
	    print("Status code:  " + conn.getResponseCode());                     <4>
	    print("Cipher suite: " + conn.getCipherSuite());                      <5>
	    Certificate[ ] certs = conn.getServerCertificates();                  <6>
	    for (Certificate cert : certs) {
		print("\tCert. type: " + cert.getType());
		print("\tHash code:  " + cert.hashCode());                        <7>
		print("\tAlgorithm:  " + cert.getPublicKey().getAlgorithm());     <8> 
		print("\tFormat:     " + cert.getPublicKey().getFormat());        <9>
		print("");
	    }
	}
	catch(Exception e) { System.err.println(e); }
    }
    private void print(Object s) { System.out.println(s); }
}
----
====
The endpoint URL for an HTTPS connection to Google begins with +https+ (known in HTTP as the 'scheme') and the
port number, +443+, is the standard one for HTTPS connections. Modern web servers typically accept HTTP connections 
on port 80 and HTTPS connections on port 443, although these numbers are configurable. For example, Tomcat by
default listens on port 8080 for HTTP connections and on port 8443 for HTTPS connections. The HTTPS URL for
Google is line 1 in the code listing.

The +GoogleClient+ next opens an HTTPS connection (line 2) and prepares for a GET request against Google (line 3).
Once the connection is made, the application invokes +dumpDetails+ to print information about the secure connection:
the type of certificates returned from Google during the challenge, the 'hash code' or 'fingerprint' that identifies
each certificate, the algorithm used to generate the key pair, and the format of the certificate (lines 5 through 9
in the code listing). The +dumpDetails+ method also prints the response code, the by-now familiar 200 that 
signals a successful GET request. On a sample run, the output from +dumpDetails+ was:
----
Status code:  200
Cipher suite: TLS_ECDHE_RSA_WITH_RC4_128_SHA <1>
	Cert. type: X.509
	Hash code:  12584213
	Algorithm:  RSA
	Format:     X.509

	Cert. type: X.509
	Hash code:  2815543
	Algorithm:  RSA
	Format:     X.509
----
Line 1 in the listing gives the 'cipher suite', a collection of information about the algorithms used in the
initial handshake and in the encryption/decryption of messages exchanged after a successful handshake. Underscore
characters separate the parts of the cipher suite. Here is a summary of the parts:

TLS:: The Transport Layer Security, added to HTTP, yields HTTPS and thus accounts for the *S* in HTTPS.
ECDHE:: The acronym stands for Elliptic Curve Diffie-Hellman key Exchange, which is the algorithm that governs the handshake.
RSA:: This is the _public key cryptography algorithm_, named after Rivest, Shamir, and Adleman, the former MIT professors who designed it. 
RSA is the most commonly used public key algorithm. It is used to encrypt the pre-master that is sent from the client to the server. Also,
the public key on exchanged digital certificates comes from an RSA-generated key pair.

RC4_128:: The _stream cipher algorithm_, which is used to encrypt and decrypt the bit traffic between client and server, has a key 
length of 128 bits. The R is for Rivest in RSA, and the C is for cipher. (Sometimes RC is said to be shorthand for _Ron's Code_, 
as Rivest's first name is Ron.) RC4 is the most commonly used stream cipher. 
RC4_128 is used to encrypt the data traffic once the handshake is completed.

SHA:: The certificate's 160-bit identifying hash, also called its _fingerprint_, is generated with the Secure Hash Algorithm, officially
officially known as a 'cryptographic hash function'. There is a family of SHA algorithms but SHA-1, used here, is probably still the
most widely used member of this family.

The Google web server sent two digital certificates during the mutual challenge phase. Each is an X.509 
certificate generated with the RSA algorithm; and each of the SHA fingerprints is 160 bits in length. 
The format of each certificate follows the X.509 specification.

How does the +GoogleClient+ verify the two X.509 certificates the Google web server sends? There is nothing in 
the +GoogleClient+ code to suggest certificate verification. The core Java JDK ships with a default truststore 
('JAVA_HOME/jre/lib/security/cacerts'). Because the +GoogleClient+ opens an HTTPS connection to the Google web
server, the Java run-time intervenes to handle the certificate verification; and because Google is such a standard web
site, the 'cacerts' truststore has entries to verify the Google certificates. What about HTTPS connections to less 
popular and prominent sites? Java's security API makes it possible to disable peer authentication 
so that a client such as the +GoogleClient+ can take over certificate verification and make its own decisions about
what to accept and to reject. The +GoogleTrustingClient+ (see <<google_trusting_client>>) 
revises the +GoogleClient+ and shows how programmatic verification can be done--or by-passed altogether.

[[google_trusting_client]]
.The +GoogleTrustingClient+, which turns off certificate verification.
====
----
import java.net.URL;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import javax.net.ssl.SSLContext;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.net.MalformedURLException;
import java.security.cert.Certificate;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class GoogleTrustingClient {
    private static final String endpoint = "https://www.google.com:443/";

    public static void main(String[ ] args) {
	new GoogleTrustingClient().doIt();
    }
    private void doIt() {
	try {
	    // Configure the HttpsURLConnection so that it does not
	    // check certificates.
	    SSLContext sslCtx = SSLContext.getInstance("TLS");                        <1>
	    TrustManager[ ] trustMgr = getTrustMgr();                                 <2>
	    sslCtx.init(null,                // key manager                           <3>
			trustMgr,            // trust manager                         <4>
			new SecureRandom()); // random number generator               <5>
	    HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory()); <6>

	    URL url = new URL(endpoint);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setDoInput(true);
	    conn.setRequestMethod("GET");
	    conn.connect();
	    dumpDetails(conn);
	}
	catch(MalformedURLException e) { System.err.println(e); }
	catch(IOException e) { System.err.println(e); }
	catch(Exception e) { System.err.println(e); }
    }
    private TrustManager[ ] getTrustMgr() {                                           <7>
	// No exceptions thrown in any of the methods.
	TrustManager[ ] certs = new TrustManager[ ] {                                  
	    new X509TrustManager() {
		public X509Certificate[ ] getAcceptedIssuers() {                      <8>
		    return null; 
		}
		public void checkClientTrusted(X509Certificate[ ] certs,              <9>
					       String type) { } 
		public void checkServerTrusted(X509Certificate[ ] certs,              <10>
					       String type) { }
	    }
	};
	return certs;
    }
    private void dumpDetails(HttpsURLConnection conn) {
	try {
	    print("Status code:  " + conn.getResponseCode());
	    print("Cipher suite: " + conn.getCipherSuite());
	    Certificate[ ] certs = conn.getServerCertificates();
	    for (Certificate cert : certs) {
		print("\tCert. type: " + cert.getType());
		print("\tHash code:  " + cert.hashCode());
		print("\tAlgorithm:  " + cert.getPublicKey().getAlgorithm());
		print("\tFormat:     " + cert.getPublicKey().getFormat());
		print("");
	    }
	}
	catch(Exception e) { System.err.println(e); }
    }
    private void print(String s) { System.out.println(s); }
}
----
====
The +GoogleTrustingClient+ first gets an instance of an +SSLContext+ (line 1) and then invokes
+getTrustManager+ (line 2) to get a +TrustManager[ ]+, an array of managers for the
in-memory truststore. A +TrustManager+ defines three methods: 

+getAcceptedIssuers+:: This method (line 8) returns an array of +X509Certificate+ instances. In this case,
+null+ is returned, which is explained shortly. 

+checkClientTrusted+:: This method (line 9) expects, as one argument, an array of +X509Certificate+
instances and, as a second argument, a +String+ that describes the certificates type (for
instance, X509). The method has +void+ as the return type.

+checkServerTrusted+:: This method (line 10) expects the same arguments as +checkClientTrusted+.

Each method is minimally defined but--and this is the critical point--no method throws a +CertificateException+, which
means that the +TrustManager+ effectively accepts 'all' certificates. The +TrustManager+ array returned from
the +getTrustManager+ method (line 7) has a single member; and this member is all-trusting.
The result is that +GoogleTrustingClient+
effectively turns off certificate verification, a move that can be useful during development. In production,
the +TrustManager+ could implement whatever certificate-inspection logic is appropriate.

The security details about HTTPS can be examined concretely with a lightweight HTTPS server, introduced in the next
section. The +Endpoint+ utility class, used in earlier chapters to publish both REST-style and SOAP-based services,
does not support HTTPS connections. The +Endpoint+ publisher is built with the +HttpServer+ class, which
ships with core Java. The next section uses the related class +HttpsServer+ to clarify, with
code, how HTTPS works.

=== A Very Lightweight HTTPS Server and Client

An HTTPS server needs two stores for digital certificates:

keystore:: A 'keystore' contains digital certificates, including the certificates that an HTTPS server sends to
clients during the 'peer authentication' phase of the HTTPS handshake. When the server is challenged to establish
its identify, the server can send one or more certificates for its keystore to the challenger. If 'peer
authentication' is truly mutual, then a client as well needs a keystore with the client's own digital certificates,
which can be sent to the server for verification.

truststore:: A 'truststore' is a keystore with a specified function: the truststore stores trusted certificates
used to verify other certificates. When a host, server or client, receives a certificate to be verified, this
received certificate can be compared against truststore entries. If the truststore does not contain such
a certificate, the truststore may contain at least a certificate from a CA such as VeriSign, whose
digital signature is on the received certificate.

[[keystore_truststore]]
.A depiction of how a keystore and a truststore function.
====
----
  Keystore             
+-----------------------+  DC1,DC2,...,DCn
| Digital certificates |--------------------------------->challenging peer
+-----------------------+  DCs to challenging peer

  Truststore
+------------------------------+  DC1,DC2,...,DCn
| Trusted digital certificates |<--------------------------challenged peer
+------------------------------+  DCs from challenged peer                
----
====                                                 
Although the keystore and the truststore differ in core purpose (see <<keystore_truststore>>), 
one and the same file can function as both keystore and truststore; and, in development, this option is attractively simple.
In fleshing out these and related details about HTTPS security, the +HttpsPublisher+ (see <<https_server>>) code may be useful.

[[https_server]]
.The lightweight +HttpsPublisher+.
====
----
import java.net.InetSocketAddress;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;
import java.security.KeyStore;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import javax.xml.ws.http.HTTPException;
import java.io.OutputStream;
import java.io.InputStream;
import java.security.SecureRandom;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpsServer;
import com.sun.net.httpserver.HttpsConfigurator;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpsParameters;
import service.IService;

public class HttpsPublisher {
    private static final int defaultPort = 3443; 
    private static final int backlog = 12;      
    private static final String keystore = "test.keystore"; 
    private IService serviceInstance;                                           <1>

    public static void main(String[ ] args) {
	if (args.length < 2) {
	    System.err.println("Usage: java HttpsPublisher <service> <path>");
	    return;
	}
	// % java HttpsPublisher myService.Service /service 
	new HttpsPublisher().init(args[0],  // service name
				  args[1]); // URI
    }
    private void init(String serviceName, String uri) {
	try {
	    Class serviceClass = Class.forName(serviceName);                    <2>
	    serviceInstance = (IService) serviceClass.newInstance();            <3>
	}
	catch(Exception e) { throw new RuntimeException(e); }
	HttpsServer server = getHttpsServer(uri, defaultPort);
	if (server != null) {
	    server.createContext(uri);                                          <4>
	    System.out.println("Server listening on port " + defaultPort);
	    server.start();                                                     <5>
	}
	else
	    throw new RuntimeException("Cannot create server instance.");
    }
    private HttpsServer getHttpsServer(String uri, int port) {
	HttpsServer server = null;
	try {
	    InetSocketAddress inet = new InetSocketAddress(port);
	    server = HttpsServer.create(inet, backlog);                         <6>
	    SSLContext sslCtx = SSLContext.getInstance("TLS");
	    // password for keystore
	    char[ ] password = "qubits".toCharArray();
	    KeyStore ks = KeyStore.getInstance("JKS");
	    FileInputStream fis = new FileInputStream(keystore);
	    ks.load(fis, password);
	    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
	    kmf.init(ks, password);
	    TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
	    tmf.init(ks); // same as keystore
	    sslCtx.init(kmf.getKeyManagers(), 
			tmf.getTrustManagers(), 
			new SecureRandom()); 
	    // Create SSL engine and configure HTTPS to use it.
	    final SSLEngine eng = sslCtx.createSSLEngine();
	    server.setHttpsConfigurator(new HttpsConfigurator(sslCtx) {
		    public void configure(HttpsParameters parms) {
			parms.setCipherSuites(eng.getEnabledCipherSuites());
			parms.setProtocols(eng.getEnabledProtocols());
		    }
		});
	    server.setExecutor(null); // use default, hence single-threaded
	    server.createContext(uri, new MyHttpsHandler(this.serviceInstance));
	}
	catch(Exception e) { throw new RuntimeException(e); }
	return server;
    }
}
// The handle method is called on a particular request context,
// in this case on any request to the server that ends with /<uri>.
class MyHttpsHandler implements HttpHandler {
    private IService service; 

    public MyHttpsHandler(IService service) {
	this.service = service;
    }
    public void handle(HttpExchange ex) {
	// Implement a simple routing table.
        String verb = ex.getRequestMethod().toUpperCase();
	if (verb.equals("GET"))         service.doGet(ex);
	else if (verb.equals("POST"))   service.doPost(ex);
	else if (verb.equals("PUT"))    service.doPut(ex);
	else if (verb.equals("DELETE")) service.doDelete(ex);
	else throw new HTTPException(405);
    }
}
----
====
The +HttpsPublisher+ can be started with a command such as:
----
% java HttpsPublisher service.TestService /test
----
The first command-line argument, +service.TestService+ (see <<test_service>>), is the fully qualified name of a RESTful service's
implementation class; and the second command-line argument, in this case +/test+, is the URI that identifies
the service. Any service deployed with the +HttpsPublisher+ must implement the +IService+ interface
(see <<iservice_iface>>), which means that the four CRUD methods +doGet+, +doPost+, +doPut+, and +doDelete+ must
be defined. The +HttpsPublisher+ declares a reference of data type +IService+ (line 1 in the listing) and then
uses the +Class.forName+ utility to load a service class such as +TestService+
from the file system (line 2) and create an instance (line 3). The +IService+ interfaces thus
allows the +HttpPublisher+ to publish any service that implements the RESTful CRUD operations with the
designated method names. 

The +HttpsPublisher+ sets the context for requests (line 4), which in this
example means that a client must use the URI +/test+ to hit the +TestService+. The publisher maintains a 
queue of up to +backlog+ requests, currently set to 16, on the specified HTTPS port +3443+.
Finally, the 
+start+ method is invoked on the +HttpsServer+ instance (line 5), which starts the server for an indefinitely long
run.
[[iservice_iface]]
.The +IService+ interface.
====
----
package service;
import com.sun.net.httpserver.HttpExchange;

public interface IService {
    public void doGet(HttpExchange e);
    public void doPost(HttpExchange e);
    public void doPut(HttpExchange e);
    public void doDelete(HttpExchange e);
}
----
====

[[test_service]]
.The +TestService+ published with the +HttpsPublisher+.
====
----
package service;

import java.io.OutputStream;
import com.sun.net.httpserver.HttpExchange;

public class TestService implements IService {
    public void doGet(HttpExchange e) { respond2Client(e, "doGet"); }
    public void doPost(HttpExchange e) { respond2Client(e, "doPost"); }
    public void doPut(HttpExchange e) { respond2Client(e, "doPut"); }
    public void doDelete(HttpExchange e) { respond2Client(e, "doDelete"); }

    private void respond2Client(HttpExchange ex, String response) { 
	try {
	    ex.sendResponseHeaders(200, 0); // 0 == as many bytes as there are
	    OutputStream out = ex.getResponseBody();
	    out.write(response.getBytes());
	    out.close(); // effectively ends session
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====

Once the RESTful service class has been loaded, the +HttpsServer+ begins the tricky security
configuration. A client that opens an HTTPS connection to the +HttpsServer+ is going to challenge
this server to verify its identify; and the +HttpsServer+ responds with a digital certificate. 
The core Java JDK comes with a 'keytool' utility that can be used to create a 'self-signed' rather
than a CA-certified digital certificate. For development, the self-signed digital certificate is good enough; for
production, a CA-certified digital certificate would be needed. The command
----
% keytool -genkey -keyalg RSA -keystore test.keystore 
----
eventually creates the file 'test.keystore', which contains an X.509 digital certificate generated using the RSA algorithm. This
file is the keystore. The 'keytool' utility is interactive, prompting the user with questions that must be
answered. The first such question is about a password to protect access to the keystore. In this case, the password
is 'qubits'. For the current example, the keystore file 'test.keystore' (the name is arbitrary) performs
various functions.

* The file acts as a regular keystore that contains the digital certificate that the +HttpsPublisher+ sends to any challenger, in this
case the +HttpsClient+, which is introduced shortly.

* The file doubles as the +HttpsPublisher+ truststore and as the +HttpsClient+ truststore. Accordingly, the fix is in.
When the +HttpsPublisher+ sends the one and only digital certificate in the keystore 'test.keystore', the +HttpsClient+ verifies this
digital certificate by checking it against the very same keystore--but a keystore now functioning as a truststore. Were the +HttpsPublisher+
to challenge the +HttpsClient+, the client would send the same digital certificate as its identity voucher--and the +HttpsPublisher+
would verify this digital certificate against itself, in effect. 

Using the keystore for multiple purposes simplifies the set-up and keeps the focus on the technical coding details. In a
production environment, of course, there would be four keystores involved in this scenario: the +HttpsPublisher+ would have
a keystore with its certificates and a truststore with the certificates that it trusts; and the same would hold for the
+HttpsClient+.

The +HttpsPublisher+ reads into memory the digital certificate stored in the file named 'test.keystore'. Here is a block of initialization
code:
----
SSLContext sslCtx = SSLContext.getInstance("TLS");                      <1>
char[ ] password = "qubits".toCharArray();                              <2>
KeyStore ks = KeyStore.getInstance("JKS");
FileInputStream fis = new FileInputStream(keystore);
ks.load(fis, password);                                                 <3>
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
kmf.init(ks, password);                                                 <4>  
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks); // same as keystore
sslCtx.init(kmf.getKeyManagers(),                                       <5>
            tmf.getTrustManagers(),                                     <6>
            new SecureRandom()); 
final SSLEngine eng = sslCtx.createSSLEngine();
server.setHttpsConfigurator(new HttpsConfigurator(sslCtx) {
   public void configure(HttpsParameters parms) {
      parms.setCipherSuites(eng.getEnabledCipherSuites());              <7>
      parms.setProtocols(eng.getEnabledProtocols());                    <8>
   }});
server.setExecutor(null); // use default, hence single-threaded         <9>
server.createContext(uri, new MyHttpsHandler(this.serviceInstance));    <10>
----
The +SSLContext+ (line 1) is the central data structure; and this context supports secure (that is, TLS-based)
communications from clients to the +HttpsPublisher+. After the password bytes are stored in an array (line 2), the
contents of the keystore file, 'test.keystore', are loaded into memory (line 3) and a +KeyManagerFactory+
is initialized with the contents of this keystore file (line 4). There is now an in-memory version of the file 'test.keystore'.
The +TrustStoreFactory+ (line 5) is initialized with the contents of the very same
keystore file. At this point, the +SSLContext+ is initialized with the 'key managers' of the
keystore file and the 'trust managers' of the truststore file, which are the same file.

The next security initialization steps involve setting the appropriate cipher suites (line 7), which are
used during the handshake negotiations with a client. The security protocols that are available to the
server are likewise part of the initialization (line 8). For demonstration purposes, the +HttpsPublisher+
remains single-threaded, which explains the +null+ in line 9. To make the publisher multi-threaded, a
non-+null+ value for the +Executor+ (that is, the thread manager) would be used. Finally, the 
HTTPS server specifies a 'handler' to handle requests against the URI, in this case +/test+ (line 10).

The set-up code is tricky but its gist can be summarized as follows:

* An +SSLContext+ data structure is populated with security information, in particular the
keystore and truststore contents that the +HttpsPublisher+ needs to conduct the handshake with
a prospective client. 

* The +HttpsPublisher+ also uses the +SSLContext+ to create an +SSLEngine+, which manages
the cipher suites and related security protocols.

When the set-up is complete, the +HttpsPublisher+ is ready to accept HTTPS connections from
potential clients. Client requests are dispatched to an instance of the class +MyHttpsHandler+:
----
server.createContext(uri, new MyHttpsHandler(this.serviceInstance)); 
----
The constructor call to +MyHttpsHandler+ has, as its single argument, a reference to the
+IService+ instance so that GET requests can be forwarded to the +serviceInstance+ 
method +doGet+,
POST requests to +doPost+, and so on. The +MyHttpsHandler+ class implements
the +HttpHandler+ interface, which has a single method: +handle+. Here is the implementation:
----
public void handle(HttpExchange ex) {
    String verb = ex.getRequestMethod().toUpperCase();
    if (verb.equals("GET"))         service.doGet(ex);
    else if (verb.equals("POST"))   service.doPost(ex);
    else if (verb.equals("PUT"))    service.doPut(ex);
    else if (verb.equals("DELETE")) service.doDelete(ex);
    else throw new HTTPException(405); // bad verb
}
----
The flow of control (see <<handler_routing>>) is straightforward: a request targeted at the
URI +/test+ goes to the +MyHttpsHandler+ instance, which implements the +handle+ method.
The +handle+ method dispatches GET requests to the service's +doGet+ method, POST requests
to the service's +doPost+ method, and so on. The critical point is that the communications
between the +HttpsPublisher+ and the client are over a secure HTTPS channel.
[[handler_routing]]
.The routing in the +HttpsPublisher+.
====
----
             +----------------+    +----------------+    +----------+ doPost
requests---->| HttpsPublisher |--->| MyHttpsHandler |--->| IService | doGet
             +----------------+    +----------------+    +----------+ doPut
                                                                      doDelete
----
====
In the current implementation, the +TestService+ instance encapsulates minimalist versions of +doGet+, +doPost+,
+doPut+, and +doDelete+ operations. The point of interest is the security configuration, not the
actual behavior of the RESTful service. Each CRUD operation returns a string confirming that the
operation has been invoked. For HTTPS requests with bodies (that is, POST and PUT), the +HttpsClient+
(see <<https_client>>) sends a short string that the service operations ignore.

[[https_client]]
.The sample +HttpsClient+ against the +TestService+.
====
----
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.SecureRandom;

public class HttpsClient {
    private static final String endpoint = "https://localhost:3443/test/";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
	new HttpsClient().runTests();
    }
    private void runTests() {
	try {
	    SSLContext sslCtx = SSLContext.getInstance("TLS");
	    // password for truststore (same as server's keystore)
	    char[ ] password = "qubits".toCharArray();
	    KeyStore ks = KeyStore.getInstance("JKS");
	    FileInputStream fis = new FileInputStream(truststore);
	    ks.load(fis, password);
	    TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
	    tmf.init(ks); // same as keystore
	    sslCtx.init(null,                   // not needed, not challenged
			tmf.getTrustManagers(), 
			null);                  // use default: SecureRandom
	    HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
	    URL url = new URL(endpoint);
	    HttpsURLConnection conn = getConnection(url, "GET");
	    getTest(conn);
	    conn = getConnection(url, "POST");
	    postTest(conn);
	    conn = getConnection(url, "PUT");
	    putTest(conn);
	    conn = getConnection(url, "DELETE");
	    deleteTest(conn);
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url, String verb) {
	try {	
	    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
	    conn.setDoInput(true);
	    conn.setDoOutput(true);
	    conn.setRequestMethod(verb);
	    // Guard against "bad hostname" errors during handshake.
	    conn.setHostnameVerifier(new HostnameVerifier() {
		    public boolean verify(String host, SSLSession session) {
			return host.equals("localhost"); // for development
		    }
		});
	    return conn;
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest(HttpsURLConnection conn) {                <1>
	try {
	    conn.connect();
	    readResponse("GET request: ", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest(HttpsURLConnection conn) {               <2>
	try {
	    conn.connect();
	    writeBody(conn);
	    readResponse("POST request: ", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void putTest(HttpsURLConnection conn) {                <3>
	try {
	    conn.connect();
	    writeBody(conn);
	    readResponse("PUT request: ", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(HttpsURLConnection conn) {             <4>
	try { 
	    conn.connect();
	    readResponse("PUT request: ", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
	try {
	    OutputStream out = conn.getOutputStream();
	    out.write("foo bar baz".getBytes()); // anything will do
	    out.flush();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
	try {
	    byte[ ] buffer = new byte[512]; // plenty for testing
	    InputStream in = conn.getInputStream();
	    in.read(buffer);
	    System.out.println(msg + new String(buffer));
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====
The +HttpsClient+ (see <<https_client>>) makes requests against the four CRUD operations (lines 1, 2, 3, and 4) in the +TestService+ 
published with the +HttpsPublisher+
This client is similar in structure to the +GoogleTrustingClient+ examined earlier except that the
+HttpsClient+ does demand a digital certificate from the +HttpsPublisher+ and does verify this certificate
against a truststore. As noted earlier, the client's truststore is the same file, 'test.keystore', as the server's
keystore; hence, the verification is guaranteed to succeed. The +HttpsClient+ reads the truststore data into memory
and uses these data to initialize the all-important +SSLContext+. Here is the relevant code:
----
FileInputStream fis = new FileInputStream(truststore);
ks.load(fis, password);
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks); // same as keystore
sslCtx.init(null, // not needed, not challenged   <1>
            tmf.getTrustManagers(), 
            new SecureRandom());                
----
In the call to +init+ (line 1), the first argument is +null+, which represents the keystore managers. The
assumption is that the +HttpsPublisher+ will not challenge the +HttpsClient+, which therefore does not need a 
keystore for the handshake. Were 'mutual' challenge in operation, then the +HttpsClient+ set-up would be the
same, with respect to the keystore and the truststore, as in the +HttpsPublisher+.

Of course, a non-Java client also can connect over HTTPS to the +HttpsPublisher+. As proof of concept,
here is a very short Perl client that connects but does not bother to verify the digital certificates
that the +HttpsPublisher+ sends to the client:
----
use Net::SSLeay qw(get_https);
my ($type, $start_line, $misc, $extra) = get_https('localhost', 3443, '/test');
print "Type/value:  $type\n";
print "Start line:  $start_line\n";
print "Misc:        $misc => $extra\n";
----
The output from a sample run was:
----
Type/value:  doGet
Start line:  HTTP/1.1 200 OK
Misc:        CONNECTION => close
----
Changing from HTTP to HTTPS transport does not imperil the language neutrality and interoperability of
web services--assuming, of course, that the languages used on client-side and the service-side include
HTTPS libraries, as modern languages usually do.

=== HTTPS in a Production-Grade Web Server

The +HttpsPublisher+ is simple enough in structure to illustrate the basics of wire-level security. Among the
several reasons for going with a production-grade web server such as Tomcat or Jetty is that these 
servers provide such good support for HTTPS, at the application and at the administrative level. 
Although these web servers provide first-rate HTTPS support,
they do require set-up comparable to that illustrated with the +HttpsPublisher+. This section focuses on Tomcat.

Tomcat does not ship with a keystore of digital certificates and, accordingly, does not enable HTTPS by default. The 
service must be turned on by editing the configuration file 'TOMCAT_HOME/conf/server.xml', with details
provided shortly. The same keystore file used in the +HttpsPublisher+ example, 'test.keystore', could be
re-used for Tomcat. A modern browser connecting over HTTPS to Tomcat should complain that the 
digital certificate in 'test.keystore' is self-signed and, therefore, worthless as a security credential.
In production, a keystore with commercial-grade keystore digital certificates would be needed. Yet the point of immediate interest is
that Tomcat does require the programmer to jump through a few hoops in order to switch from an HTTP-accessible
to an HTTPS-accessible service. There are only three such hoops:

* HTTPS connections must be enabled in Tomcat by editing the 'server.xml' file. Details follow shortly.

* A keystore must be made available so that Tomcat can perform the handshake with potential clients 
and afterwards support the encryption and decryption of exchanged messages.

* The configuration file 'web.xml' must turn on HTTPS support for the web site or web service. No change
is required to the site or service code, however.

The first two changes are covered in the sidebar (see <<tomcat_https>>).

[[tomcat_https]]
.Setting up Tomcat for HTTPS support.
****
The primary configuration file for Tomcat is 'TOMCAT_HOME/conf/server.xml'. If this file is edited,
Tomcat must be re-started in order for the changes to take effect. The file contains several
elements tagged +Connector+. For example, here is the entry for the HTTP connector:
----    
<Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" />
----
The Tomcat port of HTTP connection is 8080 but this could be changed to, for instance, port 80.
The last attribute in this XML element has +redirectPort+ as its key and +8433+ as its value. Suppose
that a web site or web service requires HTTPS access but that a client tries to hit the site or
service using HTTP. Tomcat then counters with an 'HTTP redirect', instructing the client (for instance,
a browser in the case of a web site) to redirect to port 8443, the port at which Tomcat awaits
HTTPS connections. Tomcat, however, is not yet configured for HTTPS.

The +Connector+ element for HTTPS is commented out in 'server.xml':
----
<!--
<Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" />
-->
----
After removing the comment delimiters and restarting Tomcat, HTTPS should be enabled.

One further change is in order. Tomcat needs access to a keystore. The 'test.keystore' from the
+HttpsPublisher+ example could be used, of course, or a fresh keystore could be created. In any case,
the recommended change is to have the HTTPS +Connector+ element point explicitly to this file:
----
<Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" 
           keystoreFile="${user.home}/tcKeystore.keystore"   <1>
           keystorePass="qubits"/>                           <2>
----
Line 1 is the change, with the keystore file 'tcKeystore.keystore' stored in my home directory with 
the password 'qubits' (line 2).
The keystore file can be located anywhere on the local file system. Recall that Tomcat now must be 
restarted for these changes to take effect.

With these changes in place, entering the URL
----
https://localhost:8443/
----
in a browser or as an argument to the 'curl' utility results in the fetch of Tomcat's familiar welcome
page, the same page accessible through the HTTP URL
----
http://localhost:8080/
----

The attributes in the HTTPS +Connector+ element are intuitive. The +maxThreads+ value of 150 signals that
Tomcat will queue up to 150 requests against an HTTPS service before issuing a 'connection refused' response to
a client attempting to connect. The SSL protocol is the current standard, TLS; and the HTTP scheme used to
connect over HTTPS is, as expected, 'https'.
****

==== Enforcing HTTPS Access to a Web Service

A web site or a web service can instruct Tomcat to enforce HTTPS access to either the entire resource (for instance,
all of the HTML pages in the web site and all of the operations in the web service) or only parts thereof (for 
instance, to administrative HTML pages in the site or to selected operations in the service). The instructions
to Tomcat occur in a +security-constraint+ section of the 'web.xml' deployment file. To illustrate, the RESTful
'predictions2' service of Chapter 2, originally deployed with HTTP access only, can be redeployed with 
HTTPS access only. This requires no change whatsoever in the code. 
The revised 'web.xml' is <<revised_web>>.

[[revised_web]]
.The 'web.xml' revised for security.
====
----
<?xml version = "1.0" encoding = "UTF-8"?>
<web-app>
  <servlet>
    <servlet-name>predictor</servlet-name>
    <servlet-class>predictions2.PredictionsServlet</servlet-class>
  </servlet>
  <security-constraint>                                          <1>
    <web-resource-collection>
      <url-pattern>/*</url-pattern>                              <2>
    </web-resource-collection>
    <user-data-constraint>
      <transport-guarantee>CONFIDENTIAL</transport-guarantee>    <3>
    </user-data-constraint>
  </security-constraint>
  <servlet-mapping>
    <servlet-name>predictor</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----
====

The changes are limited to the +security-constraint+ section (line 1). In this example,
the security constraint is enforced on the entire resource because the +url-pattern+ (line 2)
has +/*+ as its value. The deployed WAR file 'predictions2.war' (created, as usual, with the
Ant script) could be partitioned in subdirectories, for example:
----
/admin    ;; contains administrative operations
/public   ;; contains publicly accessible operations
----
Under this partition, the service operations in the +/admin+ directory might require HTTPS
but not the ones in the +/public+ directory. To enforce this policy, the +url-pattern+ in line 2
would change to +/admin/*+. The +transport-guarantee+ element, with a value of
+CONFIDENTIAL+ (line 3), instructs Tomcat to enforce HTTPS access on the specified resource, in this
example on the entire 'predictions2' WAR file. If a client tried to access the 
'predictions2' service under HTTP, Tomcat would respond with an HTTP status code of 302 and the
appropriate 'https' URL, thereby signaling to the client that a new request with an HTTPS connection should be
attempted.

Within the +web-resource-collection+ element of 'web.xml', access constraints can be specified
that depend on the HTTP verb of the client request. For example, the 'web.xml' segment
----
<web-resource-collection>
  <url-pattern>/*</url-pattern>                           
  <http-method>POST</http-method> <1>
  <http-method>PUT</http-method>  <2>
</web-resource-collection>
----
specifies that access to the resource, in this case the entire 'predictions2' service, is constrained only on
POST and PUT requests (lines 1 and 2). If no specific HTTP verbs are specified, then the constraint covers them all.

==== An HTTPS Client against the 'predictions2' Service

[[https_predictions_client]]
.The +HttpsPredictionsClient+ against the 'predictions2' service
====
----
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.security.SecureRandom;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;

public class PredictionsHttpsClient {
    private static final String endpoint = "https://localhost:8443/predictions2";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
	new PredictionsHttpsClient().runTests();
    }
    private void runTests() {
	try {
	    SSLContext sslCtx = SSLContext.getInstance("TLS");
	    char[ ] password = "qubits".toCharArray();
	    KeyStore ks = KeyStore.getInstance("JKS");
	    FileInputStream fis = new FileInputStream(truststore);
	    ks.load(fis, password);
	    TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
	    tmf.init(ks); // same as keystore
	    sslCtx.init(null,                   // not needed, not challenged
			tmf.getTrustManagers(), 
			new SecureRandom());                
	    HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
	    getTest();
	    postTest();
	    getTestAll();     // confirm POST test
	    deleteTest("31"); 
	    getTestAll();     // confirm DELETE test
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url, String verb) {
	try {	
	    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
	    conn.setDoInput(true);
	    conn.setDoOutput(true);
	    conn.setRequestMethod(verb);
	    conn.setHostnameVerifier(new HostnameVerifier() {
		    public boolean verify(String host, SSLSession session) {
			return host.equals("localhost"); // for development
		    }
		});
	    return conn;
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest() {
	getTestAll();
	getTestOne("31");
    }
    private void getTestAll() {
	try {
	    URL url = new URL(endpoint);
	    HttpsURLConnection conn = getConnection(url, "GET");
	    conn.connect();
	    readResponse("GET all request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTestOne(String id) {
	try {
	    URL url = new URL(endpoint + "?id=" + id);
	    HttpsURLConnection conn = getConnection(url, "GET");
	    conn.connect();
	    readResponse("GET request for " + id + ":\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest() {
	try {
	    URL url = new URL(endpoint);
	    HttpsURLConnection conn = getConnection(url, "POST");
	    conn.connect();
	    writeBody(conn);
	    readResponse("POST request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(String id) {
	try {
	    URL url = new URL(endpoint + "?id=" + id);
	    HttpsURLConnection conn = getConnection(url, "DELETE");
	    conn.connect();
	    readResponse("DELETE request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
	try {
	    String pairs = "who=Freddy&what=Avoid Friday nights if possible.";
	    OutputStream out = conn.getOutputStream();
	    out.write(pairs.getBytes()); 
	    out.flush();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
	try {
	    byte[ ] buffer = new byte[4096]; 
	    InputStream in = conn.getInputStream();
	    ByteArrayOutputStream out = new ByteArrayOutputStream();
	    int n = 0;
	    while ((n = in.read(buffer)) != -1) out.write(buffer, 0, n); 
	    in.close();
	    System.out.println(new String(out.toByteArray())); // stringify and print
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====

The +PredictionsHttpsClient+  (see <<https_predictions_client>>) is a test client against
the HTTPS-deployed version of the 'predictions2' service. This client is roughly similar to the
+HttpsClient+ (<<https_client>>) but methods such as +readResponse+ and +writeBody+ now are
beefed up in order to make realistic CRUD requests against the service. For example, the
+postTest+ adds new +Prediction+ to the collection, which requires that +writeBody+ insert
the key/value pairs for the key +who+ (the predictor) and the key +what+ (the prediction); and the
+getTestAll+ must read all of the bytes returned from the service in order to display the
+Prediction+ list.

Tomcat's approach to HTTPS exemplifies the separation-of-concerns principle. A web service (or a web site)
need not be changed at the code level to move from HTTP to HTTPS access. It bears repeating that no code in the
original 'predictions2' service had to be changed; instead, only the deployment 
descriptor 'web.xml' needs to change and then only a little.
Tomcat also assumes responsibility for
enforcing HTTPS access in accordance with the policy given in the 'web.xml' document: a client that now tries to
hit the 'predictions2' service with an HTTP-based request is signaled that an HTTPS-based request should be used
instead.

=== Container-Managed Security

Wire-level security and users/roles security are related as follows. Under users/roles security, a client furnishes an identification such as a
'username' or even a digital certificate together with a security credential that vouches for the identification (for instance, a 'password' or
a signature on the digital certificate from a certificate authority). To avoid hijacking, the identification and the credential should be sent
from the client to the server through a secure channel, for instance, over an HTTPS connection. Wire-level security is thus the foundation upon which 
users/roles security should be implemented; and HTTPS is an ideal way to provide wire-level security for 'web'-based systems such as
web services.

[[users_roles]]
.Users/roles security.
====
----
   id       +----------------+     +---------------+     +----------+
----------->| user           |---->| role          |---->| secured  |
credential  | authentication |     | authorization |     | resource | 
            +----------------+     +---------------+     +----------+
                required              optional
----
====

Users/roles security is a two-phase process (see <<users_roles>>). In the first and required phase, the user provides an
identification and a credential that vouches for the identification. A successful 'user authentication' phase results in 
an 'authenticated subject'. In the optional second phase, 'role authorization', the access permissions of the
authenticated subject can be refined as needed. For example, in a software development organization there might be 
a distinction between a 'senior engineer' and a 'starting programmer' in that the former can access resources (for instance,
sensitive records in a database) that the latter cannot access. This distinction could be implemented with different
authorization roles.

At what level should users/roles security be enforced? Enforcement at the application level does not scale easily in that
every web service (or web site) would require code, perhaps consolidated into a library, dedicated to security; a web 
service still would need to link to such library code. The
preferred approach is hand over the security concerns to the service container, that is, to Tomcat or Jetty. This is 
'container-managed security', which is considered best practice. Tomcat's implementation of container-managed security,
like its management of wire-level security, is unobtrusive at the service level: no changes are required in the
web service code to enable users/roles security. Once again the configuration document 'web.xml' is the key.

The RESTful 'predictions2' service once again can be augmented with container-managed security--and without any
change to the code. The revised 'web.xml' document is displayed in <<https_aa>>.

[[https_aa]]
.The revised 'web.xml' to support both HTTPS and users/roles security.
====
----
<?xml version = "1.0" encoding = "UTF-8"?>
<web-app>
  <servlet>
    <servlet-name>predictor</servlet-name>
    <servlet-class>predictions2.PredictionsServlet</servlet-class>
  </servlet>
  <security-role>                                                <1> 
    <role-name>bigshot</role-name>                               <2>
    <!-- other roles as needed -->
  </security-role>
  <security-constraint>
    <web-resource-collection>
      <url-pattern>/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>                                            <3>
      <role-name>bigshot</role-name>                             
    </auth-constraint>
    <user-data-constraint>
      <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>
  </security-constraint>
  <login-config>                                                 <4>
    <auth-method>BASIC</auth-method>                             <5>
  </login-config>
  <servlet-mapping>
    <servlet-name>predictor</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----
====
The numbered lines in the revised 'web.xml' need clarification.

Security role declaration:: Line 1 declares a +security-role+, which is an 'authorization' role; and
line 2 sets the role's name to +bigshot+. On the Tomcat side, a data store must contain the same
role name, with details to follow.

Authorization constraint:: The +security-constraint+ element, introduced earlier, now contains two
specific constraints: the +user-data-constraint+, which enforces HTTPS transport, from the earlier
example; and the new +auth-constraint+ (line 3), which is an authorization rather than an
authentication constraint in the context of
users/roles security. The authorization constraint specifies that access to the 'predictions2'
resource, the service and its operations, is restricted to a client authorized as a +bigshot+.

User authentication method:: The +login-config+ element (line 4) designates +BASIC+ as the
user-authentication method (line 5). HTTP 1.1 supports four 'authentication types': BASIC, FORM,
DIGEST, and CLIENT-CERT. These four types were designed with web sites in mind but are adaptable
to web services as well. Here is a summary of the differences:
* The BASIC type, a holdover from HTTP 1.0, centers on a 'username' and a 'password', each
passed from the client to the server for authentication. The username/password pair is encoded in
base64 but not encrypted unless, of course, HTTPS is also in play.

* The FORM type refines the BASIC type by providing a form-based authentication mechanism, with
specified names for the input fields in the form. This type also requires an error form to handle 
authentication failures. Further, the authentication procedure is laid out in detail for the FORM variant,
unlike the BASIC variant.
For modern web sites, FORM-based authentication is best practice. The FORM type, like the BASIC
type, requires HTTPS or equivalent transport-level support to provide data encryption.

* The BASIC and FORM types require that the username and the 'password' be stored on the server side
because the server needs to compare the submitted username/password pair against the server's own
copies of these. A modern user, aware of the threat that security breaches represent, may be
understandably wary of having a password stored on devices that the user does not control.  The
DIGEST type meets this challenge by sending a digest (hash value) of the password rather than the
password itself. Accordingly, only a digest of the password needs to be stored on the server.
The server-side login process computes the digest, compares the computed digest against the stored digest, 
and grants
access only if these match. In general, digest or hash functions are 'one-way secure': given the
digest and even the algorithm used to compute the digest, it is still computationally intractable to
recover the original password. Indeed, message digests are fixed-length; hence, from the digest itself
it is a taunting task to recover even the 'length' of the original password. The DIGEST type as well
requires HTTPS or the equivalent transport-level support to provide data encryption.

* The CLIENT-CERT type uses a digital certificate instead of a username/password or username/password-digest
pair for authentication. For user access to web sites, this approach may be impractical because a user may
wish to hit a web site from a device that does not have a copy of the user's digital certificate. Also, such
certificates have expiration dates and so must be refreshed periodically. For web-service clients, by
contrast, the CLIENT-CERT type may have more appeal. For example, the client application might access the
digital certificate from a database or similar datastore that is managed automatically to ensure up-to-date
digital certificates.

The very simplicity of the BASIC type is attractive for clients against RESTful services, especially if
BASIC authentication is combined with HTTPS transport, which then provides the required username/password
encryption. 

==== Linking the Service 'web.xml' with a Tomcat Security Realm

The revised 'web.xml' document specifies the type of HTTP authentication in use, BASIC, as well as the
authorization role, +bigshot+, required of client that accesses the 'predictions2' service. The next question is how
Tomcat puts this security information to use, in other words, how Tomcat's container-managed security
works under the hood. Tomcat implements container-managed security with 'realms', which are akin to 
'groups' in Unix-type operating systems. In simplest form, a realm is collection
of usernames and passwords together the authorization roles, if any, associated with the usernames. The purpose of a realm is
to coordinate various security resources in support of a single policy on access control. On the service side, security 
information needs to be saved in datastore such as a relational database system; and Tomcat realms provide the details
about how the security information is to be saved and accessed.

Tomcat7 comes with six standard plug-ins, all of which have +Realm+ in their names. 
Developers are free to develop additional +Realm+ plug-ins.
Here are the six native Tomcat plug-ins with a short description of each:

JDBCRealm:: The authentication information is stored in a relational database accessible through a JDBC driver.

DataSourceRealm:: The authentication information again is stored in a relational database and accessible through a 
Java JDBC +DataSource+, which in turn is available through a JNDI (Java Naming and Directory Interface) lookup service.

JNDIRealm:: The authentication information is stored in an LDAP-based (Lightweight Directory Access Protocol) directory service, which is available 
through a JNDI provider.

UserDatabaseRealm:: The authentication information is stored in a JNDI resource coordinated by default with the file 
'TOMCAT_HOME/conf/tomcat-users.xml'. This is the default realm in Tomcat7.

MemoryRealm:: The authentication information is read into memory, at Tomcat startup, from the file 'tomcat-users.xml'.
This is an earlier version of the +UserDatabaseRealm+ and remains as an option for backward compatibility.

JAASRealm:: The authentication information is available through a JAAS (Java Authentication and Authorization Service) framework.
This is the most powerful but also the most complicated realm. Java Application Servers such as WebSphere and JBoss rely upon 
JAAS providers for users/roles security; and this option is available in Tomcat as well.

Under any of these choices, it is the Tomcat container rather than the application that becomes the security provider. With respect
to the options, the path of
least resistance leads to the default, the +UserDatabaseRealm+. Here is the datastore, the XML file
'tomcat-users.xml'.
The five elements commented out act as Tomcat's tutorial about how the file is to be used. My additions are lines
1 and 2: line 1 declares the security role used in line 2, which specifies a username and an associated 
password:
----
<tomcat-users>
  <role rolename="bigshot"/>                                         <1>
  <user username="moe" password="MoeMoeMoe" roles="bigshot"/>        <2>
</tomcat-users>
----
With the +UserDatabaseRealm+ now configured, the security process can be summarized as follows:

* The revised deployment file 'web.xml' requires not only HTTPS transport but also users/roles
authentication and authorization. 

* To access the secured 'predictions2' service, a client must
provide a username and a password that match an entry in 'tomcat-users.xml'.

* For the authorization phase to succeed, a matching +user+ entry in the file 'tomcat-users.xml' must
include +bigshot+ among the +roles+.

==== The Client-Side in Users/Roles Security

On the service-side, Tomcat is responsible for conducting the user authentication and role authorization. 
The burden
now shifts to the client, which must properly format, within an HTTPS request, the username
and password information. On the service side, the required changes are limited to the
web service's configuration file, 'web.xml', and to the Tomcat +UserDatabaseRealm+ file,
'tomcat-users.xml'. No code in the 'predictions2' service needs to change.

[[https_aa_predictions_client]]
.The +PredictionsHttpsClientAA+ client against the 'predictions2' service.
====
----
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.security.SecureRandom;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import org.apache.commons.codec.binary.Base64;

public class PredictionsHttpsClientAA {
    private static final String endpoint = "https://localhost:8443/predictions2";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
	new PredictionsHttpsClientAA().runTests();
    }
    private void runTests() {
	try {
	    SSLContext sslCtx = SSLContext.getInstance("TLS");
	    char[ ] password = "qubits".toCharArray();
	    KeyStore ks = KeyStore.getInstance("JKS");
	    FileInputStream fis = new FileInputStream(truststore);
	    ks.load(fis, password);
	    TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
	    tmf.init(ks); // same as keystore
	    sslCtx.init(null,                   // not needed, not challenged
			tmf.getTrustManagers(), 
			new SecureRandom());                
	    HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
	    // Proof of concept tests.
	    String uname = "moe";
	    String passwd = "MoeMoeMoe";
	    getTest(uname, passwd);
	    postTest(uname, passwd);
	    getTestAll(uname, passwd);     // confirm POST test
	    deleteTest(uname, passwd, "31"); 
	    getTestAll(uname, passwd);     // confirm DELETE test
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url, 
					     String verb, 
					     String uname, 
					     String passwd) {
	try {	
	    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
	    conn.setDoInput(true);
	    conn.setDoOutput(true);
	    conn.setRequestMethod(verb);
	    // authentication (although header name is Authorization)
	    String userpass = uname + ":" + passwd;
	    String basicAuth = "Basic " + 
               new String(new Base64().encode(userpass.getBytes()));
	    conn.setRequestProperty ("Authorization", basicAuth);
	    conn.setHostnameVerifier(new HostnameVerifier() {
		    public boolean verify(String host, SSLSession session) {
			return host.equals("localhost"); // for development
		    }
		});
	    return conn;
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest(String uname, String passwd) {
	getTestAll(uname, passwd);
	getTestOne(uname, passwd, "31");
    }
    private void getTestAll(String uname, String passwd) {
	try {
	    URL url = new URL(endpoint);
	    HttpsURLConnection conn = getConnection(url, "GET", uname, passwd);
	    conn.connect();
	    readResponse("GET all request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTestOne(String uname, String passwd, String id) {
	try {
	    URL url = new URL(endpoint + "?id=" + id);
	    HttpsURLConnection conn = getConnection(url, "GET", uname, passwd);
	    conn.connect();
	    readResponse("GET request for " + id + ":\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest(String uname, String passwd) {
	try {
	    URL url = new URL(endpoint);
	    HttpsURLConnection conn = getConnection(url, "POST", uname, passwd);
	    conn.connect();
	    writeBody(conn);
	    readResponse("POST request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(String uname, String passwd, String id) {
	try {
	    URL url = new URL(endpoint + "?id=" + id);
	    HttpsURLConnection conn = getConnection(url, "DELETE", uname, passwd);
	    conn.connect();
	    readResponse("DELETE request:\n", conn);
	    conn.disconnect();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
	try {
	    String pairs = "who=Freddy&what=Avoid Friday nights if possible.";
	    OutputStream out = conn.getOutputStream();
	    out.write(pairs.getBytes()); 
	    out.flush();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
	try {
	    byte[ ] buffer = new byte[4096]; 
	    InputStream in = conn.getInputStream();
	    ByteArrayOutputStream out = new ByteArrayOutputStream();
	    int n = 0;
	    while ((n = in.read(buffer)) != -1) out.write(buffer, 0, n); 
	    in.close();
	    System.out.println(new String(out.toByteArray())); // stringify and print
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====
The +PredictionsHttpsClientAA+ (see <<https_aa_predictions_client>>) adds users/roles security
on the client side to the earlier HTTPS client against the 'predictions2' service. The changes
are quite small. The +getConnection+ method has three new lines:
----
String userpass = uname + ":" + passwd;                                  <1>
String basicAuth = "Basic " + 
                   new String(new Base64().encode(userpass.getBytes())); <2>
conn.setRequestProperty ("Authorization", basicAuth);                    <3>
----
A +userpass+ string is created as a key/value pair, with the colon +:+ as the separator,
from the parameters +uname+ and +passwd+ (line 1). The +userpass+ is then encoded in base64 
and has +Basic+ prepended (line 2). The result is inserted into the HTTPS headers, with
+Authorization+ as the key. For +moe+ as the username and +MoeMoeMoe+ as the password, the
resulting header is:
----
Authorization: Basic bW9lOk1vZU1vZU1vZQ==
----
This set-up follows HTTP 1.1 guidelines and meets Tomcat expectations about how the
authentication/authorization information is to be formatted in the HTTPS request. As usual,
a client against a RESTful service needs to stay close to the HTTP/HTTPS metal.

==== Using the 'curl' Utility for HTTPS Testing

The 'curl' utility is an alternative to a full-blown RESTful client written in Java or some
other language. For the 'predictions2' service accessible through HTTPS and with
user-authentication/role-authorization in play, this 'curl' command sends a GET request:
----
% curl --verbose --insecure --user moe:MoeMoeMoe \
       https://localhost:8443/predictions2
----
The +--insecure+ flag means that 'curl' goes through handshake process but does not verify
the digital certificates sent from the server; the verification would require that 'curl'
be pointed to the appropriate truststore file. In any case, the output from a sample run, edited
slightly for readability, is shown in <<curl_out>>.
[[curl_out]]
.The output from a 'curl' request over HTTPS.
====
----
* About to connect() to localhost port 8443 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 8443 (#0)
* successfully set certificate verify locations:
*   CAfile: none
  CApath: /etc/ssl/certs
* SSLv3, TLS handshake, Client hello (1):
* SSLv3, TLS handshake, Server hello (2):
* SSLv3, TLS handshake, CERT (11):
* SSLv3, TLS handshake, Server key exchange (12):
* SSLv3, TLS handshake, Server finished (14):
* SSLv3, TLS handshake, Client key exchange (16):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSL connection using EDH-RSA-DES-CBC3-SHA
* Server certificate:
    ...
*   SSL certificate verify result: self signed certificate (18), <1>
    continuing anyway.                                
* Server auth using Basic with user 'moe'
> GET /predictions2 HTTP/1.1
> Authorization: Basic bW9lOk1vZU1vZU1vZQ==
> User-Agent: curl/7.19.7 (x86_64-pc-linux-gnu) libcurl/7.19.7 
              OpenSSL/0.9.8k zlib/1.2.3.3 libidn/1.15
> Host: localhost:8443
> Accept: */*
> 
< HTTP/1.1 200 OK
< Server: Apache-Coyote/1.1
< Cache-Control: private
< Expires: Wed, 31 Dec 1969 18:00:00 CST
< Transfer-Encoding: chunked
...
< 
<?xml version="1.0" encoding="UTF-8"?> 
<java version="1.6.0_21" class="java.beans.XMLDecoder"> 
...
----
====
In the 'curl' output, the character +>+ introduces text lines sent from 'curl' to the server, whereas 
the character +<+ introduces text lines from from the server to 'curl'. The lines that begin
with a star +*+ trace the TLS handshake process. Although 'curl' recognizes (line 1) that the
self-signed certificate from the server is worthless as a security credential, 'curl' continues the 
process, again because of the
+--insecure+ flag, by sending a GET request over HTTPS to the 'predictions2' service; and the
service responds with a list of the predictions.

==== A @WebService under HTTPS with Users/Roles Security

Tomcat supports HTTPS transport and users/roles security for SOAP-based services as well.
A SOAP-based client built atop 'wsimport'-generated artifacts can use a slightly higher-level API than
its REST-style counterpart to insert the required security credentials into an HTTPS request. This
section uses a minimal SOAP-based service to focus on security in the client against the service.
                         
[[temp_convert]]
.The SOAP-based +TempConvert+ service.
====
----
package tc;
import javax.jws.WebService;
import javax.jws.WebMethod;

@WebService
public class TempConvert {
    @WebMethod
    public float c2f(float t) { return 32.0f + (t * 9.0f / 5.0f); }
    @WebMethod
    public float f2c(float t) { return (5.0f / 9.0f) * (t - 32.0f); }
}
----
====
The SOAP-based +TempConvert+ service (see <<temp_convert>>) has two operations: +f2c+ converts temperatures
from fahrenheit to centigrade and +c2f+ converts them from centigrade to fahrenheit. With respect to
security, the 'web.xml' for this service is essentially the same as for the RESTful and secure
'predictions2' service. However, the 'web.xml' for the SOAP-based service needs to reference the Metro
+WSServlet+ (line 2), which acts as the intermediary between the servlet container and the service (see
<<soap_web>>); and the
additional configuration file, 'sun-jaxws.xml', is likewise required.

[[soap_web]]
.The 'web.xml' document for the SOAP-based +TempConvert+ service.
====
----
<?xml version = "1.0" encoding = "UTF-8"?>
<web-app>
  <listener>
    <listener-class>
      com.sun.xml.ws.transport.http.servlet.WSServletContextListener    <1>
    </listener-class>
  </listener>
  <servlet>
    <servlet-name>wsservlet</servlet-name>
    <servlet-class>
      com.sun.xml.ws.transport.http.servlet.WSServlet                   <2>
    </servlet-class>
  </servlet>
  <security-role>
    <role-name>bigshot</role-name>
    <!-- other roles as needed -->
  </security-role>
  <security-constraint>
    <web-resource-collection>
      <url-pattern>/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
      <role-name>bigshot</role-name>
    </auth-constraint>
    <user-data-constraint>
      <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>
  </security-constraint>
  <login-config>
    <auth-method>BASIC</auth-method>
  </login-config>
  <servlet-mapping>
    <servlet-name>wsservlet</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----
====
Lines 1 and 2 are the only changes to the 'web.xml' used in the earlier 'predictions2' service.
With the 'web.xml' and 'sun-jaxws.xml' in place, the +TempConvert+ service can be 
deployed in the usual way:
----
% ant deploy -Dwar.name=tc
----
How should the 'wsimport'-generated artifacts be generated for a service accessible only through
HTTPS? The attempt
----
% wsimport -p tcClient -keep https://localhost:8443/tc?wsdl
----
generates a +sun.security.validator.ValidatorException+ precisely because 'wsimport' is unable to 
conduct the HTTPS handshake: the utility does not have access to a truststore against which the
server's digital certificate(s) can be verified.
The service is HTTPS-secured and, therefore, so is the service's dynamically
generated WSDL. The 'wsgen' utility provides a workaround. The command
----
% wsgen -cp . tc.TempConvert -wsdl
----
generates the 'TempConvertService.wsdl' file and the 'TempConvertService_schema1.xsd' file. The
'wsimport' utility now can be targeted at the WSDL:
----
% wsmport -p tcClient -keep TempConvertService.wsdl
----
The only drawback is that the service's URL is not in the class +TempConvertService+
because the WSDL used is not generated dynamically. The +TempConvertClient+ (see <<temp_convert_client>>)
shows how to overcome this drawback.

[[temp_convert_client]]
.The +TempConvertClient+ against the SOAP-based +TempConvert+ service.
====
----
import tcClient.TempConvertService;
import tcClient.TempConvert;
import javax.xml.ws.BindingProvider;
import java.util.Map;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HttpsURLConnection;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

public class TempConvertClient {
    private static final String endpoint = "https://localhost:8443/tc";
    // Make the client "trusting" and handle the hostname verification.
    static {                                                                   <1>
	HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
		public boolean verify(String name, SSLSession session) {
		    return true; // allow everything
		}
	    });
	try {
	    TrustManager[ ] trustMgr = new TrustManager[ ] {
		new X509TrustManager() {
		    public X509Certificate[ ] getAcceptedIssuers() { return null; }
		    public void checkClientTrusted(X509Certificate[ ] cs, String t) { } 
		    public void checkServerTrusted(X509Certificate[ ] cs, String t) { }
		}
	    };
	    SSLContext sslCtx = SSLContext.getInstance("TLS");
	    sslCtx.init(null, trustMgr, null);
	    HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    public static void main(String args[ ]) {
	if (args.length < 2) {
	    System.err.println("Usage: TempConvertClient <uname> <passwd>");
	    return;
	}
	String uname = args[0];
	String passwd = args[1];
        TempConvertService service = new TempConvertService();
        TempConvert port = service.getTempConvertPort();
	BindingProvider prov = (BindingProvider) port;                         <2>
	prov.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, 
                                     endpoint);                                <3>
	prov.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, 
                                     uname);                                   <4>
        prov.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, 
                                     passwd);                                  <5>
        System.out.println("f2c(-40.1) = " + port.f2C(-40.1f));
        System.out.println("c2f(-40.1) = " + port.c2F(-40.1f));
        System.out.println("f2c(+98.7) = " + port.f2C(+98.7f));
    }
}
----
====
The +TempConvertClient+ uses a +static+ block (line 1) to make itself into a 'trusting' client
that does not check the server's digital certificate during the HTTPS handshake; the +static+
block also instructs the +HostnameVerifier+ to allow client access to any host,
including 'localhost'. The +static+ block isolates the transport-level security
so that the focus can be kept on the users/roles security. By the way, the +static+ block exploits the fact that
a JAX-WS client uses, under the hood, the +HttpsURLConnection+ of earlier RESTful examples.

To gain access to the transport-level, in particular to the headers in the HTTPS request, the
+TempConvertClient+ casts the +port+ reference to a +BindingProvider+ (line 2). The endpoint
then is set (line 3) to the correct URL because the 'wsimport'-generated classes do not have
a usable URL. The username and password, entered as command-line arguments,
are likewise placed in the HTTPS headers. This SOAP-based client need not bother with creating a
single string out the username and password or with encoding these in base64. Instead, the client
uses the intuitive 
----
BindingProvider.USERNAME_PROPERTY
BindingProvider.PASSWORD_PROPERTY
----
keys and sets the value for each. After the set-up, the client makes three calls against the SOAP-based service. The output is:
----
f2c(-40.1) = -40.055557
c2f(-40.1) = -40.18
f2c(+98.7) = 37.055557
----
==== Using a Digested Password Instead of a Password

A downside of BASIC authentication is that a client's password must be stored, as is, on the server-side 
so that the received password can be compared against the stored password. The DIGEST option requires
only that the 'hash value' of the password be stored on the server. The set-up for the DIGEST option
is trickier than for the BASIC option, however. Yet the BASIC option can be tweaked so that it behaves
just like the DIGEST option. This section illustrates.

Tomcat comes with a 'digest' utility: 'digest.sh' for Unixy systems and 'digest.bat' for Windows. The
command 
----
% digest.sh -a SHA MoeMoeMoe
----
generates a 20-byte hash value, in hex, using the SHA-1 algorithm. Here is the value:
----
0f9e52090a322d7f788db2ae6b603e8efbd7fbd1
----
In the 'TOMCAT_HOME/conf/tomcat-users.xml' file, this value replaces the password for +moe+ (line 1):
----
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
  <role rolename="bigshot"/>                                         
  <user username="moe" 
        password="0f9e52090a322d7f788db2ae6b603e8efbd7fbd1"  <1>
        roles="bigshot"/>        
</tomcat-users>
----
The file is otherwise unchanged.

The 'digest' utility is implemented with the +RealmBase.Digest+ method, which can be used in a Java client. The
revised client against the +TempConvertService+, named +TempConvertClient2+ (see <<temp_convert2>>), illustrates.
[[temp_convert2]]
.The revised +TempConvertClient2+.
====
----
import tcClient.TempConvertService;
import tcClient.TempConvert;
...
import org.apache.catalina.realm.RealmBase;                                      <1>

public class TempConvertClient2 {
    private static final String endpoint = "https://localhost:8443/tc";

    static {
       ...
    }
    public static void main(String args[ ]) {
	if (args.length < 2) {
	    System.err.println("Usage: TempConvertClient <uname> <passwd>");
	    return;
	}
	String uname = args[0];
	String passwd = args[1];
	String passwdHash = RealmBase.Digest(passwd,  // password                <2>
					     "SHA",   // algorithm
					     null);   // default encoding: utf-8
        TempConvertService service = new TempConvertService();
        TempConvert port = service.getTempConvertPort();
	BindingProvider prov = (BindingProvider) port;
	prov.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, 
                                     endpoint);
	prov.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, 
                                     uname);
        prov.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, 
                                     passwdHash);                                <3>
        ...
    }
}
----
====
Most of the code in the +TempConvertClient2+ client is the same as that in the original.
The +import+ in line 1 is the first difference: the Tomcat libraries include the +RealmBase+ class
whose +Digest+ method is of interest (line 2). The +Digest+ method generates the hash value for the
sample password, in this case +MoeMoeMoe+, which is given as a command-line argument. The hash value
instead of the actual password then is placed in the HTTPS headers (line 3). On the service-side, 
the send hash value is compared against the hash value stored in the revised 'tomcat-users.xml'. The 
ZIP with the sample code includes 'runClient.xml', an Ant script to compile and execute the 
+TempConvertClient2+. A sample invocation with output is:
----
% ant -f runClient.xml -Darg1=moe -Darg2=MoeMoeMoe

Buildfile: run.xml
compile:
run:
     [java] f2c(-40.1) = -40.055557
     [java] c2f(-40.1) = -40.18
     [java] f2c(+98.7) = 37.055557
----

=== WS-Security

WS-Security is a family of specifications (see <<fig_05_wss>>) designed to augment wire-level security ('e.g.', HTTPS) and
container-managed security ('e.g.', Tomcat) by providing a 
unified, transport-neutral, container-neutral, end-to-end framework for higher levels of security such 
as message confidentiality and authentication/authorization.

[[fig_05_wss]]

.The WS-Security specifications
image::images/jwsu_0506.png[]

The layered blocks above WS-Security in <<fig_05_wss>> can be clarified briefly as follows. The first layer 
consists of WS-Policy, WS-Trust, and WS-Privacy. The second layer of WS-SecureConversation, WS-Federation, and 
WS-Authorization builds upon this first layer. The architecture is thus modular but also complicated. Here is a 
short description of each specification, starting with the first layer:

WS-Policy:: This specification describes general security capabilities, constraints, and policies. For example, a 
WS-Policy assertion could stipulate that a message requires security tokens or that a particular encryption algorithm be used.

WS-Trust:: This specification deals primarily with how security tokens are to be issued, renewed, and validated. 
In general, the specification covers brokered trust relationships.

WS-Privacy:: This specification explains how services can state and enforce privacy policies. The specification also covers
 how a service can determine whether a requester intends to follow such policies.

WS-SecureConversation:: This specification covers, as the name indicates, secure web service conversations across different sites 
and, therefore, across different security contexts and trust domains. The specification focuses on how a security context is 
created and how security keys are derived and exchanged.

WS-Federation:: This specification addresses the challenge of managing security identities across different platforms and 
organizations. At the heart of the challenge is how to maintain a single, authenticated identity (for example, Alice&rsquo;s 
security identity) in a heterogeneous security environment.

WS-Authorization:: This specification covers the management of authorization data such as security tokens and underlying 
policies for granting access to secured resources.

WS-Security is often associated with federated
      security in the broad sense, which has the goal of cleanly separating web service logic from the high-level security 
concerns, in particular authentication/authorization, that challenge web service deployment. This separation of concerns is 
meant to ease collaboration across computer systems and trust realms.

Recall that SOAP-based web services are meant to be transport-neutral. Accordingly, SOAP-based services cannot depend simply on 
the reliable transport that HTTP and HTTPS provide, although most SOAP messages are transported over HTTP. HTTP and 
HTTPS rest on TCP/IP (Transmission Control Protocol/Internet Protocol), which supports reliable messaging. What if TCP/IP 
infrastructure is not available? The WS-ReliableMessaging specification addresses precisely the issue of delivering 
SOAP-based services over unreliable infrastructure.

A SOAP-based service can rely on the authentication/authorization support that a web container such as Tomcat or an 
application server such as Oracle WebLogic, JBoss, GlassFish, or WebSphere may provide. In this case, the service
outsources users/roles security to the service container. The WS-Security specifications are a guide to how
security in general can be handled from 'within' SOAP messaging. Accordingly, the WS-Security specifications 
address security issues as part of SOAP itself rather than as the part of the infrastructure 
that happens to be in place for a particular SOAP-based service. The goals of WS-Security are often summarized with 
the phrase _end-to-end_ security, which means that security matters are not delegated to the either the transport level 
('e.g.', HTTPS)
or a particular service container ('e.g.', Tomcat) but, rather, handled directly through an appropriate security API. 
A framework for end-to-end security needs to cover the 
situation in which a message is routed through intermediaries, each of which may have to process the message, before 
reaching the ultimate receiver; and end-to-end security thus focuses on message content rather than on the underlying transport
or the service container. As a result, SOAP messaging becomes considerably more complicated.


==== Securing a @WebService with WS-Security 

In order to focus squarely on WS-Security, the sample web service (see <<echo_service>>) is deliberately bare-bones.
Further, the +Endpoint+ publisher is used to host the service despite the fact that +Endpoint+ supports neither
wire-level security nor users/roles authentication and authorization. The very point of WS-Security is to provide security 
'within' SOAP messaging. The +Echo+ service focuses on how WS-Security supports user authentication in particular.

[[echo_service]]
.The bare-bones +Echo+ service.
====
----
package echoService;
import javax.jws.WebService;
import javax.jws.WebMethod;

@WebService
public class Echo {
    @WebMethod
    public String echo(String msg) { return "Echoing: " + msg; }
}
----
==== 
The +Echo+ class gives no hint of WS-Security, which is
delegated to the handler level, in this case to the message handler +ServiceHandler+. 
This separation of concerns means that, at the application level, the +Echo+ service looks like any other 
+@WebService+: the service is a collection of operations, in this case only the +echo+ method.

[[wss_publisher]]
.The +EchoPublisher+, which publishes the +Echo+ service.
====
----
package echoService;

import javax.xml.ws.Endpoint;
import javax.xml.ws.Binding;
import java.util.List;
import java.util.LinkedList;
import javax.xml.ws.handler.Handler;

public class EchoPublisher {
    public static void main(String[ ] args) {
        Endpoint endpoint = Endpoint.create(new Echo());    <1>
        Binding binding = endpoint.getBinding();            <2>
        List<Handler> hchain = new LinkedList<Handler>();   <3>
        hchain.add(new ServiceHandler());                   <4>
        binding.setHandlerChain(hchain);                    <5>
        endpoint.publish("http://localhost:7777/echo");     <6>
        System.out.println("http://localhost:7777/echo");
    }
}
----
====
The publisher (see <<wss_publisher>>) first sets an +Echo+ instance as the service endpoint (line 1)
and then gets the +Binding+ (line 2) in order to register a service-side handler (lines 3, 4, and 5).
The publisher finishes its work by publishing the service at the specified URL (line 6).

At this point, a shift to the client-side may be helpful because the client, too, has a handler; and
the service-side handler validates the information that the client-side handler puts into the
SOAP request message.
The client-side handler inserts a username and a password into the header of every SOAP request 
from the client. The service-side handler then verifies the identity of the user by using the password as
the credential that vouches for the identity. The client's request hits the +Echo+ service only if the
service-side handler is successful in its verification.

On the client-side and on the service-side, the labor is divided in similar ways. The client-side
message handler inserts the username and password into the outgoing SOAP message but relies upon the
+Prompter+, which in turn is a +CallbackHandler+, to prompt for and read in the username and password;
this +Callback+ handler obscures but, in this example, does not encrypt the password.
The client-side message handler also inserts other security information into the SOAP request message 
(see <<client_arch>>).
[[client_arch]]
.The client-side architecture in the +Echo+ service.
====
----
+---------------+  original  +---------------+  revised
| EchoClientWSS |----------->| ClientHandler |------------>to service
+---------------+  SOAP msg  +---------------+  SOAP msg
                                 /|\
                 +----------+     | 
                 | Prompter |-----+ 
                 +----------+
                  Get username/password
----
====
On the service-side, the message handler delegates verification to a +CallbackHandler+ of
its own, the +Verifier+ (see <<service_arch>>). The +Verifier+, in turn, relies on other +CallbackHandler+ instances
to extract the authentication information and to verify the sent username/password against
service-side copies of these. The architecture on the service-side thereby complements the architecture on the client-side.
[[service_arch]]
.The service-side architecture in the +Echo+ service.
====
----
             request    +----------------+ verified  +--------------+
from client------------>| ServiceHandler |---------->| Echo service |
             SOAP msg   +-------+--------+ SOAP msg  +--------------+
                                | 
                                |       +----------+
                                +------>| Verifier |
                                        +----------+
                                         Verify username/password
----
====
An examination of a familiar request/response exchange, starring from a client request through the service response, 
should cast light on the implementation details. 
The +EchoClientWSS+ client (see <<echo_client>>) relies on the usual 'wsimport'-generated artifacts (lines 1 and 2)
to get a +port+ reference (line 3), which is cast to the data type +BindingProvider+ (line 4) so that the client-side
+SOAPHandler+, an instance of the +ClientHandler+ class, can be linked dynamically with the client (line 5). With
this set-up in place, the +EchoClientWSS+ then makes a call against the +Echo+ service (line 6) and
prints the response for confirmation (line 7). All of the WS-Security code is relegated to the
+ClientHandler+.
[[echo_client]]
.The sample +EchoClientWSS+ against the +Echo+ service.
====
----
import java.util.List;
import java.util.LinkedList;
import javax.xml.ws.handler.Handler;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.Binding;
import echoClient.EchoService;                                       <1>
import echoClient.Echo;                                              <2>

public class EchoClientWSS {
    public static void main(String[ ] args) {
        try { 
	    List<Handler> hchain = new LinkedList<Handler>();
	    hchain.add(new ClientHandler());
            EchoService service = new EchoService();
            Echo port = service.getEchoPort();                       <3>
	    Binding binding = ((BindingProvider) port).getBinding(); <4>
	    binding.setHandlerChain(hchain);                         <5> 
            String response = port.echo("Goodbye, cruel world!");    <6>
            System.out.println("From Echo service: " + response);    <7>
        } 
	catch (Exception e) { throw new RuntimeExceptione(e); }
    }
}
----
====
The +ClientHandler+ receives, from the underlying SOAP libraries on the client-side, a SOAP message that
represents a call to the +echo+ operation in the +Echo+ service. This message is
passed to the +ClientHandler+ (see <<client_handler>>), which does the WS-Security
work. The result of this work impacts only the SOAP header, not the
SOAP body; hence, the +ClientHandler+ must be a +SOAPHandler+ 
in order to access the SOAP header.
[[client_handler]]
.The client-side +ClientHandler+, which uses the +Prompter+.
====
----
import java.util.Set;
import java.util.HashSet;
import javax.xml.namespace.QName;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;
import java.io.FileInputStream;
import java.io.File;
import com.sun.xml.wss.ProcessingContext;
import com.sun.xml.wss.SubjectAccessor;
import com.sun.xml.wss.XWSSProcessorFactory;
import com.sun.xml.wss.XWSSProcessor;

public class ClientHandler implements SOAPHandler<SOAPMessageContext> {
    private XWSSProcessor xwssClient;
    private boolean trace;

    public ClientHandler() {
	XWSSProcessorFactory fact = null;
	try {
	    fact = XWSSProcessorFactory.newInstance();                              <1>
	    FileInputStream config = new FileInputStream(new File("client.xml"));   <2>
	    xwssClient =                                                            <3>
		fact.createProcessorForSecurityConfiguration(config, new Prompter());
	    config.close();
	}
	catch (Exception e) { throw new RuntimeException(e); }
	trace = true; // set to true to enable message dumps
    }
    // Add a security header block
    public Set<QName> getHeaders() {                                                <4>
	String uri = "http://docs.oasis-open.org/wss/2004/01/" +
                     "oasis-200401-wss-wssecurity-secext-1.0.xsd";
	QName securityHdr = new QName(uri, "Security", "wsse");
	HashSet<QName> headers = new HashSet<QName>();
	headers.add(securityHdr);
	return headers;
    } 
    public boolean handleMessage(SOAPMessageContext msgCtx) {
        Boolean outbound = (Boolean)       
	    msgCtx.get (MessageContext.MESSAGE_OUTBOUND_PROPERTY);
        SOAPMessage msg = msgCtx.getMessage();
        if (outbound.booleanValue()) {
            ProcessingContext pCtx = null;
            try {
                pCtx = xwssClient.createProcessingContext(msg);                     <5>
                pCtx.setSOAPMessage(msg);                                           <6>
                SOAPMessage secureMsg = xwssClient.secureOutboundMessage(pCtx);     <7>
                msgCtx.setMessage(secureMsg);                                       <8>
		
		if (trace) dump("Outgoing message:", secureMsg);
            } 
	    catch (Exception e) { throw new RuntimeException(e); }
        } 
	return true;
    }
    public boolean handleFault(SOAPMessageContext msgCtx) { return true; }
    public void close(MessageContext msgCtx) { }
    private void dump(String msg, SOAPMessage soapMsg) {
	try {
	    System.out.println(msg);
	    soapMsg.writeTo(System.out);
	    System.out.println();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====
The +ClientHandler+ no-argument constructor creates an +XWSSProcessor+ (lines 1 through 3),
which generates the WS-Security artifacts that go into the revised SOAP message. Two arguments
are required for the creation of the +XWSSProcessor+: a file from which configuration
information can be read and a +CallbackHandler+, in this case the +Prompter+, that provides the
username and password. The configuration file is minimalist:
----
<xwss:SecurityConfiguration 
   xmlns:xwss="http://java.sun.com/xml/ns/xwss/config" 
   dumpMessages="true" >
    <xwss:UsernameToken digestPassword="false"/>
</xwss:SecurityConfiguration>
----
The code for the +Prompter+ (see <<prompter>>) is examined shortly. 

A SOAP message handler must define four methods: +getHeaders+, +handleMessage+, +handleFault+, and
+close+. Of the four methods, +getHeaders+ executes first. 
Earlier examples of SOAP handlers defined the +getHeaders+ method but never put this method
to work. In this case, the +getHeaders+ method (line 4) is put to work: the method adds an 
empty header block in the SOAP message:
----
<S:Header>
  <wsse:Security 
     xmlns:wsse="http://docs.oasis-open.org/ \
                 wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" 
     S:mustUnderstand="1">
  </wsse:Security>
</S:Header>
----
Although this header block is empty, it does contain the +mustUnderstand+ attribute, with a value of 
+1+ for 'true'; and WS-Security requires the attribute. Once the +getHeaders+ method has done its part,
the +handleMessage+ method then takes over to complete the work. This method creates a WS-Security
'processing context' (line 5) that is used to transform the current SOAP message (line 6), with its newly added
+wsse:Security+ header block, into a 'secured SOAP message' whose header contains the username and
password (lines 7 and 8). Behind the scenes, the +Prompter+ instance works with the +XWSSProcessor+ to provide
the required username and password. When the +handleMessage+ method exits, the SOAP message has been
transformed into something much larger.
The client-side SOAP message before the handler operates is small (see <<before_msg>>); but the
this message becomes significantly larger after the handler has done its work (see <<wss_request>>).

[[before_msg]]
.The SOAP request before the +ClientHandler+ transforms the message.
====
----
<?xml version="1.0" encoding="UTF-8"?>
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Body>
    <ns2:echo xmlns:ns2="http://echoService/">
      <arg0>Goodbye, cruel world!</arg0>
    </ns2:echo>
  </S:Body>
</S:Envelope>
----
====

[[wss_request]]
.The SOAP request after the +ClientHandler+ transforms the message.
====
----
<?xml version="1.0" encoding="UTF-8"?>
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Header>
    <wsse:Security 
       xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/\
                   oasis-200401-wss-wssecurity-secext-1.0.xsd" 
       S:mustUnderstand="1">
      <wsse:UsernameToken 
	 xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/\
                    oasis-200401-wss-wssecurity-utility-1.0.xsd" 
	 wsu:Id="XWSSGID-1365549760320-535388749">
	<wsse:Username>fred</wsse:Username>                                    <1>
	<wsse:Password                                                         <2>
	   Type="http://docs.oasis-open.org/wss/2004/01/\
                 oasis-200401-wss-username-token-profile-1.0#PasswordText">
	  ****
	</wsse:Password>
	<wsse:Nonce                                                            <3>
	   EncodingType="http://docs.oasis-open.org/wss/2004/01/\
                         oasis-200401-wss-soap-message-security-1.0#Base64Binary">
	  Q945eYMcu3NWuq90IjmNXjDy
	</wsse:Nonce>
	<wsu:Created>...</wsu:Created>
      </wsse:UsernameToken>
    </wsse:Security>
  </S:Header>
  <S:Body>
    <ns2:echo xmlns:ns2="http://echoService/">
      <arg0>Goodbye, cruel world!</arg0>
    </ns2:echo>
  </S:Body>
</S:Envelope>
----
====
The outgoing SOAP request now has, in the header, three items of security interest:

* The username, which is the client's identity (line 1).
* The obscured but not encrypted password, which is the credential that vouches for the username (line 2).
* A 'cryptographic nonce', a randomly generated value that is used just once 
in order to thwart so-called 'replay attacks' (line 3). Each time that the +EchoClientWSS+ sends a request
to the +Echo+ service, the username and password might be the same but the nonce would differ
from preceding ones; and the WSS libraries on the service-side validate the nonce.

The low-level work on the client-side falls to the +Prompter+ class (see <<prompter>>, which implements
the +CallbackHandler+ interface by defining the +handle+ method. The details are tedious but the
gist is clear: the +Prompter+, in a production environment, would prompt for a username and
password by using a +UsernameCallback+ (line 1) and a +PasswordCallback+, respectively. The 
+XWSSProcessor+, which has access to the two callbacks through the 'processing context', 
extracts the username and password so that these can be inserted into the outgoing SOAP message.
[[prompter]]
.The +Prompter+ callback handler, which helps the +ClientHandler+.
====
----
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import com.sun.xml.wss.impl.callback.PasswordCallback;
import com.sun.xml.wss.impl.callback.PasswordValidationCallback;
import com.sun.xml.wss.impl.callback.UsernameCallback;
import java.io.BufferedReader;
import java.io.InputStreamReader;

// For ease of testing, the username and password are 
// hard-wired in the handle method with local variables
// username and password. For production, the hard-wirings
// would be removed.
public class Prompter implements CallbackHandler {
    private String readLine() {
	String line = null;
	try {
	    line = new BufferedReader(new InputStreamReader(System.in)).readLine();
	}
	catch(Exception e) { throw new RuntimeException(e); }
	return line;
    }
    // Prompt for and read the username and the password.
    public void handle(Callback[ ] callbacks) {
	try {
	    for (int i = 0; i < callbacks.length; i++) {
		if (callbacks[i] instanceof UsernameCallback) {
		    UsernameCallback cb = (UsernameCallback) callbacks[i];   <1>
		    /* Disable for testing.
		    System.out.print("Username: ");
		    String username = readLine();
		    */
		    String username = "fred"; // hard-wire for testing
		    if (username != null) cb.setUsername(username);
		} 
		else if (callbacks[i] instanceof PasswordCallback) {
		    PasswordCallback cb = (PasswordCallback) callbacks[i];   <2>
		    /* Disable for testing
		    System.out.print("Password: ");
		    String password = readLine();
		    */
		    String password = "rockbed"; // hard-wire for testing
		    if (password != null) cb.setPassword(password);
		} 
	    }
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
}
----
====
On the client-side, the +XWSSProcessor+ could do could more than it does in this example. For instance,
the security processor could encrypt the blocks in the SOAP header, particularly the one with the password, 
and encrypt even the payload in the
SOAP body. However, this first look at WS-Security is focused on the architecture and flow of control; and these additional steps
would distract from that focus. It is now time to move over to the service-side.

On the service-side, the incoming SOAP message goes to the +ServiceHandler+ (see <<wss_handler>>), which
verifies the security header blocks that the +ClientHandler+ injects into the SOAP request. This handler
also pares down the incoming message (see <<wss_request>>) to an ordinary-looking SOAP request:
----
<S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Header/>
  <S:Body>
    <ns2:echo xmlns:ns2="http://echoService/">
      <arg0>Goodbye, cruel world!</arg0>
    </ns2:echo>
  </S:Body>
</S:Envelope>
----
This is almost the very request that the +EchoClientWSS+ generates 'before' the client-side handler 
goes into action. The one difference is that the pared-down, incoming message has a SOAP header--but an empty one.

[[wss_handler]]
.The service-side +ServiceHandler+.
====
----
package echoService;

import java.util.Set;
import java.util.HashSet;
import javax.xml.namespace.QName;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;
import java.io.ByteArrayInputStream;
import com.sun.xml.wss.ProcessingContext;
import com.sun.xml.wss.SubjectAccessor;
import com.sun.xml.wss.XWSSProcessorFactory;
import com.sun.xml.wss.XWSSProcessor;

public class ServiceHandler implements SOAPHandler<SOAPMessageContext> {
    private XWSSProcessor xwssServer = null;
    private boolean trace;

    public ServiceHandler() {
	XWSSProcessorFactory fact = null;
	try {
	    fact = XWSSProcessorFactory.newInstance();                     <1>
	    ByteArrayInputStream config = getConfig();                     <2>
	    xwssServer =                                                   <3>
		fact.createProcessorForSecurityConfiguration(config, 
                                                             new Verifier());
	}
	catch (Exception e) { throw new RuntimeException(e); }
	trace = true; // set to true to enable message dumps
    }
    public Set<QName> getHeaders() {                                       <4>
	String uri = "http://docs.oasis-open.org/wss/2004/01/" +
                     "oasis-200401-wss-wssecurity-secext-1.0.xsd";
	QName securityHdr = new QName(uri, "Security", "wsse");            <5>
	HashSet<QName> headers = new HashSet<QName>();
	headers.add(securityHdr);
	return headers;                                                    <6>
    } 
    public boolean handleMessage(SOAPMessageContext msgCtx) {
        Boolean outbound = (Boolean)       
	    msgCtx.get (MessageContext.MESSAGE_OUTBOUND_PROPERTY);
        SOAPMessage msg = msgCtx.getMessage();
	if (!outbound.booleanValue()) {                                           
	    // Validate the message.
            try{
                ProcessingContext pCtx =                                          
                   xwssServer.createProcessingContext(msg);
                pCtx.setSOAPMessage(msg);
                SOAPMessage verifiedMsg = 
                   xwssServer.verifyInboundMessage(pCtx);                  <7>
                msgCtx.setMessage(verifiedMsg);                            <8>
		if (trace) dump("Incoming message:", verifiedMsg);
            } 
            catch(Exception e) { throw new RuntimeException(e); }
        }
	return true;
    }   
    public boolean handleFault(SOAPMessageContext msgCtx) { return true; }
    public void close(MessageContext msgCtx) { }
    private void dump(String msg, SOAPMessage soapMsg) {
	try {
	    System.out.println(msg);
	    soapMsg.writeTo(System.out);
	    System.out.println();
	}
	catch(Exception e) { throw new RuntimeException(e); }
    }
    private ByteArrayInputStream getConfig() {                             <9>  
	String config = 
	    "<xwss:SecurityConfiguration " +
            "xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\" " +
            "dumpMessages=\"true\"><xwss:RequireUsernameToken " +
            "passwordDigestRequired=\"false\"/> " +
            "</xwss:SecurityConfiguration>";
	return new ByteArrayInputStream(config.getBytes());
    }    
}
----
====
The structure of the +ServiceHandler+ is very close to that of the +ClientHandler+. In the
+ServiceHandler+, the +handleMessage+ method is interested only in in-coming SOAP messages,
that is, requests. This handler has a +XWSSProcessor+ (lines 1 through 3) created from a hard-wired configuration
document (line 9) and associated with a +Verifier+ instance, a +Callbackhandler+ that extracts the
security information--the nonce, the username, and the password--from the SOAP header for verification. 
Once the SOAP request has been validated, the newly verified and simplified SOAP message is passed on to
the usual SOAP libraries, which transform the XML document into the appropriate Java objects so that the 
+Echo+ service can do its thing.

The +ServiceHandler+ also makes use of the +getHeaders+ method, which is particularly important with respect to
the SOAP response from the +EchoService+.
Recall that the +ServiceHandler+, like every handler, is inherently 
bi-directional. The +handleMessage+ method is coded so that this method ignores outgoing messages; but
the +getHeaders+ method injects, into the SOAP response from the +Echo+ service, a WS-Security
header with the +mustUnderstand+ attribute set to 'true'. In effect, the +ServiceHandler+ is demanding
that any receiver of the SOAP response, including the +EchoClientWSS+, stick by the WS-Security rules.
If the +getHeaders+ method simply returned +null+, a client-side exception would be thrown because the
incoming message would not be formatted according to WS-Security standards.

The service-side +Verifier+, like the client-side +Prompter+, is a +CallbackHandler+ delegated to
do grunt work. In a production environment, the +Verifier+ might check the username and
password against a database record; but here, for simplicity, these are hard-wired in the code.
The +Verifier+ also uses a +PlainTextPasswordVerifier+ because the password itself rather than
a hash value of the password were sent in the message.
[[verifier]]
.The service-side +Verifier+, a callback handler that helps the +ServiceHandler+.
====
----
package echoService;

import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import com.sun.xml.wss.impl.callback.PasswordCallback;
import com.sun.xml.wss.impl.callback.PasswordValidationCallback;
import com.sun.xml.wss.impl.callback.UsernameCallback;

// Verifier handles service-side callbacks for password validation.
public class Verifier implements CallbackHandler {
    // Username/password hard-coded for simplicity and clarity.
    private static final String _username = "fred";
    private static final String _password = "rockbed";

    // For password validation, set the validator to the inner class below.
    public void handle(Callback[ ] callbacks) throws UnsupportedCallbackException {
        for (int i = 0; i < callbacks.length; i++) {
            if (callbacks[i] instanceof PasswordValidationCallback) {
                PasswordValidationCallback cb = 
                    (PasswordValidationCallback) callbacks[i];
                if (cb.getRequest() instanceof 
		    PasswordValidationCallback.PlainTextPasswordRequest) 
                    cb.setValidator(new PlainTextPasswordVerifier());
            } 
	    else 
                throw new UnsupportedCallbackException(null, "Not needed");
        }
    }
    // Encapsulated validate method verifies the username/password.
    private class PlainTextPasswordVerifier
	implements PasswordValidationCallback.PasswordValidator {               <1>
	public boolean validate(PasswordValidationCallback.Request req)
	      throws PasswordValidationCallback.PasswordValidationException {
            PasswordValidationCallback.PlainTextPasswordRequest plain_pwd =
		(PasswordValidationCallback.PlainTextPasswordRequest) req;
            return_username.equals(plain_pwd.getUsername()) &&
		  _password.equals(plain_pwd.getPassword());
        }
    }
}
----
====
On a successful verification, the +Verifier+ validates +fred+ (the username) as an 'authenticated subject'
whose 'public credential' is the name +fred+ and whose 'private credential' is the password that vouches
for Fred's identity. 

The security illustrated in this sample could be ratcheted up to Mutual Challenge
Security (MCS) with digital certificates used on both sides for peer authentication. Further, the
contents of SOAP messages could be encrypted at the SOAP level, which would result in significantly larger
SOAP headers that specified all of the cryptographic information: encryption and message digest
algorithms, digital certificate formats, policies on confidentiality, encoding practices, specification
of which parts of the SOAP message are to be encrypted and even digitally signed, and so on. 

[[wss_jar]]
.Compiling and running the +Echo+ service and the +EchoClientWSS+. 
****
The WS-Security packages do not ship with core Java but can be downloaded, in a single JAR file, from
'download.java.net/maven/1/com.sun.xml.wss/jars'. The current version, 'xws-security-3.0.jar', is included
in the ZIP file with the sample code. The ZIP file also includes an executable JAR for the service and 
Ant script to compile and execute the
client.

* The 'EchoPublisher.jar' file can be used to launch the publisher:
+
----
% java -jar EchoPublisher.jar
----

* The script 'runClient.xml' can be used to compile and execute the +EchoClientWSS+:
+
----
% ant -f runClient.xml
----
+
The client-side message handler, like its service-side counterpart, has a +dump+ utility that can
be turned on or off in the code. With the +dump+ turned off, the output should be similar to:
+
----
Buildfile: runClient.xml
compile:
    [javac] Compiling 4 source files to /home/mkalin/jwsur2/ch6/wss
run:
     [java] com.sun.xml.wss.impl.filter.DumpFilter process
     [java] From Echo service: Echoing: Goodbye, cruel world!
----

The client uses 'wsimport'-generated artifacts, which are created in the usual way:
----
% wsimport -p echoClient -keep http://localhost:777/echo?wsdl
----
In a production environment, the +Prompter+ on the client-side would read the
username and password either from a data store or interactively, with the latter as
the default. It is easier to execute the client from the Ant script 'runClient.xml'
without any interaction; hence, for testing purposes, the username and password
are hard-wired in the code. For a more realistic experience, the
+Prompter+ sections currently commented out can be uncommented. In this case,
the +Prompter+ awaits client input. At the command-prompt, the input should be
----
fred
rockbed
----
These are the username and password that the +ServiceHandler+ will verify.

Also in a production environment, the +Verifier+ on the service-side would 
verify a received username/password pair against a data store such as database.
Again for simplicity, the +Verifier+ has the data hard-wired in the code. 
****

=== What's Next?

The examples so far have published RESTful and SOAP-based services with command-line utilities such as
+Endpoint+ and production-grade web servers such as Tomcat and Jetty.
At the production level, Tomcat or Jetty represent a lightweight option; and a 
Java Application Server (JAS) such as  IBM WebSphere, JBoss, GlassFish (the reference implementation), or
Oracle WebLogic (formerly BEA WebLogic) represents a heavier-weight option. In the early 2000s, the 
'lightweight Java movement', often associated with the Spring framework ('www.springsource.org'), emerged as
a reaction against the complexities of J2EE and the JASes used to deliver J2EE applications.
In the meantime, the move from J2EE to Java EE 5 and 6 has meant significant weight loss for JASes
because Java EE 5/6 offers a lightweight alternative to the earlier J2EE. The popular JASes now support
the updated Java EE specifications. Packaging and configuration
have become significantly easier with the new JAS versions, which have administrative and other utilities that
make the JAS an attractive option for deploying web services. For example, Java EE applications now can
express configuration information with annotations instead of with complicated XML documents; indeed, a Java EE
application, including a web service, officially can be deployed without any configuration document, although
the 'web.xml' remains the rule rather than the exception for both web sites and web services. The next chapter considers 
the publication of REST-style and SOAP-based services under GlassFish and TomcatEE, emphasizing the nuts-and-bolts
details of such software but also the trade-offs involved in using a JAS for deployment.





















































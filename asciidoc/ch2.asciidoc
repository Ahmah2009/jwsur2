[[jwsur_2nd_chapter_2]]
== RESTful Web Services: The Service Side

Java has options for implementing and publishing RESTful web services. 
On the publishing side, the choices range from very basic, command-line servers that are well suited for
development, testing, and even low-volume production;
through lightweight, Java-centric web servers such as Tomcat and Jetty; and up to full-blown Java 
application servers (JAS) such as GlassFish, JBoss, Oracle WebLogic, and WebSphere. This chapter introduces
publication options in the first two categories and Chapter 7 covers JAS publication.

There is also variety among the APIs and their implementations for 
RESTful services. Here is the list of APIs covered in this chapter:

* The +HttpServlet+ and JSP APIs, introduced briefly in Chapter 1 and examined more thoroughly in this chapter.

* The JAX-RS (Java API for XML-Restful Services) API.

* The third-party Restlet API, which is very similar to JAX-RS in look-and-feel.

* The JAX-WS (Java API for XML-Web Services) API, the +@WebServiceProvider+ interface in particular.

For the most part, the API used to implement the web service does not constrain how this service can be published. 
The exception is the servlet API, as servlets need to be
deployed in a servlet container such as Tomcat's Catalina or Jetty. (Jetty is the name of both the web server
and its servlet container.) There are shortcuts for
publishing JAX-RS and JAX-WS services but these, too, can be published with Tomcat or Jetty; and the same goes for 
Restlet services.

The decision about how to publish a service depends on many 
factors. For example, if service deployment requires wire-level security in the form of HTTPS together with
user authentication/authorization, then a web server such as Tomcat or Jetty is the obvious starting point. If the published
web services are to interact with EJBs, which are deployed in an EJB container, then a souped-up web server such as TomEE (Tomcat
with EE support) or a full JAS is a better choice. In development, simpler command-line options such as +Endpoint+, introduced 
later, are attractive. 

=== A RESTful Service as an +HttpServlet+
Chapter 1 has a sample RESTful service implemented as a JSP script and two back-end classes, +Prediction+ and
+Predictions+. The JSP-based service supported only GET requests. This section revises the example to provide an
+HttpServlet+ implementation with support for the four CRUD operations:

* A new +Prediction+ can be created with a POST request whose body should have two key/value pairs: a +who+ key whose value
is the name of the predictor and a +what+ key whose value is the prediction. 

* The +Prediction+ objects can be read one at a time or all together with a GET request.
If the GET request has a query string with an +id+ key, then the corresponding +Prediction+, if any, is returned.
If the GET request has no query string, then the full list of +Predictions+ is returned. On any GET request,
the client can indicate a preference for JSON rather than the default XML format.

* A specified +Prediction+ can be updated with a PUT request that provides the identifier for the 
+Prediction+ and either
a new +who+ or a new +what+. 

* A specified +Prediction+ can be deleted.

The earlier JSP service is 'predictions' and the servlet revision is 'predictions2'.
The structure of 'predictions2' differs from that of 'predictions' in several ways.
The most obvious change is that
an explicit +HttpServlet+ subclass replaces the JSP script. There are also changes in the details of the +Prediction+ and
+Predictions+ classes, which still provide back-end support. The details follow.

.The Jetty web server
[options="header"]
****
The Jetty web server is available at _jetty.codehaus.org_ as a ZIP file. Let the install directory be 'JETTY_HOME'.
Its subdirectories are similar to those of 'TOMCAT_HOME'. For
example, there is a _webapps_ subdirectory into which WAR files are deployed; a _logs_ subdirectory; a _lib_ subdirectory with various 
JAR files, including a versioned counterpart
of Tomcat's _servlet-api.jar_; and others. Jetty ships with an executable JAR file _start.jar_; hence,
Jetty can be started at the command line with the command
----
% java -jar start.jar
----
In general, a WAR file deployable under Tomcat is deployable under Jetty and vice-versa; my examples can be
deployed under either. 
The Jetty web
server, like Tomcat, listens by default on port 8080. Jetty is a first-rate web server that
has a lighter feel than does Tomcat; and Jetty's simplicity makes embedding this web server in other
systems relatively straightforward. It is hard to make a bad choice between Tomcat and
Jetty.
****
==== Implementation Details

[[Ex1]]
.The back-end +Prediction+ class.
====
----
package predictions2;
import java.io.Serializable;

public class Prediction implements Serializable, Comparable<Prediction> {
    private String who;   // person
    private String what;  // his/her prediction
    private int    id;    // identifier used as lookup-key

    public Prediction() { }
    public void setWho(String who) { this.who = who; }
    public String getWho() { return this.who; }
    public void setWhat(String what) { this.what = what; }
    public String getWhat() { return this.what; }
    public void setId(int id) {	this.id = id; }     <1>
    public int getId() { return this.id; }
    public int compareTo(Prediction other) { return this.id - other.id; }	
}
----
====

There are small but important changes to the +Prediction+ class (see <<Ex1>>), which now includes an +id+ property (line 1), an
an auto-incremented integer that the service sets when a +Prediction+ object is constructed. The +id+
property is used to sort the +Prediction+ objects, which explains why the +Prediction+ class implements
the interface +Comparable+ used in sorting:
----
public class Prediction implements Serializable, Comparable<Prediction> {
----
Implementing the +Comparable+ interface requires that the +compareTo+ method be defined:
----
public int compareTo(Prediction other) {
    return this.id - other.id;
}
----
The +compareTo+ method uses the comparison semantics of the age-old C function +qsort+. For illustration, 
suppose that +this.id+ in the code above is 7 and +other.id+ is 12, where +this+ is the current object
and +other+ is another +Prediction+ object against which the current +Prediction+ object is being
compared. The difference 7 - 12 is the negative integer -5, which signals that the current +Prediction+
'precedes' the other +Prediction+ because 7 precedes 12. In general,

* A returned negative integer signals that the current object 'precedes' the other object.
* A returned positive integer signals that the current object 'succeeds' the other object.
* A returned zero signals that the two objects are to be treated as equals with respect to sorting.

The implementation of the +compareTo+ method means the sort is to be in ascending order. Were the +return+
statement changed to
----
return other.id - this.id;
----
the sort would be in descending order. The +Prediction+ objects are sorted for ease of confirming that
the CRUD operations work correctly. For example, if a +Prediction+ object is created with the
appropriate POST request, then the newly created +Prediction+ occurs at the _end_ of the 
+Prediction+ list. In similar fashion, it is easy to confirm that the other destructive CRUD
operations--PUT (update) and DELETE--work as intended by inspecting the resulting sorted list of +Prediction+
objects.

A +Prediction+ is still +Serializable+ so that a list of these can be serialized into
XML using the +XmlEncoder+ utility. An added feature is that this list also can be formatted in 
JSON if the client so requests.

[[Ex2]]
.The back-end +Predictions+ class.
====
-----
package predictions2;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
import java.beans.XMLEncoder; // simple and effective
import javax.servlet.ServletContext;

public class Predictions {
    private ConcurrentMap<Integer, Prediction> predictions;
    private ServletContext sctx;
    private AtomicInteger mapKey;

    public Predictions() { 
	predictions = new ConcurrentHashMap<Integer, Prediction>();
	mapKey = new AtomicInteger();
    }
    public void setServletContext(ServletContext sctx) {
	this.sctx = sctx;
    }
    public ServletContext getServletContext() { return this.sctx; }
    public void setMap(ConcurrentMap<String, Prediction> predictions) { 
	// no-op for now
    } 
    public ConcurrentMap<Integer, Prediction> getMap() {
	// Has the ServletContext been set?
	if (getServletContext() == null) return null;      
	// Have the data been read already?
	if (predictions.size() < 1) populate(); 
	return this.predictions;
    }
    public String toXML(Object obj) {
	String xml = null;
	try {
	    ByteArrayOutputStream out = new ByteArrayOutputStream();
	    XMLEncoder encoder = new XMLEncoder(out);
	    encoder.writeObject(obj); // serialize to XML
	    encoder.close();
	    xml = out.toString(); // stringify
	}
	catch(Exception e) { }
	return xml;
    }
    public int addPrediction(Prediction p) {
	int id = mapKey.incrementAndGet();
	p.setId(id);
	predictions.put(id, p);
	return id;
    }
    private void populate() {
	String filename = "/WEB-INF/data/predictions.db";
	InputStream in = sctx.getResourceAsStream(filename);
	// Read the data into the array of Predictions. 
	if (in != null) {
	    try {
		InputStreamReader isr = new InputStreamReader(in);
		BufferedReader reader = new BufferedReader(isr);
		int i = 0;
		String record = null;
		while ((record = reader.readLine()) != null) {
		    String[] parts = record.split("!");
		    Prediction p = new Prediction();
		    p.setWho(parts[0]);
		    p.setWhat(parts[1]);
		    addPrediction(p);
		}
	    }
	    catch (IOException e) { }
	}
    }
}
----
====

The utility class +Predictions+ has changed as well (see <<Ex2>>). As explained in the
sidebar about thread synchronization and servlets, the +Map+ of the earlier JSP
implementation gives way to a +ConcurrentMap+ so that the code can avoid explicit
locks in the form of +synchronized+ blocks. The +Predictions+ class now has an +addPrediction+ method
----
public int addPrediction(Prediction p) {
   int id = mapKey.incrementAndGet(); // AtomicInteger
   p.setId(id);
   predictions.put(id, p);
   return id;
}
----
to support POST requests. The servlet's +doPost+ method creates a new +Prediction+, sets
the +who+ and +what+ properties with data from the POST message's body, and then
invokes +addPrediction+ to add the newly constructed +Prediction+ to the map whose
object reference is +predictions+. The +mapKey+, a thread-safe +AtomicInteger+, gets incremented
with each new +Prediction+ and behaves like an auto-incremented integer in a database system; the
+mapKey+ value becomes the +id+ of each newly constructed 
+Prediction+, thereby ensuring that each +Prediction+ has a unique +id+.

The remaining +Predictions+ code is slightly changed, if at all, from the earlier version. 
For example, the +populate+ method is modified slightly to give each newly constructed
+Prediction+ an +id+; but the method's main job is still to read data from the text
file encapsulated in the WAR, data that contain the +who+ and the +what+ of each
+Prediction+.

The +PredictionServlet+ (see <<Ex3>>) replaces the JSP script and differs from this
script in supporting all of the CRUD operations. The servlet offers new functionality
by allowing the client to request JSON format for the response of any GET request. Further,
the earlier JSP script interpreted GET to mean 'read all' but the servlet allows the client to
request one specified +Prediction+ or all of them. The code for the +PredictionServlet+ is long enough 
that it makes sense to isolate important code segments for clarification.

[[Ex3]]
.The +PredictionsServlet+ with full support for the CRUD operations.
====
----
package predictions2;

import java.util.concurrent.ConcurrentMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.ws.http.HTTPException;
import java.util.Arrays;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.beans.XMLEncoder;
import org.json.JSONObject;
import org.json.XML;

public class PredictionsServlet extends HttpServlet {
    private Predictions predictions; // back-end bean

    // Executed when servlet is first loaded into container.
    // Create a Predictions object and set its servletContext
    // property so that the object can do I/O.
    @Override
    public void init() {
	predictions = new Predictions();
	predictions.setServletContext(this.getServletContext());
    }
    // GET /predictions2
    // GET /predictions2?id=1
    // If the HTTP Accept header is set to application/json (or an equivalent
    // such as text/x-json), the response is JSON and XML otherwise.
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
	String param = request.getParameter("id");
	Integer key = (param == null) ? null : new Integer(param.trim());
	// Check user preference for XML or JSON by inspecting
	// the HTTP headers for the Accept key.
	boolean json = false;
	String accept = request.getHeader("accept");
	if (accept != null && accept.contains("json")) json = true;
        // If no query string, assume client wants the full list.
        if (key == null) {
	    ConcurrentMap<Integer, Prediction> map = predictions.getMap();
	    // Sort the map's values for readability.
	    Object[] list = map.values().toArray();
	    Arrays.sort(list);
	    String xml = predictions.toXML(list);
	    sendResponse(response, xml, json);
	}
	// Otherwise, return the specified Prediction.
	else {
	    Prediction pred = predictions.getMap().get(key);

	    if (pred == null) { // no such Prediction
		String msg = key + " does not map to a prediction.\n";
		sendResponse(response, predictions.toXML(msg), false);
	    }
	    else { // requested Prediction found
		sendResponse(response, predictions.toXML(pred), json);
	    }
	}
    }
    // POST /predictions2
    // HTTP body should contain two keys, one for the predictor ("who") and
    // another for the prediction ("what").
    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) {
	String who = request.getParameter("who");
	String what = request.getParameter("what");
	// Are the data to create a new prediction present?
        if (who == null || what == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
	// Create a Prediction.
	Prediction p = new Prediction();
	p.setWho(who);
	p.setWhat(what);
	// Save the ID of the newly created Prediction.
	int id = predictions.addPrediction(p);
	// Generate the confirmation message.
	String msg = "Prediction " + id + " created.\n";
	sendResponse(response, predictions.toXML(msg), false);
    }
    // PUT /predictions
    // HTTP body should contain at least two keys: the prediction's id
    // and either who or what.
    @Override
    public void doPut(HttpServletRequest request, HttpServletResponse response) {
	/* A workaround is necessary for a PUT request because neither Tomcat
	   nor Jetty generates a workable parameter map for this HTTP verb. */
	String key = null;
	String rest = null;
	boolean who = false;
	/* Let the hack begin. */
	try {
	    BufferedReader br = 
		new BufferedReader(new InputStreamReader(request.getInputStream()));
	    String data = br.readLine();
	    /* To simplify the hack, assume that the PUT request has exactly
	       two parameters: the id and either who or what. Assume, further,
	       that the id comes first. From the client side, a hash character
	       # separates the id and the who/what, e.g.,
	          id=33#who=Homer Allision
	    */
	    String[] args = data.split("#");      // id in args[0], rest in args[1]
	    String[] parts1 = args[0].split("="); // id = parts1[1]
	    key = parts1[1];
	    String[] parts2 = args[1].split("="); // parts2[0] is key 
	    if (parts2[0].contains("who")) who = true;
	    rest = parts2[1];
	}
	catch(Exception e) { 
	    throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
	}
	// If no key, then the request is ill formed.
	if (key == null)
	    throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
	// Look up the specified prediction.
	Prediction p = predictions.getMap().get(new Integer(key.trim()));
	if (p == null) { // not found? 
	    String msg = key + " does not map to a Prediction.\n";
	    sendResponse(response, predictions.toXML(msg), false);
	}
	else { // found
	    if (rest == null) {
		throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
	    }
	    // Do the editing.
	    else {
		if (who) p.setWho(rest);
		else p.setWhat(rest);
		String msg = "Prediction " + key + " has been edited.\n";
		sendResponse(response, predictions.toXML(msg), false);
	    }
	}
    }
    // DELETE /predictions2?id=1
    @Override
    public void doDelete(HttpServletRequest request, HttpServletResponse response) {
        String param = request.getParameter("id");
	Integer key = (param == null) ? null : new Integer(param.trim());
        // Only one Prediction can be deleted at a time.
        if (key == null)
            throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
        try {
	    predictions.getMap().remove(key);
	    String msg = "Prediction " + key + " removed.\n";
	    sendResponse(response, predictions.toXML(msg), false);
        }
        catch(Exception e) {
            throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
    // Method Not Allowed
    @Override
    public void doTrace(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Method Not Allowed
    @Override
    public void doHead(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Method Not Allowed
    @Override
    public void doOptions(HttpServletRequest request, HttpServletResponse response) {
        throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
    // Send the response payload to the client.
    private void sendResponse(HttpServletResponse response, String payload, boolean json) {
	try {
	    // Convert to JSON?
	    if (json) {
		JSONObject jobt = XML.toJSONObject(payload);
		payload = jobt.toString(3); // 3 is indentation level for nice look
	    }
	    OutputStream out = response.getOutputStream();
	    out.write(payload.getBytes());
	    out.flush();
	}
	catch(Exception e) {
	    throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
	}
    }
}     
-----
====
Recall that each of the 'do'-methods in an +HttpServlet+ takes the same arguments: an 
+HttpServletRequest+, a map that contains the information encapsulated in the HTTP request, and an
+HttpServletRespose+, which encapsulates an output stream for communicating back with the client.
Here is the start of +doGet+ method:
----
public void doGet(HttpServletRequest request, HttpServletResponse response) {
----
The +HttpServletRequest+ has a +getParameter+ method that expects a string argument, a
key into the request map, and returns either +null+ if there is no such key or the 
key's value as a string otherwise. The +getParameter+ method is agnostic about whether the
key/value pairs are in the body of, for example, a POST request or in the
query string of, for example, a GET request. The method works the same in either case.
There is also a +getParameters+ method that returns the parameter collection as a whole.

In the case of +PredictionsServlet+, the +doGet+ method needs to answer two questions
about the incoming request:

* Does the body-less GET request include a key named +id+ whose value identifies a particular +Prediction+?
+
If the +id+ is present, the +doGet+ method uses the +id+ to perform a lookup against the +ConcurrentMap+, which
holds references to all of the +Prediction+ objects. If the lookup fails, then the +doGet+ method
method returns an XML message to that effect:
+
----
Prediction pred = predictions.getMap().get(key);
if (pred == null) { // no such Prediction
    String msg = key + " does not map to a prediction.\n";
    sendResponse(response, predictions.toXML(msg), false);
}
----
+
The last argument to the +sendResponse+ method indicates whether JSON rather than XML should be
sent back to the client. In this example, XML is returned because the JSON flag is +false+.
If the +id+ parameter is not present, the +doGet+ method assumes that the client wants to read a 
list of all +Predictions+ and returns this list in either JSON or XML format:
+
----
ConcurrentMap<String, Prediction> map = predictions.getMap();
// Sort the map's values for readability.
Object[] list = map.values().toArray();
Arrays.sort(list); // other ways to sort shown later
...
----
* Does the client prefer JSON over XML?
+
In an HTTP request, the requester can express a preference for the MIME type of the
returned representation. For example, the header element
+
----
Accept: text/html
----
+
expresses a preference for the MIME type +text/html+. Among the MIME combinations is
+application/json+ that, together with several variants, expresses a preference for JSON. The +doGet+
method therefore uses the +getHeader+ method in the +HttpServletRequest+ to inspect the HTTP header 
element with +Accept+ as its key:
+
----	
boolean json = false;
String accept = request.getHeader("accept");
if (accept != null && accept.contains("json")) json = true;
----	
+
This check determines whether the client prefers JSON over XML. (Recall that HTTP is case insensitive; hence,
the key could be +Accept+, +accept+, +ACCEPT+, and so on.) The +json+ flag is the third argument
to the +sendResponse+ method:
+
----
private void sendResponse(HttpServletResponse res, 
                          String payload, 
                          boolean json) { // json format?
   try {
      if (json) {
        JSONObject jobt = XML.toJSONObject(payload);
        payload = jobt.toString(3); // 3 is indentation level 
      }
      OutputStream out = res.getOutputStream();
      out.write(payload.getBytes());
      out.flush();
   }
   catch(Exception e) {
      throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
   }
}
----
+
Details about generating the JSON are considered next.

The deployed WAR file 'predictions2.war' includes a lightweight, third-party JSON library in the
JAR file 'json.jar' (see 'www.json.org/java'). If the client prefers JSON over XML, then the response +payload+
is converted to JSON. If anything goes awry in sending the response back to the client,
the servlet throws an +HTTPException+, which in this case generates a response with
HTTP status code 500 for 'Internal Server Error', a catch-all for request-processing errors on 
the server.

The +doPost+ and +doPut+ operations are similar in that +doPost+ creates an altogether new +Prediction+
using data in the body of a POST request, whereas +doPut+ updates an existing +Prediction+ from
data in the body of a PUT request. The main difference is that a PUT request needs to include
the +id+ of the +Prediction+ to be updated, whereas a POST request creates a new 
+Prediction+ and then sets its +id+ to an auto-incremented integer. In implementation, however,
+doPost+ and +doPut+ differ significantly because the servlet container's run-time does not generate a 
usable parameter map, the +HttpServletRequest+, on a PUT request; on a POST request, the 
map is usable. (This is the case in both Tomcat and Jetty.) As a result, the +doPut+ implementation
extracts the data directly from an input stream.

To begin, here is the +doPost+ implementation, without the comments:
----
public void doPost(HttpServletRequest request, HttpServletResponse response) {
   String who = request.getParameter("who");                           <1>
   String what = request.getParameter("what");                         <2>
   if (who == null || what == null)
      throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
   Prediction p = new Prediction();                                    <3>
   p.setWho(who);                                                      <4>
   p.setWhat(what);                                                    <5>
   int id = predictions.addPrediction(p);                              <6>
   String msg = "Prediction " + id + " created.\n";
   sendResponse(response, predictions.toXML(msg), false);              <7>
}
----
The two calls to the +getParameter+ method extract the required data (lines 1 and 2). 
A new +Prediction+
is then constructed, its +who+ and +what+ properties are set, and a confirmation is
generated for the client (lines 3 through 7).

In the +doPut+ method, the +getParameter+ method does not work correctly because neither
Tomcat nor Jetty builds a usable parameter map in +HttpServletRequest+.
The workaround is to access directly the input stream encapsulated in the 
request structure:
----
BufferedReader br = 
  new BufferedReader(new InputStreamReader(request.getInputStream()));
String data = br.readLine();
...
----
The next step is to extract the +data+ from this stream. The code, though not pretty, gets
the job done. The point of interest is that the +HttpServletRequest+ does provide 
access to the underlying input stream from which the PUT data can be extracted. Using
the +getParameter+ method is, of course, much easier.

The body of +doDelete+ method has simple logic:
----
String key = request.getParameter("id");
if (key == null)	
   throw new HTTPException(HttpServletResponse.SC_BAD_REQUEST);
try {
   predictions.getMap().remove(key);                         <1>
   String msg = "Prediction " + key + " removed.\n";
   sendResponse(response, predictions.toXML(msg), false);
}
catch(Exception e) {
   throw new HTTPException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
}
----
If the +id+ for the +Prediction+ can be extracted from the parameter map, the
prediction is effectively removed from the collection by removing the lookup key
from the +ConcurrentMap+ (line 1).

The +PredictionsServlet+ also implements three other 'do'-methods and all in the same way. Here, for example,
is the implementation of +doHead+:
----
public void doHead(HttpServletRequest request, HttpServletResponse response) {
     throw new HTTPException(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
}
----
Throwing the +HTTPException+ signals to the client that the underlying HTTP
verb, in this case +HEAD+, is not supported. The numeric status code for
+Method Not Allowed+ is 405. The web service designer thus has an idiomatic 
way to reject particular HTTP verbs: throw a +Method Not Allowed+ exception.

.Servlets and thread synchronization
[options="header"]
****
A web server such as Tomcat can instantiate arbitrarily many instances of a servlet, although the number is
typically small, for example, 1 through 4. The web server 
itself makes the decision. For example, Tomcat by default loads one instance of a servlet to begin but may load
more instances thereafter if simultaneous requests for the servlet are sufficient in number. Whatever the
number of servlet instances, the number of client requests per instance is typically greater--and significantly
so. For example, one servlet instance might handle tens of simultaneous requests. For reasons of efficiency, a web server
such as Tomcat keeps the number of servlet instances as small as possible while supporting reasonable 
response time per request. A high-volume web server might have to handle hundreds of
requests per second, distributed across many servlet instances; and one servlet instance per request is out of the question in 
this real-world scenario. The upshot is that Java-based web servers rely on multithreading to handle simultaneous requests.
The model is sometimes described as 'one thread per request'.

For reasons of performance, a web server such as Tomcat creates a thread pool at startup; as requests come
in, each is dispatched to a thread from the pool, which then handles the request and returns to the pool
afterwards. The pooling amortizes the relatively
expensive cost of thread-creation across the web server's uptime. There are, of course, various ways to
measure how well a web server is performing. One critical measure is response time. For example, a web site
might require that the upper bound on response time for 90% of all requests be, say, 10 'ms'.

The one-thread-per-request model poses challenges for the servlet/JSP programmer, in particular the
challenge of thread coordination or _synchronization_. For example, if there are a dozen
concurrent requests against the +PredictionsServlet+ of the 'predictions2' service, then each of
these requests is implemented as a thread that executes the appropriate 'do'-method in the servlet.
On a multi-core server (that is, a server with more than CPU), one thread could be
executing the +doGet+ method at exactly the same time as another is executing the +doPut+ method: the 
result is a simultaneous 'read' and 'write' operation on the same resource. There are various 
other concurrency scenarios, any one of which requires proper thread synchronization to avoid so-called
'race conditions'; and the programmer 
rather than the servlet container must ensure that these scenarios remain thread safe.

A servlet container such as Catalina or Jetty, in contrast to an EJB container, does 'not' ensure
thread safety; instead, the programmer is responsible for proper thread coordination. A servlet must be
programmed so that, for example, two requests--each executing as a separate thread--cannot simultaneously 
update the same resource such as a +Prediction+. In earlier Java versions, the mainstay of thread coordination was the 
+synchronized+ block; later versions of Java have added higher-level constructs, many in the
+java.util.concurrent+ package, for managing 
thread-based concurrency. 

The 'predictions2' service uses a thread-safe +ConcurrentMap+ to coordinate
simultaneous thread access to the +Predictions+.
A +ConcurrentMap+ segments its entries; as a result, the map
usually needs to lock only a portion of its total entries to enforce synchronization. In any case, the
+ConcurrentMap+ synchronizes access to the +Predictions+ collection and does so in an
efficient manner. The +java.util.concurrent+ package offers other thread-safe data structures; a 
later example in this chapter, the JAX-RS 'predictions3' service, uses one of these data structures, 
the thread-safe +CopyOnWriteArrayList+.
Finally, the 'predictions2' service uses an integer counter to set the +id+ for each newly created prediction.
The counter is implemented with a thread-safe +AtomicInteger+.
****

==== Sample Client Calls against the 'predictions2' Service

Example 2-4 is a list of 'curl' calls against the service. These calls serve as a very preliminary test
of the service. Two semi-colons introduce comments that explain the purpose of
the 'curl' call. Recall that the Ant script can be used to deploy the 'predictions2' service under Tomcat:
----
% ant -Dwar.name=predictions2 deploy
----
[[Ex4]]
.A suite of 'curl' calls against the 'predictions' RESTful service.
====
----
;; GET all predictions (XML response)
% curl localhost:8080/predictions2/   ;; curl --request GET...
;; GET a specified saying (XML response)
% curl localhost:8080/predictions2?id=31
;; GET all predictions (JSON response)
% curl --header "Accept: application/json" localhost:8080/predictions2/
;; GET a specified saying (JSON response)
% curl --header "Accept: application/json" localhost:8080/predictions2?id=31
;; POST a new saying
% curl --request POST --data "who=TSEliot& \
           what=This is the way the world ends" localhost:8080/predictions2/
;; GET all predictions to confirm the POST (new saying is at the end)
% curl localhost:8080/predictions2/
;; PUT new data into an existing saying
% curl --request PUT --data "id=33#what=This is an update" localhost:8080/predictions2/
;; GET all predictions to confirm the PUT (edited saying is at the end)
% curl localhost:8080/predictions2/
;; DELETE a specificed saying
% curl --request DELETE localhost:8080/predictions2?id=33
;; GET all predictions to confirm the DELETE
% curl localhost:8080/predictions2/
----
====
The XML responses from the 'predictions2' service are formatted exactly the same as in the
original version, which did not support JSON responses. Here is a sample JSON response from a GET 
request on the +Prediction+ with +id+ 31:
----
{"java": {"class": "java.beans.XMLDecoder", "object": {"void": [
         {"int": 31, "property": "id"},
         {"string": "Balanced clear-thinking utilisation 
                     will expedite collaborative initiatives.",
          "property": "what"}, {"string": "Deven Blanda", "property": "who"}],
 "class": "predictions2.Prediction"}, 
 "version": "1.7.0_17"}}
----
=== A RESTful Web Service as a JAX-RS Resource 
The servlet API, the grizzled workhorse for producing Java web sites, is still nimble enough to support RESTful web services as well.
There are more recent APIs, among them JAX-RS (Java API for XML-RESTful Web Services). JAX-RS relies upon Java annotations to 
advertise the RESTful role that a class and its encapsulated methods play. Jersey ('jersey-java.net') is the 
'reference implementation' (RI) of JAX-RS. RESTEasy, a JBoss project ('www.jboss.org/resteasy'), 
Apache Wink ('incubator.apache.org/wink/'), and Apache CXF ('cxf.apache.org') are other implementations. 
JAX-RS has APIs for programming RESTful services and clients
against such services; and the two APIs can be used independently. This section focuses on the service-side API. The first
JAX-RS example supports only GET requests but the second JAX-RS example supports all of the CRUD operations.

==== A First JAX-RS Web Service using Jersey
JAX-RS web services are 'resources'
that can be published with the Tomcat and Jetty web servers (see the sidebar). The first example has
one resource, the class +Adages+, and two supporting Java classes: the 
deployment class +RestfulApplication+ and the POJO class +Adage+. Exactly how these three classes
interact is covered next.

The +RestfulAdage+ class (see <<Ex5>>) extends the
JAX-RS +Application+ class (line 2), which implements a +getClasses+ method that enumerates the individual resources
deployed in the WAR file (line 3). In this example, there is but one such resource, +Adages+, but there
could be arbitrarily many (line 4).
[[Ex5]]
.The JAX-RS +Application+ subclass that lists +Adages.class+ as a resource.
====
----
package adages;

import java.util.Set;
import java.util.HashSet;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/resourcesA")                        <1>
public class RestfulAdage extends Application {        <2>
    @Override
    public Set<Class<?>> getClasses() {                <3>
	Set<Class<?>> set = new HashSet<Class<?>>();
        set.add(Adages.class);                         <4>
        return set;
    }
}
----
====
Recall that any web site or web service deployed under Tomcat has a URI that begins with the
name of the deployed WAR file. In the +RestfulAdage+ class, the annotation +ApplicationPath+  (line 1)
spells out how the URI continues. For example, assuming that the deployed WAR file is named
'adages.war', the +ApplicationPath+ annotation indicates that the URI part of the URL
continues with 'resourcesA':
----
http://localhost:8080/adages/resourcesA
----
The next part is tricky so the low-level details are explained in a sidebar. At issue is how the 
programmer-defined +RestfulAdage+ class interacts with the Jersey JAX-RS implementation under a Tomcat
deployment. For context, 
recall that the +getClasses+ method (line 3), a callback invoked when the +RestfulAdage+ instance is loaded into the
servlet container, specifies the JAX-RS resources available in the WAR file. Once again, there
is but a single resource +Adages+ (see <<Ex7>>) in the example. 
The 
+RestfulAdage+ class is a Jersey +Application+ because the programmer-defined +RestfulAdage+ class extends the
JAX-RS +Application+ class.
If multiple JAX-RS resources were to be
made available in the deployed WAR file, then the class name of each would occur in a
+set.add+ call in +RestfulAdage+. In the current example, there is only
----
set.add(Adages.class);
----
because +Adages+ is the only resource.

.Publishing JAX-RS resources with a Java Application
[options="header"]
****
A later sidebar explains how a JAX-RS resource can be published with production-grade web server such
as Tomcat; the sidebar also explains how the JAX-RS libraries can be downloaded. For now, the
point of interest is that the Jersey implementation of JAX-RS offers other ways to publish, which may be better
suited for development. Here is a standalone Java application that publishes the 'adages' service:
----
package adages;

import java.net.InetSocketAddress;
import javax.ws.rs.ext.RuntimeDelegate;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

public class AdagesPublisher{
    private static final int port = 9876;                                  <1>
    private static final String uri = "/resourcesA/";                      <2>
    private static final String url = "http://localhost:" + port + uri;
    public static void main(String[ ] args) {
	new AdagesPublisher().publish();
    }
    private void publish() {
	HttpServer server = getServer();
	HttpHandler requestHandler =
	    RuntimeDelegate.getInstance().createEndpoint(new RestfulAdage(), 
                                                         HttpHandler.class);
	server.createContext(uri, requestHandler); 
	server.start();
	msg(server);
    }
    private HttpServer getServer() {
	HttpServer server = null;
	int backlog = 8;
	try {
	    server = 
              HttpServer.create(new InetSocketAddress("localhost", port), 
                                backlog);
	}
	catch(Exception e) { throw new RuntimeException(e); }
	return server;
    }

    private void msg(HttpServer server) {
	String out = "Publishing RestfulAdage on " + url + 
                                                 ". Hit any key to stop.";
	System.out.println(out);
	try {
	    System.in.read();
	} catch(Exception e) { }
	server.stop(0); // normal termination
    }
}
----
For convenience, this +AdagesPublisher+ class is in the +adages+ package together with
+Adage+, +Adages+, and +RestfulAdage+. To compile, the JAR file 'jersey-core.jar' must be on the
classpath; to run, that file and 'jersey-server.jar' must be on the classpath. The ZIP that 
contains the sample code has an executable JAR file 'AdagesPublish.jar' that includes all of the
dependencies. The JAR can be executed from the command line:
----
% java -jar AdagesPublish.jar
----
The +AdagesPublisher+ awaits connections on port 9876 (line 1) and the URI (line 2) is 
+/resourcesA+. Accordingly, the base URL is:
----
http://localhost:9876/resourcesA/
----
The JAX-RS utility publisher uses classes such as +HttpServer+ and +HttpHandler+, which
come with core Java. Later examples will put these and related classes to use. The point for
now is that there are options for publishing JAX-RS services, including a very lightweight
option. The 'adages' web service performs the same way regardless of how it is published. 
The Jersey
implementation does a nice job of cleanly separating JAX-RS services from their publication.
****

.Publishing JAX-RS resources with Tomcat
[options="header"]
****
The JAX-RS and Jersey packages do not come with the core Java JDK; instead, the relevant JAR files can be
found at 'jersey.java.net'. There is a Maven repository from which a Maven script can install
Jersey and its dependencies but the standalone JAR files are available as well. The Maven approach deliberately
hides the deployment details to make life easier for the developer. The goal here, however, is to
understand how things work under the hood. In any case,
working directly with the JARs is straightforward.

JAX-RS resources can be published as usual with the Ant 'build.xml' script.
For example, the command to deploy a JAX-RS resource in the WAR file named 'adages'
is
----
% ant -Dwar.name=adages deploy
----
As usual, the relevant files would be in a 'src' directory. In this example, the three '.java' files
are in the 'src/adages' subdirectory. The remaining files, including four Jersey JARs, are in
'src'. The relevant JAR files, with approximate sizes, are
----
asm.jar             ;;  43K bytes
jersey-core.jar     ;; 206K bytes
jersey-server.jar   ;; 595K bytes
jersey-servlet.jar  ;; 125K bytes
----
The last three JARs are available, for convenience, in a 'jersey-bundle.jar'. 

There are different ways to
make these four JARs accessible to Tomcat. The JAR files could be copied to 'TOMCAT_HOME/lib' and thereby
be made available to any WAR file deployed under Tomcat. (Recall that Tomcat must be restarted after 
files are copied to its 'lib' directory in contrast to its 'webapps' directory.) The problem with
this approach is version control. Should new versions of the JARs be installed as they come out?
If so, will these new versions break already deployed web services? A more conservative approach is to
'freeze' a deployed WAR file by packing the four JARs within the WAR file. This approach also
makes it easier to port the WAR from one web server to another, for instance, from Tomcat on one
machine to Tomcat on another machine, or from Tomcat to Jetty, and so on. The one downside to packing the JARs inside
the WAR is, of course, that the WAR file becomes larger. My preference is to include the required JARs
within the WAR file. With this approach, the contents of deployed WAR file 'adages.war' are:
----
WEB-INF/web.xml
WEB-INF/classes/adages/Adage.class
WEB-INF/classes/adages/Adages.class
WEB-INF/classes/adages/RestfulAdage.class
WEB-INF/lib/asm.jar
WEB-INF/lib/jackson-annotations.jar
WEB-INF/lib/jackson-core.jar
WEB-INF/lib/jackson-databind.jar
WEB-INF/lib/jersey-core.jar
WEB-INF/lib/jersey-server.jar
WEB-INF/lib/jersey-servlet.jar
----
The three JAR files that begin with +jackson+ handle the generation of JSON documents. Jackson is a collection of
Java packages ('jackson.codehaus.org') for producing and consuming JSON documents. The main text 
explains how Jackson works with the rest of the service.

The class +adages.RestfulAdage+ (see <<Ex5>>) encapsulates a +getClasses+ method, whose role can be clarified
with reference to the deployment file 'web.xml'. A JAX-RS service deployed under Tomcat needs 
a minimalist 'web.xml' to set up communication between the servlet container and the service. 
Here is an example, which can be used with any Jersey JAX-RS service published with Tomcat (or Jetty):
----
<?xml version="1.0" encoding="UTF-8"?>  
<web-app>  
  <servlet>  
    <servlet-name>jersey</servlet-name>  
    <servlet-class>
       com.sun.jersey.spi.container.servlet.ServletContainer
    </servlet-class>  
    <load-on-startup>1</load-on-startup>
  </servlet>      
</web-app>  
----
The +load-on-startup+ element prompts Tomcat to instantiate and
load an instance of the Jersey +ServletContainer+ during the WAR bootstrap process; and the critical role of 
the +ServletContainer+ is to scan the deployed WAR file for Jersey +Application+
classes. Here is a slice of Tomcat's 'catalina.out' log file, edited for readability:
----
INFO: Deploying web application archive adages.war
INFO: Registering Jersey servlet application, named adages.RestfulAdage,  <1>
      at the servlet mapping, /resources/*, with the Application class 
      of the same name
INFO: Scanning for root resource in the Web app resource paths:
INFO: Root resource classes found: class adages.Adages                    <2>
INFO: Instantiated the Application class adages.RestfulAdage
----
The upshot of this log segment is that the Jersey +ServletContainer+ finds the
class +RestfulAdage+ (line 1), which in turn identifies the JAX-RS 
resources in the WAR file (line 2). In this case, there is only one
such resource: +Adages+. By the way, if multiple JAX-RS services are
deployed to a servlet container, then each service should have a unique name for the
class that extends +Application+. In this first example, the class is named
+RestfulAdage+; in a later example, the name is +RestfulPrediction+ to avoid
conflict.

The JAX-RS service in the deployed WAR file, 'adages.war', is now ready to accept requests 
such as 
----
% curl http://localhost:8080/adages/resourcesA/
----
****

The +Adage+ class (see <<Ex6>>) has an +import+ for the JAX-B (Java API for XML-Binding) 
annotation +XmlRootElement+. The term 'binding' refers, in this context, to linking a 
Java data type such as +String+ to an XML type, in this case +xsd:string+. 

[[Ex6]]
.The +Adage+ POJO class annotated for XML generation through JAX-B.
====
----
package adages;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "adage")                              <1>
public class Adage {
    private String words;
    private int wordCount;
    
    public Adage() { }
    @Override
    public String toString() {
	return words + " -- " + wordCount + " words";
    }
    public void setWords(String words) { 
	this.words = words; 
	this.wordCount = words.trim().split("\\s+").length;
    }
    public String getWords() { return this.words; }
    public void setWordCount(int wordCount) { }
    public int getWordCount() { return this.wordCount; }
}
----
====
The +@XmlRootElement+ annotation (line 1) signals that an +Adage+ object can be transformed into an XML document
whose 'document' or 'root' (that is, outermost) element is named +adage+. 
For example, the XML document
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<adage>
  <wordCount>7</wordCount>
  <words>What can be shown cannot be said.</words>
</adage>
----
results from the JAX-B transformation of an in-memory +Adage+ object.

The +Adages+ class (see <<Ex7>>) is a JAX-RS 'resource' that accepts RESTful requests, in 
this case only GET requests, and responds with payloads of these three MIME types: +text/plain+,
+application/json+, and +application/xml+.

[[Ex7]]
.The +Adages+ class as a JAX-RS resource.
====
----
package adages;

import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.JAXBElement;
import javax.xml.namespace.QName;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.util.Random;
import com.fasterxml.jackson.databind.ObjectMapper;

@Path("/")
public class Adages {
    // Add aphorisms to taste...
    private String[ ] aphorisms = 
       {"What can be shown cannot be said.",
	"If a lion could talk, we could not understand him.",
	"Philosophy is a battle against the bewitchment of " +
        "our intelligence by means of language.",
	"Ambition is the death of thought.",
	"The limits of my language mean the limits of my world."};
    public Adages() { }
    @GET
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml" 
    public JAXBElement<Adage> getXml() {
	return toXml(createAdage());
    }
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public String getJson() {
	return toJson(createAdage());
    }
    @GET
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/plain")
    public String getPlain() {
	return createAdage().toString() + "\n";
    }
    // Create an Adage and set the words property, which
    // likewise sets the wordCount property. The adage is
    // randomly selected from the array, aphorisms.
    private Adage createAdage() {
	Adage adage = new Adage();
	adage.setWords(aphorisms[new Random().nextInt(aphorisms.length)]);
	return adage;
    }
    // Java Adage --> XML document
    @XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
    private JAXBElement<Adage> toXml(Adage adage) {
	return new JAXBElement<Adage>(new QName("adage"), Adage.class, adage);
    }
    // Java Adage --> JSON document
    // Jersey provides automatic conversion to JSON using the Jackson
    // libraries. In this example, the conversion is done manually 
    // with the Jackson libraries just to indicate how straightforward it is.
    private String toJson(Adage adage) {
	String json = "If you see this, there's a problem.";
	try {
	    json = new ObjectMapper().writeValueAsString(adage);
	}
	catch(Exception e) { }
	return json;
    }
} 
----
====
Perhaps the best way to clarify how the three Java classes interact is through sample
client calls. To begin, consider the request
----
% curl localhost:8080/adages/resourcesA/plain
----
On a sample run, the output was:
----
What can be shown cannot be said. -- 7 words
----
The RESTful routing of the client's request works as follows:

* In the URI '/adages/resources/plain', the initial segment '/adages' specifies the deployed WAR file 'adages.war'.

* The next sub-segment '/resourcesA' represents the JAX-RS +ApplicationPath+, information that the WAR file's +RestfulAdage+ provides to the web server.

* The next sub-segment is '/'. Recall that the RESTful resource in this web service is the +Adages+ class, which begins:
+
----
@Path("/")
public class Adages {
...
----
+
The +@Path("/")+ annotation represents the last slash in the URI 'adages/resources/'. Accordingly, this URI maps to the +Adages+ class, which is 
the one and only JAX-RS resource in the deployed WAR file 'adages.war'.

* The final sub-segment in the URI is 'plain' so that full URI is 
+
----
/adages/resources/plain
----
+
The +Adages+ method +getPlain+ is
+
----
@GET
@Produces({MediaType.TEXT_PLAIN})
@Path("/plain")
public String getPlain() {
   return createAdage().toString() + "\n";
}
----
+
The +@GET+ annotation signals that the method/operation +getPlain+, an arbitrary name, is accessible through a GET request only. 
The +@Produces+ annotation promises, in effect,
to respond with the MIME type +text/plain+. This is a promise rather than a guarantee. The +@Path+ annotation indicates the URI sub-segment 
'/plain' completes the path to this service operation.

The RESTful routing idioms used in JAX-RS follow the spirit, if not the exact syntax, of those from the Rails framework. 
These idioms support clear, terse URIs such as
----
/adages/resourcesA/plain
----

and 

----
adages/resourcesA/json
----

==== JAX-RS Generation of XML and JSON Responses

The interaction between the JAX-RS resource class +Adages+ and the POJO class +Adage+ needs clarification.  Recall that class +Adage+ begins
----
@XmlRootElement(name = "adage")
public class Adage {
...
----

and that the annotation +@XmlRootElement+ allows an +Adage+ instance to be serialized into an XML document with +<adage>+ as its document-level
start tag. In the language of JAX-RS, the +Adage+ class is a 'provider' of XML. 
(See the sidebar for details about how JAX-B uses an XML Schema to generate the XML.) +Adage+ is likewise a POJO class 
with the familiar 'get/set' methods for two properties, +words+ and +wordCount+. The only unusual
detail is that the +setWords+ method also sets the +wordCount+ for the adage
----
public void setWords(String words) { 
   this.words = words; 
   this.wordCount = words.trim().split("\\s+").length; // word count
}
----
because this is a convenient way to do so. 

.How JAX-B can transform a Java object into an XML document
[options="header"]
****
The 'adages' JAX-RS service uses the JAX-B library, under the hood, to transform a Java object, an +Adage+ instance, into an
XML document such as:
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<adage>
  <wordCount>14</wordCount>
  <words>
    Philosophy is a battle against the bewitchment of our intelligence 
    by means of language.
  </words>
</adage>
----
The +@XmlRootElement+ annotation on the +Adage+ class guides the transformation by indicating
that the outermost XML element is to be named +adage+; and the return data type +JAXBElement<Adage>+ in the +getXml+
method represents, in Java, an XML element--including an entire XML document. This sidebar delves into the
details.

The core Java JDK has a 'schemagen' utility footnote:[In core Java 8, the functionality of the 'schemagen' utility
will give way to general annotation processing through 'javac'.]
that, when applied to a POJO source file such as 'Adage.java',
generates an XML Schema. The utility can be invoked from the command-line:
----
% schemagen Adage.java
----
The resulting XML Schema document is:
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:complexType name="Adage">
    <xs:sequence>
      <xs:element name="words" type="xs:string"/>
      <xs:element name="wordCount" type="xs:int"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>
----
This XML Schema document has all of the information that JAX-B utilities would need to go from an 
XML +adage+ document to a Java +Adage+ instance:

* The XML Schema indicates that the data type, an XML +complexType+, is named +Adage+. In this
context, a +complexType+ is contrasted with a simple, built-in type such as +xsd:string+.
The +Adage+ class is programmer-defined rather than built-in as well.
When an +Adage+ instance is constructed, its two properties, +words+ and +wordCount+, are
available for setting.

* The XML Schema specifies an element named +words+ and another element named +wordCount+, with the data type
of each: a +word+ in XML is an +xs:string+, which binds to a Java +String+; and a +wordCount+ is
in XML is an +xs:int+, which binds to a Java +int+. JAX-B thus works from the convention that
the +Adage+ elements in the XML Schema correspond to Java properties, with the corresponding
'set'-methods, in this case +setWords+ and +setWordCount+.

In summary, the JDK 'schemagen' utility can generate an XML Schema instance from a Java class.
A second JDK utility, 'xjc', works in the other direction. Given an XML Schema, 'xjc' can generate Java
classes to represent the XML types in the schema. Such processing details, which remain hidden in the Jersey
implementation of JAX-RS, will be investigated carefully in Chapter 3. This first look at the 
Java-to-XML transformation sketches the kind of processing that Jersey must perform to transform an 
+Adage+ into an XML document.
****
The +Adages+ resource has three methods that define the web service operations, the methods named +getJson+, +getPlain+, 
and +getXml+. The 
operation names are arbitrary. The important routing information for each operation comes from the annotations that
describe the HTTP verb (in this case, only GET) and the +@Path+. The  +getXml+ operation has no +@Path+ annotation, which
means that the path for the resource, the +Adages+ class, is the the path for this operation; and the path is
'/adages/resourcesA/'. In effect, +getXml+ is the default operation.

The +getJson+ and +getXml+ operations could be combined into a single operation
----
@GET
@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) 
...
----
because Jersey can coordinate directly with the Jackson libraries to process JSON. My implementation uses Jackson explicitly to show
just how simple the API is. Further, if the two operations were combined into one, then a client would have to disambiguate the request by
adding the HTTP header 
----
Accept: application/json
----
to the HTTP request. It seems cleaner to use two different URIs: '/adages/resourcesA/'
maps to the default +getXml+ operation, whereas '/adages/resourcesA/json' maps to the +getJson+ operation. Here for review is the utility method
that +getJson+ calls to produce the JSON:
----
private String toJson(Adage adage) {
   String json = "If you see this, there's a problem.";
   try {
      json = new ObjectMapper().writeValueAsString(adage); <1>
   } catch(Exception e) { }
   return json;
}
----
The Jackson +ObjectMapper+ encapsulates the method +writeValueAsString+ (line 1),
which serializes an +Adage+ into a JSON document.
The response for a sample request against the +toJson+ operation, 
formatted for readability, would look like this:
----
{"words":    "The limits of my language mean the limits of my world.",
 "wordCount":11
}
----

Similar serialization occurs with respect to an +Adage+ converted into an XML document.
The default operation +getXml+
----
@GET
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public JAXBElement<Adage> getXml() {
   return toXml(createAdage());
}
----
returns a +JAXBElement<Adage>+, an XML document that represents an +Adage+. Under the hood the JAX-B
processor converts an +Adage+ instance into an XML document. On a sample run the output was
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<adage>
  <wordCount>10</wordCount>
  <words>If a lion could talk, we could not understand him.</words>
</adage>
----
The POJO class +Adage+ currently has but one annotation, +@XmlRootElement+. A variety of others could
be used to refine the XML output. Here is a sample refinement:
----
package adages;
...
@XmlRootElement(name = "adage")
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(propOrder = {"words", "wordCount"})  <1>
public class Adage {
    @XmlElement(required = true) 
    protected String words;
    @XmlElement(required = true)
    protected int wordCount;
    ...
----
The +@XmlType+ (line 1) is particularly useful if the order of elements in the generated XML document matters. 
In the current implementation, the +wordCount+ element precedes the +words+ element; but this order
could be reversed through the +propOrder+ attribute in the +@XmlType+ annotation (line 1).

This first JAX-RS example illustrates the style of implementing a RESTful web service as a 
JAX-RS resource. The deployment under Tomcat is uncomplicated; and the 'adages.war' file also can 
be deployed, as is, under Jetty. 
The 'adages' service supports only GET requests. The forthcoming 'adages2' service, implemented as a set of 
Restlet resources, supports all of the CRUD operations. The next section also shows, with a different 
example, how JAX-RS nicely
supports all of the CRUD operations.

==== Porting the 'predictions' Web Service to JAX-RS
The servlet-based 'predictions2' service supports the four CRUD operations; hence, the port from the servlet/JSP implementations to
JAX-RS is an opportunity to show the +@POST+, +@PUT+, and +@DELETE+ annotations and to illustrate 
parametrized versions of the +@GET+ and +@DELETE+ operations. This revision highlights again the JAX-RS idioms
for RESTful URIs. The revised service is called 'predictions3'.

The JAX-RS 'predictions3' service has four Java classes:

* The +RestfulPrediction+ class extends the JAX-RS +Application+ class. When the service WAR file is loaded into Tomcat or Jetty, the Jersey 
+ServletContainer+ finds the +RestfulPrediction+ instance and invokes its +getClasses+ method to identify the RESTful
resources in the WAR file. In the case of the +RestfulPrediction+ service, there is only one resource: the
+PredictionsRS+ class.

* The +PredictionsRS+ class is the RESTful resource, a POJO class whose methods carry annotations such as +@GET+ and +@POST+ in
support of the standard CRUD operations. This resource supports MIME-typed requests for XML, JSON, and plain text. A
GET request can ask for all predictions or for a specific one.

* The +Prediction+ class is a also a POJO class with two properties from before: +who+ is the author of the prediction and
+what+ is the prediction itself. There is still an +id+ property whose value uniquely identifies each +Prediction+ instance;
prediction instances are stored, in ascending order by +id+, in a +PredictionsList+, explained in the next bullet point. 
The +Prediction+ class is annotated as an +@XmlRootElement+ so that Jersey can automatically convert
a single prediction into an XML document. The 'get'-methods of the properties are annotated with 
+@XmlElement+ for emphasis. A +Prediction+ instance can be transformed into an XML or a JSON document; the +Prediction+ override
of the +toString+ method supports a plain-text format as well. The +Prediction+ class still implements the
+Comparable+ interface in case sorting is needed. The implementation logic of 'predictions3' ensures, however, that the
predictions are always sorted by +id+ in ascending order; hence, additional sorting might put the predictions in descending order
by +id+, ascending order by +who+, and so on.

* The +PredictionsList+ is a class that represents a collection of +Prediction+ instances, with the collection implemented as
a thread-safe +CopyOnWriteArrayList+. The integer +id+ of each prediction added to the list is generated with a thread-safe
+AtomicInteger+.
The class +PredictionsList+ is annotated as an +@XmlRootElement+ so that Jersey 
automatically serializes a list of predictions, as well as a single prediction, into XML. The +PredictionsList+ class likewise
overrides the +toString+ method, yet again a convenient way to support a plain-text representation of a predictions list.

The +RestfulPrediction+ class (see <<Ex8>>) is the JAX-RS +Application+ class. To ensure that the 'adages' 
JAX-RS service of Section 3.1 and this
JAX-RS service can co-exist in the same servlet container, the names of the two +Application+ classes must differ:
in the case of 'adages', the +Application+ class is +RestfulAdage+; and in this case, the +Application+ class is
+RestfulPrediction+.

[[Ex8]]
.Registering the +PredictionsRS+ class as a JAX-RS resource
====
----
package predictions3;

import java.util.Set;
import java.util.HashSet;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/resourcesP")
public class RestfulPrediction extends Application {
    @Override
    public Set<Class<?>> getClasses() {
	Set<Class<?>> set = new HashSet<Class<?>>();
        set.add(PredictionsRS.class);
        return set;
    }
}
----
====
The back-end support for the +PredictionsRS+ source consists of two POJO classes, +Prediction+ (see <<Ex9>>) and
+PredictionsList+ (see <<Ex10>>). The class +Prediction+ is mostly unchanged from the 'predictions2' version except for
the added +@XmlRootElement+ annotation, which means that the run-time can automatically convert a 
+Prediction+ instance into an XML document. Details follow shortly. 

[[Ex9]]
.The +Prediction+ class with properties +who+, +what+, and +id+
====
----
package predictions3;

import javax.xml.bind.annotation.XmlRootElement; 
import javax.xml.bind.annotation.XmlElement;

@XmlRootElement(name = "prediction")
public class Prediction implements Comparable<Prediction> {
    private String who;   // person
    private String what;  // his/her prediction
    private int    id;    // identifier used as lookup-key

    public Prediction() { }
    @Override
    public String toString() {
	return String.format("%2d: ", id) + who + " ==> " + what + "\n";
    }
    public void setWho(String who) { this.who = who; }
    @XmlElement
    public String getWho() { return this.who; }
    public void setWhat(String what) { this.what = what; }
    @XmlElement
    public String getWhat() { return this.what; }
    public void setId(int id) {	this.id = id; }
    @XmlElement
    public int getId() { return this.id; }
    public int compareTo(Prediction other) { return this.id - other.id; }	
}
----
====
The +PredictionsList+ POJO class (see <<Ex10>>) in the 'predictions3' service is simpler overall than the 
+Predictions+ from class of 'predictions2' because methods such as +populate+ have moved into the core JAX-RS class.
In any case, the +PredictionsList+ class has a +find+ method to search for a particular +Prediction+; and the
data structure used to store the predictions is now a thread-safe +CopyOnWriteArrayList+. 

[[Ex10]]
.The +PredictionsList+ class 
====
----
package predictions3;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import javax.xml.bind.annotation.XmlElement; 
import javax.xml.bind.annotation.XmlElementWrapper; 
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "predictionsList")
public class PredictionsList {
    private List<Prediction> preds; 
    private AtomicInteger predId;

    public PredictionsList() { 
	preds = new CopyOnWriteArrayList<Prediction>(); 
	predId = new AtomicInteger();
    }
    @XmlElement 
    @XmlElementWrapper(name = "predictions") 
    public List<Prediction> getPredictions() { 
	return this.preds;
    } 
    public void setPredictions(List<Prediction> preds) { 
	this.preds = preds;
    }
    @Override
    public String toString() {
	String s = "";
	for (Prediction p : preds) s += p.toString();
	return s;
    }
    public Prediction find(int id) {
	Prediction pred = null;
	// Search the list -- for now, the list is short enough that
	// a linear search is ok but binary search would be better if the
	// list got to be an order-of-magnitude larger in size.
	for (Prediction p : preds) {
	    if (p.getId() == id) {
		pred = p;
		break;
	    }
	}	
	return pred;
    }
    public int add(String who, String what) {
	int id = predId.incrementAndGet();
	Prediction p = new Prediction();
	p.setWho(who);
	p.setWhat(what);
	p.setId(id);
	preds.add(p);
	return id;
    }
}
----
====
[[Ex11]]
.The JAX-RS resource +PredictionsRS+
====
----
package predictions3;

import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.DELETE;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.FormParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Context;
import javax.servlet.ServletContext;
import com.fasterxml.jackson.databind.ObjectMapper;

@Path("/")
public class PredictionsRS {
    @Context 
    private ServletContext sctx;          // dependency injection
    private static PredictionsList plist; // set in populate()

    public PredictionsRS() { }

    @GET
    @Path("/xml")
    @Produces({MediaType.APPLICATION_XML}) 
    public Response getXml() {
	checkContext();
	return Response.ok(plist, "application/xml").build();
    }
    @GET
    @Path("/xml/{id: \\d+}")
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
    public Response getXml(@PathParam("id") int id) {
	checkContext();
	return toRequestedType(id, "application/xml");
    }
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public Response getJson() {
	checkContext();
	return Response.ok(toJson(plist), "application/json").build();
    }
    @GET    
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json/{id: \\d+}")
    public Response getJson(@PathParam("id") int id) {
	checkContext();
	return toRequestedType(id, "application/json");
    }
    @GET
    @Path("/plain")
    @Produces({MediaType.TEXT_PLAIN}) 
    public String getPlain() {
	checkContext();
	return plist.toString();
    }
    @POST
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/create")
    public Response create(@FormParam("who") String who, 
			   @FormParam("what") String what) {
	checkContext();
	String msg = null;
	// Require both properties to create.
	if (who == null || what == null) {
	    msg = "Property 'who' or 'what' is missing.\n";
	    return Response.status(Response.Status.BAD_REQUEST).
		                                   entity(msg).
		                                   type(MediaType.TEXT_PLAIN).
		                                   build();
	}	    
	// Otherwise, create the Prediction and add it to the collection.
	int id = addPrediction(who, what);
	msg = "Prediction " + id + " created: (who = " + who + " what = " + what + ").\n";
	return Response.ok(msg, "text/plain").build();
    }
    @PUT
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/update")
    public Response update(@FormParam("id") int id,
			   @FormParam("who") String who, 
			   @FormParam("what") String what) {
	checkContext();
	// Check that sufficient data are present to do an edit.
	String msg = null;
	if (who == null && what == null) 
	    msg = "Neither who nor what is given: nothing to edit.\n";
	Prediction p = plist.find(id);
	if (p == null)
	    msg = "There is no prediction with ID " + id + "\n";

	if (msg != null)
	    return Response.status(Response.Status.BAD_REQUEST).
		                                   entity(msg).
		                                   type(MediaType.TEXT_PLAIN).
		                                   build();
	// Update.
	if (who != null) p.setWho(who);
	if (what != null) p.setWhat(what);
	msg = "Prediction " + id + " has been updated.\n";
	return Response.ok(msg, "text/plain").build();
    }
    @DELETE
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/delete/{id: \\d+}")
    public Response delete(@PathParam("id") int id) {
	checkContext();
	String msg = null;
	Prediction p = plist.find(id);
	if (p == null) {
	    msg = "There is no prediction with ID " + id + ". Cannot delete.\n";
	    return Response.status(Response.Status.BAD_REQUEST).
		                                   entity(msg).
		                                   type(MediaType.TEXT_PLAIN).
		                                   build();
	}
	plist.getPredictions().remove(p);
	msg = "Prediction " + id + " deleted.\n";
	return Response.ok(msg, "text/plain").build();
    }
    private void checkContext() {
	if (plist == null) populate();
    }
    private void populate() {
	plist = new PredictionsList();
	String filename = "/WEB-INF/data/predictions.db";
	InputStream in = sctx.getResourceAsStream(filename);
	// Read the data into the array of Predictions. 
	if (in != null) {
	    try {
		BufferedReader reader = new BufferedReader(new InputStreamReader(in));
		int i = 0;
		String record = null;
		while ((record = reader.readLine()) != null) {
		    String[] parts = record.split("!");
		    addPrediction(parts[0], parts[1]);
		}
	    }
	    catch (Exception e) { 
		throw new RuntimeException("I/O failed!"); 
	    }
	}
    }
    private int addPrediction(String who, String what) {
	int id = plist.add(who, what);
	return id;
    }
    // Prediction --> JSON document
    private String toJson(Prediction prediction) {
	String json = "If you see this, there's a problem.";
	try {
	    json = new ObjectMapper().writeValueAsString(prediction);
	}
	catch(Exception e) { }
	return json;
    }
    // PredictionsList --> JSON document
    private String toJson(PredictionsList plist) {
	String json = "If you see this, there's a problem.";
	try {
	    json = new ObjectMapper().writeValueAsString(plist);
	}
	catch(Exception e) { }
	return json;
    }
    // Generate an HTTP error response or typed OK response.
    private Response toRequestedType(int id, String type) {
	Prediction pred = plist.find(id);
	if (pred == null) {
	    String msg = id + " is a bad ID.\n";
	    return Response.status(Response.Status.BAD_REQUEST).
		                                   entity(msg).
		                                   type(MediaType.TEXT_PLAIN).
		                                   build();
	}
	else if (type.contains("json"))
	    return Response.ok(toJson(pred), type).build();
	else
	    return Response.ok(pred, type).build(); // toXml is automatic
    }
}
----
====
The +PredictionsRS+ class (see <<Ex11>>) is the JAX-RS resource with annotations that define the CRUD operations. The
class is long enough that inspecting the code in chunks may be helpful. A summary of the major parts follows.

* There are five operations annotated with +@GET+. 
+
Three of the +@GET+ operations return the entire list of predictions: in
XML, in JSON, and in plain-text format. In addition, there is a parametrized GET
+
----
@GET
@Path("/xml/{id: \\d+}")   
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public Response getXml(@PathParam("id") int id) {
...
----
+
that, if successful, returns a single prediction in XML. There is a similarly parametrized GET that,
if successful, returns a
single prediction in JSON. The +@Path+ annotation
+
----
@Path("/xml/{id: \\d+}")
----
+
contains a parameter, +id+, together with a regular expression that restricts the values of the 
parameter to one or more decimal digits. The regular expression also could be written as
+
----
@Path("/xml/{id: [0-9]+}")
----
+
In either case, the regular expression requires at least one but perhaps more decimal digits.
A request such as
+
----
% curl http://localhost:8080/predictions3/resourcesP/xml/13
----
+
would succeed and return, as an XML document, the +Prediction+ with +id+ 13 because +13+ matches the
specified pattern. However, a request such as
+
----
% curl http://localhost:8080/predictions3/resourcesP/xml/foo
----
+
would result in an HTTP 404 (Not Found) error because +foo+ does not match the one-or-more-decimal-digits pattern.
The JAX-RS support for precise data validation through regular expressions is, of course, convenient; the only
complication comes in the regular expressions themselves.
+
The methods that implement parametrized GET operations use the +@PathParam+ annotation to
identify which argument in a method corresponds to the URI parameter. For example, the +getJson+
method begins
+
----    
@GET    
@Produces({MediaType.APPLICATION_JSON})
@Path("/json/{id: \\d+}")
public Response getJson(@PathParam("id") int id) { <1>
...
----
+
The +@PathParam+ named +id+ (line 1) corresponds, in this example, to the +int+ parameter named
+id+ as well. The two names could differ. If a URI had multiple parameters
+
----
http://...:8080/greetings/resourcesG/msg/fred/Hi
----
+
then the order of the Java method's parameters 
+
----
...
@Path("/msg/{who}/{what}
public Response echoMessage(@PathParam("what") String p1, 
                            @PathParam("who") String p2) {
...
----
+
could differ from the order in the URI.

.Why does the 'predictions3' RESTful service use +static+ class members?
[options="header"]
****
In a production-grade service, the data typically would be persisted in a database of some kind. 
As the +PredictionsRS+ resource in the 'predictions3' service changes through POST, PUT, and DELETE operations,
however, these changes are not persisted in a back-end database; instead, a +static+ collection is used
to store--in memory--the changing data. My goal is to keep the focus on the APIs for RESTful services,
minimizing distractions wherever possible; and database access would be one such distraction. In a
production-grade service, of course, a persistent data store almost surely would be the way to go. Two later
examples illustrate how the JPA (Java Persistence API) can be used to persist +Predictions+ with two different
relational database systems.
****

* The operations annotated with +@POST+, +@PUT+, and +@DELETE+ implement the remaining CRUD operations: 
'create', 'update', and 'delete', respectively.
+
In the 'predictions3' service, most of the RESTfully annotated operations return the JAX-RS type +Response+. This
gives the operations a common look-and-feel that accentuates critical features of an HTTP response: the
HTTP status code together with the content-type of the response. For simplicity, the +getPlain+ method
returns a +String+.
Here is the +return+ statement from the
non-parametrized +getXml+ operation, which returns all of the predictions in XML format:
+
----
return Response.ok(predictions, "application/xml").build();
----
+
Consider the contrast between this +return+ statement and its counterpart in the 'adages' JAX-RS service:
+
----
@GET
@Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
public JAXBElement<Adage> getXml() {
    return toXml(createAdage());
}
----
+
In the 'adages' case, the return type is +JAXBElement+ and there is an explicit call to the +toXml+
method to convert an +Adage+ instance into an XML document:
+
----
@XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
private JAXBElement<Adage> toXml(Adage adage) {
   return new JAXBElement<Adage>(new QName("adage"), Adage.class, adage);
}
----
+
By contrast, the 'predictions3' service simply returns a +Predictions+ instance as the +Response+ without
wrapping the +predictions+ reference in a call to +toXml+:
+
----
//**** No need to invoke toXml on the predictions!
return Response.ok(toXml(predictions), "application/xml").build();
----
+
The reason for this simplification is that, with +Response+ as the return type of the +getXml+ method, the
JAX-RS run-time automatically generates the XML; and JAX-RS run-time does so because the
+@Produces+ annotation gives +application/xml+ as the MIME type of the HTTP response. Recall
that the +Prediction+ and +PredictionsList+ POJO classes are annotated with +@XmlRootElement+. The
combination of this annotation and the +@Produces+ annotation together automate the XML
generation.

The 'predictions3' service still has a +toJson+ utility method to convert one +Prediction+ or
a collection of these into JSON. This is a design decision, not a necessity. The JAX-RS run-time also generates
JSON automatically if the relevant Jackson libraries are included and if the HTTP request contains
the header element +Accept: application/json+. The conversion to JSON is simple enough that
'predictions3' does it manually, thereby sparing the client the responsibility of adding a specific header element
to the HTTP request.

The request pattern in the 'predictions3' service is uniform as there is no default URI, that is,
a URI consisting solely of the slash +/+.
A request for an XML document ends with +/xml+ for all predictions in XML or, for instance, 
+/xml/7+ to get prediction 7 in XML; a request for JSON ends with +/json+ or, for example,
+/json/13+; and a request for plain text ends with +/plain+. The JAX-RS patterns for URIs can adhere
to the Rails URI patterns, now widely imitated, as closely as the programmer likes.

=== A RESTful Web Service as Restlet Resources
The Restlet web framework supports RESTful web services and the API is similar to JAX-RS; indeed,
a Restlet application can use JAX-RS annotations such as +@Produces+ instead of or in addition to
Restlet annotations. This section adapts the earlier JAX-RS 'adages' service to a Restlet 
implementation, which is published both with a web server and with a standalone Java application
The revised service, 'adages2', implements the four CRUD operations.

.Downloading and using the Restlet framework
[options="header"]
****
The Restlet JAR files are available for download at 'www.restlet.org'. The current version is
2.x. There are 
editions for core and enterprise Java together with tutorials, documentation, and examples. 
Restlet, like JAX-RS, provides HTTP-method annotations for 'resources'. Restlet has a 
client-side and a service-side API.
A Restlet resource published under Tomcat or Jetty can be published, with little change, using 
a standard command-line application and a single Restlet JAR file. The framework does a 
first-rate job of decoupling the service-as-a-resource from its publication. 

The Restlet framework includes JAR files to interoperate with other popular Java frameworks
such as Spring and the Google Web Toolkit. Restlet even supports, through an extension,
JAX-RS annotations such as +@POST+ and +@Produces+.
There are libraries for Apache's Velocity templating engine ('velocity.apache.org'),
email, SSL (Secure Sockets Layer), OAuth ('oauth.net'), and various other technologies. Anyone versatile in
either JAX-RS or Restlet should have little trouble adapting to the other; and both approaches are worth
a look.
****
A Restlet web service has three main parts, each of which consists has one or more Java classes:

* A programmer-defined class, in this example +AdagesApplication+, extends the Restlet +Application+ class.
The purpose of the extended class is to set up a 'routing table', which maps request URIs to resources.
The resources are named or anonymous Java classes; and the current example illustrates both approaches. The
spirit of Restlet development is to have very simple resource classes.

* There are arbitrarily many resource classes, any mix of named or anonymous. In best practices, a resource
implementation supports a very small number of operations on the resource, in the current example only one
operation per resource. For example, the 'adages2' service has seven resources: six of these are named classes that
extend the Restlet +ServerResource+ class and the other is an anonymous class that implements the
+Restlet+ interface. The named classes are +CreateResource+, the target of a POST request; +UpdateResource+, the
target of a PUT request; +XmlAllResource+, the target of a GET request for all +Adages+ in XML; +JsonAllResource+,
the target of a GET request for all +Adages+ in JSON; +XmlOneResource+, the target of a GET request for a
specified +Adage+; and so on.

* The back-end POJO classes are +Adage+ and +Adages+, each slightly redefined from the earlier 'adages' 
web service.

If the Restlet service is deployed with a web server such as Tomcat or Jetty, then the Restlet +ServerServlet+
acts as an interceptor for requests against the Restlet service. The interceptor servlet interacts with the
Restlet +Application+, which contains the routing table, so that a properly formatted request winds up at the
correct Restlet resource. The architecture is simple and clean. Deployment of 'adages2' service requires a 
'web.xml' document (see <<Ex12>>) that sets up the Restlet interceptor (line 1) and links the
interceptor to the Restlet +Application+ (line 2).

[[Ex12]]
.The 'web.xml' file for the 'adages2' Restlet service
====
----
<?xml version="1.0" encoding="UTF-8"?>  
<web-app>
   <!-- Restlet adapter -->  
   <servlet>  
      <servlet-name>RestletServlet</servlet-name>  
      <servlet-class>org.restlet.ext.servlet.ServerServlet</servlet-class>  <1>
      <init-param>
        <!-- Application class name -->
        <param-name>org.restlet.application</param-name>
        <param-value>adages2.AdagesApplication</param-value>                <2>
      </init-param>
   </servlet>  
   <!-- Dispach all requests to the Restlet servlet. -->  
   <servlet-mapping>  
     <servlet-name>RestletServlet</servlet-name>  
     <url-pattern>/*</url-pattern>  
   </servlet-mapping>  
</web-app>  
----
====

.The included JAR files for the Restlet 'adages2' web service
[options="header"]
****
The 'adages2' service can be deployed to Tomcat in the usual way:
----
% ant -Dwar.name=adages2 deploy
----
The deployed WAR file includes these JAR files:
----
org.json.jar
org.restlet.ext.json.jar
org.restlet.ext.servlet.jar
org.restlet.ext.xml.jar
org.restlet.jar
----
The two main files are 'org.restlet.jar' and  'org.restlet.servlet.jar'. The remaining
three files support formatting in XML and JSON. Restlet has various options for formatting responses; the
current example illustrates two of these.
****
The +Adage+ class (see <<Ex13>>) is mostly unchanged from the earlier version of the
service. There is now an +id+ property (line 1) to support searching for a specified +Adage+ on a GET, PUT, or DELETE request.

[[Ex13]]
.The +Adage+ POJO class in the 'adages2' Restlet service
====
----
package adages2;

public class Adage {
    private String words;
    private int wordCount;
    private int id;

    public Adage() { }
    @Override
    public String toString() {
	return String.format("%2d: ", id) + words + " -- " + wordCount + " words";
    }
    public void setWords(String words) { 
	this.words = words; 
	this.wordCount = words.trim().split("\\s+").length;
    }
    public String getWords() { return this.words; }
    public void setWordCount(int wordCount) { }
    public int getWordCount() { return this.wordCount; }

    public void setId(int id) { this.id = id; }            <1>
    public int getId() { return this.id; }
}
----
====
The +Adages+ class (see <<Ex14>>) has a +static+ list (line 1), of the thread-safe type
+CopyOnWriteArrayList+, that substitutes for a persistence store such as database. The
class has a +toPlain+ method (line 2) to support a +text/plain+ response on a GET request to
the 'adages2' service. The +find+ method (line 3) supports GET, PUT, and DELETE requests for a specified
+Adage+ in the list +adages+; and the +add+ method (line 4) supports POST requests by adding a 
newly created +Adage+ to the list.

[[Ex14]]
.The POJO class +Adages+ in the 'adages2' Restlet service
====
----
package aphorism2;

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

public class Adages {
    private static CopyOnWriteArrayList<Adage> adages;        <1>
    private static AtomicInteger id;

    static {
	String[ ] aphorisms = 
	    {"What can be shown cannot be said.",
	     "If a lion could talk, we could not understand him.",
	     "Philosophy is a battle against the bewitchment of 
              our intelligence by means of language.",
	     "Ambition is the death of thought.",
	     "The limits of my language mean the limits of my world."};
	adages = new CopyOnWriteArrayList<Adage>();
	id = new AtomicInteger();
	for (String str : aphorisms) add(str);
    }

    public static String toPlain() {                          <2>
	String retval = "";
	int i = 1;
	for (Adage adage : adages) retval += adage.toString() + "\n";
	return retval;
    }
    public static CopyOnWriteArrayList<Adage> getList() { return adages; }
    public static Adage find(int id) {                        <3>
	Adage adage = null;
	for (Adage a : adages) {
	    if (a.getId() == id) {
		adage = a;
		break;
	    }
	}	
	return adage;
    }
    public static void add(String words) {                    <4>
	int localId = id.incrementAndGet();
	Adage adage = new Adage();
	adage.setWords(words);
	adage.setId(localId);
	adages.add(adage);
    }
}
----
====
The +AdagesApplication+ class (see <<Ex15>>) extends the Restlet +Application+ class (line 1) and interacts 
with the service's publisher. In the case of a 
web server such as Tomcat, this class  works with the Restlet +ServerServlet+ to dispatch incoming 
service requests to the proper resource. The dispatching is done through a pattern-driven routing table
at the end of the class.

[[Ex15]]
.The Restlet +Application+ class with the routing table
====
----
package adages2;

import org.restlet.Application;
import org.restlet.Restlet;
import org.restlet.Request;
import org.restlet.Response;
import org.restlet.routing.Router;
import org.restlet.data.Status;
import org.restlet.data.MediaType;

public class AdagesApplication extends Application {                           <1> 
    @Override
    public synchronized Restlet createInboundRoot() {
	// To illustrate the different API possibilities, implement the
	// DELETE operation as an anonymous Restlet class. For the
	// remaining operations, follow Restlet best practices and
	// implement each as a Java class.

	// DELETE handler
	Restlet janitor = new Restlet(getContext()) {                          <2>
		public void handle(Request request, Response response) {  
		    String msg = null;
		    String sid = (String) request.getAttributes().get("id");
		    if (sid == null) msg = badRequest("No ID given.\n");
		    Integer id = null;
		    try { 
			id = Integer.parseInt(sid.trim());
		    }
		    catch(Exception e) { msg = badRequest("Ill-formed ID.\n"); }
		    Adage adage = Adages.find(id);
		    if (adage == null) 
			msg = badRequest("No adage with ID " + id + "\n");
		    else {
			Adages.getList().remove(adage);
			msg = "Adage " + id + " removed.\n";
		    }
		    // Generate HTTP response.
		    response.setEntity(msg, MediaType.TEXT_PLAIN);  
		}  
	    };  
	// Create the routing table.
	Router router = new Router(getContext());
        router.attach("/",            PlainResource.class);                     <3>
	router.attach("/xml",         XmlAllResource.class);                    <4>
	router.attach("/xml/{id}",    XmlOneResource.class);                    
	router.attach("/json",        JsonAllResource.class);                   <5>
	router.attach("/create",      CreateResource.class);                    <6>
	router.attach("/update",      UpdateResource.class);
	router.attach("/delete/{id}", janitor); // instance of anonymous class
        return router;
    }
    private String badRequest(String msg) {
	Status error = new Status(Status.CLIENT_ERROR_BAD_REQUEST, msg);
	return error.toString();
    }
}   
----
====
Each 'adages2' resource could be written as an anonymous class encapsulated inside the +Application+
class; but, under Restlet best practices, these resources should be implemented as relatively small,
individual classes such as +PlainResource+ (line 3), +XmlAllResource+ (line 4), +JsonAllResource+ (line 5), 
+CreateResource+ (line 6),
and so on. For illustration, however, the +AdagesApplication+ class does include an
anonymous class that implements the +Restlet+ interface by defining the +handle+ method, which
has +Request+ and +Response+ parameters; the +Response+ and +Request+ types are quite similar to the servlet
+HttpServletRequest+ and +HttpServletResponse+ types, respectively.
The reference to an instance of this anonymous class is
named +janitor+ (line 2) because the class handles DELETE requests by removing a specified +Adage+ from the
list of adages. 

The routing table at the end of +AdagesApplication+ class follows a popular idiom for
RESTful frameworks such as Restlet: a URI
pattern maps to a specified resource. A routing-table entry such as
----
router.attach("/", PlainResource.class);
----
maps the URI +/+, the single slash, to the +PlainResource+, thereby making this resource the
default one. 
By contrast, the entry
----
router.attach("/xml/{id}", XmlOneResource.class); // {id} is a parameter
---- 
includes the parameter +id+ in braces, where the numerical +id+ identifies the desired +Adage+.
The URI for the +UpdateResource+ does not include the identifier for the +Adage+ in question
because this information is supplied in the body of the PUT request.

The resource classes are quite short because each has very specialized, hence limited, 
functionality. For example, the +XmlAllResource+ is <<xml_all>>.

[[xml_all]]
.The +XmlAllResource+ Restlet resource.
====
----
package adages2;

import org.restlet.resource.Get;
import org.restlet.resource.ServerResource;
import org.restlet.representation.Representation;
import org.restlet.ext.xml.DomRepresentation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.restlet.data.Status;
import org.restlet.data.MediaType;
import java.util.List;

public class XmlAllResource extends ServerResource {
    public XmlAllResource() { }
    @Get                                                      <1>
    public Representation toXml() {
	List<Adage> list = Adages.getList();
	DomRepresentation dom = null;                         <2>
        try {  
            dom = new DomRepresentation(MediaType.TEXT_XML);  
	    dom.setIndenting(true);
            Document doc = dom.getDocument();  
  
            Element root = doc.createElement("adages");  
	    for (Adage adage : list) {
		Element next = doc.createElement("adage");  
		next.appendChild(doc.createTextNode(adage.toString()));  
		root.appendChild(next);
	    }
	    doc.appendChild(root);
	}
	catch(Exception e) { }
	return dom;
    }
}
----
====
There are various Java ways to generate XML, including the DOM (Document Object Model) or tree-based method shown in the 
+XmlAllResource+ (line 2), which builds the XML tree out of the +Adages+. This resource is reachable, as the +@Get+ annotation
signals (line 1), only with a GET request.

The +CreateResource+ class (see <<Ex16>>) highlights some nice features of the Restlet API. The argument to the
+create+ method, of Restlet type +Representation+ (line 1), represents the HTTP request body. The Restlet class +Form+ (line 2) makes it
easy to search for specified keys, in this case +words+, with which the corresponding values can be accessed, in this
case the text for the new +Adage+.

[[Ex16]]
.The +CreateResource+ class in the 'adages2' service
====
----
package adages2;

import org.restlet.resource.Post;
import org.restlet.resource.ServerResource;
import org.restlet.representation.Representation;
import org.restlet.representation.StringRepresentation;
import org.restlet.data.Status;
import org.restlet.data.MediaType;
import org.restlet.data.Form;

public class CreateResource extends ServerResource {
    public CreateResource() { }
    @Post
    public Representation create(Representation data) {       <1>
	Status status = null;
	String msg = null;
	// Extract the data from the POST body.
	Form form = new Form(data);                           <2>
	String words = form.getFirstValue("words");
	if (words == null) {
	    msg = "No words were given for the adage.\n";
	    status = Status.CLIENT_ERROR_BAD_REQUEST;
	}
	else {
	    Adages.add(words);
	    msg = "The adage '" + words + "' has been added.\n";
	    status = Status.SUCCESS_OK;
	}
	setStatus(status);
	return new StringRepresentation(msg, MediaType.TEXT_PLAIN);
    }
}
----
====
A JAX-RS resource typically encapsulates several methods, each annotated with a distinct combination of
HTTP verb (for instance, +@GET+ or +@POST+) and URI (that is, +@Path+). In this sense, a JAX-RS resource
class is multi-purpose: its various methods handle various HTTP requests. The Restlet approach differs.
Each resource class is, in best practices, single purpose: one annotated method is the callback for 
an HTTP request targeted at a particular URI. The Restlet resource classes thus tend to be small, as
the 'adages2' service illustrates.

==== Sample Calls against the 'adages2' Service

The RESTful 'adages2' service can be deployed to Tomcat in the usual way:
----
% ant -Dwar.name=adages2 deploy
----
Once the service is deployed, some 'curl' calls can be used to confirm that the service is
behaving correctly. Here is a series of test calls. Each begins with a comment, introduced
with two semicolons, followed by the 'curl' call itself, and ending with the output, which
is formatted for readability.

----
;; GET all in plain text
% curl --request GET http://localhost:8080/adages2/
 1: What can be shown cannot be said. -- 7 words
 2: If a lion could talk, we could not understand him. -- 10 words
 ...
;; GET all in XML
% curl --request GET http://localhost:8080/adages2/xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<adages>
<adage> 1: What can be shown cannot be said. -- 7 words</adage>
<adage> 2: If a lion could talk, we could not understand him. -- 10 words</adage>
...
;; GET all in JSON
% curl --request GET http://localhost:8080/adages2/json
[ 1: What can be shown cannot be said. -- 7 words,  
  2: If a lion could talk, we could not understand him. -- 10 words,  
...
;; GET Adage with id of 2 in XML
% curl --request GET http://localhost:8080/adages2/xml/2
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<adage> 
   2: If a lion could talk, we could not understand him. -- 10 words
</adage>
;; Create a new adage
% curl --request POST --data "words=This is a test" \
  http://localhost:8080/adages2/create
The adage 'This is a test' has been added.
;; Delete the newly added Adage
% curl --request DELETE http://localhost:8080/adages2/delete/6
Adage 6 removed.
----

==== Publishing the 'adages2' Restlet Service without a Web Server
Restlet is excellent at separating concerns: the web service is one concern and its publication is quite another. The
'adages2' service can be deployed with Tomcat or Jetty but also--and with ease--using a standard Java application
(see <<Ex17>>).

[[Ex17]]
.A Java application to publish the Restlet 'adages2' web service
====
----
package adages2;

import org.restlet.Component;                                                  <1>
import org.restlet.data.Protocol;                                              <2>

public class Main {
    public static void main(String[ ] args) throws Exception {  
	// Create a new Component.  
	Component component = new Component();  
	// Add a new HTTP server listening on port 8182.  
	component.getServers().add(Protocol.HTTP, 8182);                       <3>
	// Attach the application.  
	component.getDefaultHost().attach("/adages", new AdagesApplication()); <4>
	// Start the web server.  
	component.start();  
    }          
}
----
====
The two +import+ statements (lines 1 and 2)in +Main+ require only the 'org.restlet.jar' file to compile and
run; but the various Restlet resource classes such as +XmlAllResource+ and
+JsonAllResource+ require other JARs. The command-line server listens for HTTP
connections on port 8182 (line 3) for requests against the URI that begins with '/adages' (line 4).

The ZIP file with the sample applications includes 'Main.jar', an executable JAR file 
that can be used instead of Tomcat or Jetty to publish the service:
----
% java -jar Main
----
The built-in server listens for requests indefinitely and the functionality of the 'adages2' service
is unchanged in this command-line option for publication. For example, here is a request for
the adages in plain text together with the response:
----
% curl localhost:8182/adages/

 1: What can be shown cannot be said. -- 7 words
 2: If a lion could talk, we could not understand him. -- 10 words
 3: Philosophy is a battle against the bewitchment of our intelligence 
    by means of language. -- 14 words
 4: Ambition is the death of thought. -- 6 words
 5: The limits of my language mean the limits of my world. -- 11 words
----
The URI begins with '/adages', in effect the counterpart of the WAR file name under Tomcat or Jetty.
The URI ends with the slash, giving '/adages/', which maps to the +PlainResource+ in the 'adages2' service. 

The command-line option for publishing is nicely suited for development. In a production
environment, a web servers such as Tomcat and Jetty or application servers such as 
GlassFish and WebSphere provide levels of support that a standalone Java application simply cannot 
match.

=== A RESTful Service as a +@WebServiceProvider+
JAX-WS (Java API for XML-Web Services) includes APIs for RESTful and SOAP-based web services, although JAX-WS
seems to be used mostly for the latter. The reference implementation is Metro ('metro.java.net'), which is part of
the GlassFish project. Although JAX-WS technically belongs to enterprise rather than core Java, the core Java JDK (1.6 or
greater) includes enough of the Metro distribution to compile and to publish RESTful and SOAP-based services. JAX-RS and 
Restlet are state-of-the-art, high-level APIs for developing RESTful services; by contrast, the JAX-WS API for RESTful services is low
level. Nonetheless, JAX-WS support for RESTful services deserves a look; and the JAX-WS API for SOAP-based services will be the 
centerpiece in Chapters 4 and 5.

The JAX-WS stack reflects the view that SOAP-based services over HTTP are refinements of RESTful services. The JAX-WS API has two
main annotations. A POJO class annotated as a +@WebService+ delivers a SOAP-based service, whereas
a POJO class annotated as a +@WebServiceProvider+ usually delivers a RESTful one; however, a class annotated as 
a +@WebServiceProvider+ can deliver
a SOAP-based service as well. Yet another revision of the 'adages' RESTful service, 'adages3', introduces the JAX-WS API for
RESTful services.

In the revised 'adages3' service, the +Adage+ and +Adages+ classes are mostly unchanged from the 'adages2' version. One small change
is that the package name goes from +adages2+ to +adages3+; another change is that the +Adage+ list is returned as array, which 
then is serialized into XML.
The +toPlain+ method in the +Adages+ class could be dropped because the revised service deals only in +application/xml+ and not 
in +text/plain+ HTTP payloads.
The +AdagesProvider+ class (see <<Ex18>>) supports the four CRUD operations against the RESTful service.

[[Ex18]]
.The +AdagesProvider+ class that supports the CRUD operations.
====
----
package adages3;

import java.beans.XMLEncoder;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import javax.annotation.Resource;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.WebServiceProvider;
import javax.xml.ws.Provider;
import javax.xml.ws.BindingType;
import javax.xml.ws.http.HTTPBinding;
import javax.xml.ws.ServiceMode;
import javax.xml.ws.http.HTTPException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import org.xml.sax.InputSource;

@WebServiceProvider                             // generic service provider       <1>
@ServiceMode(javax.xml.ws.Service.Mode.MESSAGE) // entire message available       <2>
@BindingType(HTTPBinding.HTTP_BINDING)          // versus SOAP binding            <3>
public class AdagesProvider implements Provider<Source> {
    @Resource
    protected WebServiceContext wctx;  // dependency injection

    public AdagesProvider() { }
    // Implement the Provider interface by defining invoke, which expects an XML 
    // source (perhaps null) and returns an XML source (perhaps null).
    public Source invoke(Source request) {                                        <4>
	if (wctx == null) throw new RuntimeException("Injection failed on wctx.");
	// Grab the message context and extract the request verb.
	MessageContext mctx = wctx.getMessageContext();                           <5>
	String httpVerb = (String) mctx.get(MessageContext.HTTP_REQUEST_METHOD);
	httpVerb = httpVerb.trim().toUpperCase();
	// Dispatch on verb to the handler method. POST and PUT have non-null 
	// requests so only these two get the Source request.
	if      (httpVerb.equals("GET"))    return doGet(mctx);                   <6>
	else if (httpVerb.equals("POST"))   return doPost(request);
	else if (httpVerb.equals("PUT"))    return doPut(request);
	else if (httpVerb.equals("DELETE")) return doDelete(mctx);
	else throw new HTTPException(405);  // bad verb 
    }
    private Source doGet(MessageContext mctx) {
	// Parse the query string.
	String qs = (String) mctx.get(MessageContext.QUERY_STRING);
	// Get all Adages.
	if (qs == null) return adages2Xml();
	// Get a specified Adage.
	else {  
	    int id = getId(qs);
	    if (id < 0) throw new HTTPException(400); // bad request
	    Adage adage = Adages.find(id);
	    if (adage == null) throw new HTTPException(404); // not found
	    return adage2Xml(adage);
	}
    } 
    private Source doPost(Source request) {
	if (request == null) throw new HTTPException(400); // bad request
	InputSource in = toInputSource(request);
	String pattern = "//words/text()"; // find the Adage's "words"
	String words = findElement(pattern, in);
	if (words == null) throw new HTTPException(400); // bad request
	Adages.add(words);
	String msg = "The adage '" + words + "' has been created.";
	return toSource(toXml(msg));
    }
    private Source doPut(Source request) {
	if (request == null) throw new HTTPException(400); // bad request
	InputSource in = toInputSource(request);
	String pattern = "//words/text()";  // find the Adage's "words"
	String words = findElement(pattern, in);
	if (words == null) throw new HTTPException(400); // bad request
	// Format in XML is: <words>!<id>
	String[ ] parts = words.split("!");
	if (parts[0].length() < 1 || parts[1].length() < 1)
	    throw new HTTPException(400); // bad request
	int id = -1;
	try {
	    id = Integer.parseInt(parts[1].trim());
	}
	catch(Exception e) { throw new HTTPException(400); } // bad request
	// Find and edit.
	Adage adage = Adages.find(id);
	if (adage == null) throw new HTTPException(404); // not found
	adage.setWords(parts[0]);
	String msg = "Adage " + adage.getId() + " has been updated.";
	return toSource(toXml(msg));
    }
    private Source doDelete(MessageContext mctx) {
	String qs = (String) mctx.get(MessageContext.QUERY_STRING);
	// Disallow the deletion of all teams at once.
	if (qs == null) throw new HTTPException(403); // illegal operation
	else {
	    int id = getId(qs);
	    if (id < 0) throw new HTTPException(400); // bad request
	    Adage adage = Adages.find(id);
	    if (adage == null) throw new HTTPException(404); // not found
	    Adages.remove(adage);
	    String msg = "Adage " + id + " removed.";
	    return toSource(toXml(msg));
	}
    }
    private int getId(String qs) {
	int badId = -1; // bad ID
	String[ ] parts = qs.split("=");
	if (!parts[0].toLowerCase().trim().equals("id")) return badId;
	int goodId = badId; // for now
	try {
	    goodId = Integer.parseInt(parts[1].trim());
	}
	catch(Exception e) { return badId; }
	return goodId;
    }
    private StreamSource adages2Xml() {
	String str = toXml(Adages.getListAsArray());
	return toSource(str);
    }
    private StreamSource adage2Xml(Adage adage) {
	String str = toXml(adage);
	return toSource(str);
    }
    private String toXml(Object obj) {
	ByteArrayOutputStream out = new ByteArrayOutputStream();
	XMLEncoder enc = new XMLEncoder(out);
	enc.writeObject(obj);
	enc.close();
	return out.toString();
    }
    private StreamSource toSource(String str) {
	return new StreamSource(new StringReader(str));
    }
    private InputSource toInputSource(Source source) {
	InputSource input = null;
	try {
	    Transformer trans = TransformerFactory.newInstance().newTransformer();
	    ByteArrayOutputStream bos = new ByteArrayOutputStream();
	    StreamResult result = new StreamResult(bos);
	    trans.transform(source, result);
	    input = new InputSource(new ByteArrayInputStream(bos.toByteArray()));
	}
	catch(Exception e) { throw new HTTPException(500); } // internal server error
	return input;
    }
    private String findElement(String expression, InputSource source) {
	XPath xpath = XPathFactory.newInstance().newXPath();
	String retval = null;
	try {
	    retval = (String) xpath.evaluate(expression, source, XPathConstants.STRING);
	}
	catch(Exception e) { throw new HTTPException(400); } // bad request
	return retval;
    }
}
----
====
Even at a glance at the +AdagesProvider+ code looks low level. Much of this code transforms one type
to another, for example, a +Source+ to an +InputSource+ or an +Adage+ to a
+StreamSource+. The +Source+ types are 'sources of XML'. The JAX-P (Java API for XML-Processing)
packages, used in the the 'adages3' service, support 'transforms' that convert a 'source' into a 'result' (see <<transform>>).
[[transform]]
.A JAX-P transform.
====
----
                 +-----------+
Source of XML--->| transform |--->Result 
                 +-----------+
----
====
For example, a generic +Source+ might be
transformed into a specific type such as +StreamResult+. The need for such transformations in the 'adages3' service is 
explained shortly. 
First, however, it will helpful to consider the overall structure of the +AdagesProvider+.

Three annotations adorn the +AdagesProvider+ class:

* +@WebServiceProvider+ (line 1) indicates that the +AdagesProvider+ class implements a templated +Provider+ interface,
in this case a +Provider<Source>+ interface, where +Source+ is a source precisely of XML. The templated
+Provider+ interface requires that the implementing class define the method
+
----
public Source invoke(Source input) { /*...*/ }
----
+
This method expects a +Source+ of XML as an argument and returns a +Source+ of XML.
The +AdagesProvider+ class defines the +invoke+ method (line 2), which is the target of every HTTP request against the 
'adages3' service. The +invoke+ method implements a simple routing table. After extracting the HTTP
verb from the incoming request, using the +MessageContext+ map (line 5) that the run-time provides, the +invoke+
method calls one of four +AdagesProvider+ methods (line 6), each of which 
returns a +Source+ of XML for the HTTP response body:
+
----
// mctc --> MessageContext, request --> Source
if      (httpVerb.equals("GET"))    return doGet(mctx);    
else if (httpVerb.equals("POST"))   return doPost(request);
else if (httpVerb.equals("PUT"))    return doPut(request);
else if (httpVerb.equals("DELETE")) return doDelete(mctx);
else throw new HTTPException(405);  // bad verb 
----
+
This table mimics, in the method names, an +HttpServlet+ with its encapsulated +doGet+, +doPost+,
+doPut+, and +doDelete+ methods. The difference here is that each 'do' method takes only one argument. The
GET and DELETE have no bodies, which means that the incoming +Source+ is empty. In any case, the 
+doGet+ and +doDelete+ methods need only information in the query string, which is stored in the
HTTP headers; hence, +doGet+ and +doDelete+ are passed the +MessageContext+ as the argument. By contrast,
the +doPost+ and +doPut+ methods require information in the HTTP request body, a non-empty +Source+; and
these methods therefore are passed the request +Source+ as their single argument.

* The +@ServiceMode+ annotation (line 2) has two possible values: +MESSAGE+ (the entire request message) or
+PAYLOAD+ (the body, if any, of the request message). The 'adages3' service needs access to both
the HTTP headers and, for POST and PUT requests, the HTTP body; hence, the service mode is 
+MESSAGE+.

* The +@BindingType+ (line 3) refers to the type of payload in an HTTP message. The default type is
SOAP, which means that the body of an HTTP message (for instance, a POST request or any response) 
is a SOAP document. The +AdagesProvider+ specifies an HTTP binding, which means that the
HTTP payload is to be arbitrary XML, not exclusively the SOAP variant of XML. Even with this
binding type, however, a SOAP document could be a payload because SOAP still counts as XML.

This overview should help in the more detailed analysis that follows. In the 'adages3' service, 
the +doGet+ method needs to handle two cases:

* If there is no query string, this method assumes that the client means 'read all' with the
GET request. In this case, the entire list of adages, encoded as XML using the +XMLEncoder+,
is returned.

* If there is a query string, it should have a key/value pair such as
+
----
id=4
----
+
where 4 is then interpreted as the +id+ of the single message to be returned. Here, for quick review,
is the +doGet+ method:
+
----
private Source doGet(MessageContext mctx) {
    // Parse the query string.
    String qs = (String) mctx.get(MessageContext.QUERY_STRING);
    if (qs == null) return adages2Xml(); // all adages                  <1>
    else {                               // one adage
        int id = getId(qs);                                    
        if (id < 0) throw new HTTPException(400); // bad request
        Adage adage = Adages.find(id);
        if (adage == null) throw new HTTPException(404); // not found
        return adage2Xml(adage);
    }
}     
----
+
Utility methods such as +adages2Xml+ (line 1) handle the transformation of +Adage+ objects
into XML documents (text), which in turn are transformed into +StreamSource+ instances sent back
to the client.

The +doPost+ method is:
----
private Source doPost(Source request) {
    if (request == null) throw new HTTPException(400); // bad request
       InputSource in = toInputSource(request);                         <1>
       String pattern = "//words/text()"; // find the Adage's "words"   <2>
       String words = findElement(pattern, in);
       if (words == null) throw new HTTPException(400); // bad request
       Adages.add(words);
       String msg = "The adage '" + words + "' has been created.";
       return toSource(toXml(msg));
}
----
This method relies on utility methods, in particular on the tricky +toInputSource+ method (line 1) that 
transforms a +Source+ request, which is likely but not necessarily a +StreamSource+,
into an +InputSource+. The reason is that, for convenience, the +doPost+ method uses
an +XPath+ instance to search the incoming XML document for the +words+ in the +Adage+
to be created. For example, the XMl document might look like this in a POST request:
----
<ns1:foo xmlns:ns1='http://sample.org'>
   <words>This is the way the world ends.</words>
</ns1:foo>
----
An +XPath+ search requires a pattern, in this example (line 2):
---- 
//words/text()
----
The two opening slashes mean 'anywhere in the document' and the specific search term is
the literal +words+. The +text()+ at the end signals +XPath+ to return the text node in the
XML document that contains the new adage, in this case the phrase 
----
This is the way the world ends.
----
The search is flexible in that the XML tag 'words' could be anywhere in the document, in
this example nested inside the root element named 'ns1:foo'. Now let me get back to the 
point about needing to transform a +Source+ into an +InputSource+. The +XPath+ method
+evaluate+ searches an XML document for a pattern such as '//words' but requires, as
a second argument, an +InputSource+; hence, the transformation of the incoming but
generic +Source+ to an +InputSource+ sets up the +XPath+ search. There are other ways in
which the +XPath+ search might be supported but any of these would require a
transformation of some kind.

The +doPut+ method in the +AdagesProvider+ class is
similar in structure to the +doPost+ method because, of course, creating a new 
+Adage+ (POST) and updating an existing one (PUT) are similar operations. However, the
+doPut+ implementation allows only the +words+ of the +Adage+ to be changed; the +id+
property, which the +Adages+ class manages, cannot be changed through a PUT operation.

.Publishing the 'adages3' service with Tomcat and +Endpoint+ 
[options="header"]
****
With core Java 1.6 or greater, publishing a +@WebServiceProvider+ service (and, for that
matter, a SOAP-based +@WebService+) from the command-line requires very little code. Here is a sample
publisher, included in the ZIP with the sample code:
----
package adages3;

import javax.xml.ws.Endpoint;
public class Publisher {
   public static void main(String[ ] args) {
      int port = 8888;
      String url = "http://localhost:" + port + "/";
      System.out.println("Restfully publishing on port " + port);
      Endpoint.publish(url, new AdagesProvider());
   }
}
----
Once published, the +AdagesProvider+ service awaits requests indefinitely on port 8888. For
example, the request
----
% curl localhost:8888/?id=3
----
elicits the response
----
<java version="1.7.0" class="java.beans.XMLDecoder"> 
 <object class="adages3.Adage"> 
  <void property="id"> 
   <int>3</int> 
  </void> 
  <void property="wordCount"> 
   <int>14</int> 
  </void> 
  <void property="words"> 
   <string>
     Philosophy is a battle against the bewitchment of our intelligence 
     by means of language.
   </string> 
  </void> 
 </object> 
</java>
----
Publishing with Tomcat or Jetty is likewise straightforward, although two configuration files
are needed: the usual 'web.xml' and the additional 'sun-jaxws.xml'. Here is the 'web.xml' for the 'adages3'
service:
----
<?xml version="1.0" encoding="UTF-8"?>
<web-app>
  <listener>
    <listener-class>
      com.sun.xml.ws.transport.http.servlet.WSServletContextListener   <1>
    </listener-class>
  </listener>
  <servlet>
    <servlet-name>jaxws</servlet-name>
    <servlet-class>
      com.sun.xml.ws.transport.http.servlet.WSServlet
    </servlet-class>                                                   <2>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>jaxws</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----
The Metro classes +WSServletContextListener+ (line 1) and +WSServlet+ (line 2) are in the JAR file 
currently named 'webservices-rt.jar', which can be downloaded with the rest of Metro 
JARs from 'metro.java.net'. The JAR in question should be in the 'src' directory so that
the Ant script can package this JAR in the deployed WAR file. In any case, the
+WSServletContextListener+ parses the 'sun-jaxws.xml' file, with more details shortly.
The +WSServlet+ acts the interceptor: the servlet receives incoming requests and 
dispatches these to the +AdagesProvider+ service. This architecture is quite similar
to the Restlet version.

The second configuration file, 'sun-jaxws.xml', is:
----
<?xml version="1.0" encoding="UTF-8"?>
<endpoints version="2.0" 
           xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"> <1>
  <endpoint implementation="adages3.AdagesProvider"              <2> 
	    name="AdagesProvider" 
	    url-pattern="/*"/>
</endpoints>
----
This file completes the routing by notifying the +WSServletContextListener+ that
the +WSServlet+ should dispatch requests to an +AdagesProvider+ instance (line 2). By the
way, the +xmlns+ attribute in the +endpoints+ element (line 1) is important and should not
be changed or omitted.

With the two configuration files and the Metro library JAR in the 'src'
directory, the 'adages3' service can be deployed to Tomcat in the usual way:
----
% ant -Dwar.name=adages3 deploy
----
Sample requests then can be sent to the service
----
% curl localhost:8080/adages3?id=3
----
****

The JAX-WS +@WebServiceProvider+ is a low-level, XML-centric API. Java is well known for providing 
options; and this API is among the Java options for delivering REST-style services. Chapter 7 introduces
the client-side API, based on the +Dispatch+ interface, for RESTful services implemented with
+@WebServiceProvider+.

=== What's Next?

This chapter has focused on programming and publishing RESTful services; the next chapter focuses on
the client side, that is, on consuming such services. Some of the sample clients make requests
against major RESTful sites such as Amazon and Twitter, whereas others make requests against the services developed
in this chapter. Once again the goal is to illustrate, with working code, the various client-side APIs
at the Java programmer's disposal.

Four different APIs were considered in this chapter but these APIs fall into three general groups:

* The +HttpServlet+ API, which has been around since the late 1990s, remains an excellent way to 
implement RESTful services. Servlets are HTTP-aware and provide convenient filtering of requests by
HTTP verb. Programmers accustomed to implementing web sites with servlets, JSP and related scripting
languages such as JSF or Struts, should find servlets a natural and appealing way to deliver web
services as well. The servlet API is at once uncomplicated and powerful.

* The JAX-RS and Restlet APIs take full advantage of Java annotations to advertise the RESTful
aspects of implemented services. These frameworks integrate well with JAX-B technologies to
automate the conversion of Java types into XML and JSON documents. JAX-RS and Restlet services,
like servlet-based servlets, can be published with production-grade web servers such as Tomcat
and Jetty. These APIs also mimic the routing idioms that have become so popular because of
frameworks such as Rails and Sinatra.

* The JAX-WS API, with the +@WebServiceProvider+ at its center, is lower level than the other 
options but well suited for programmers who need to be close to the HTTP and XML metal.
This API is sufficiently rich to deliver real-world RESTful services; but the rival APIs are
more appealing in that they hide many of the details that a JAX-WS service must handle
explicitly. For SOAP-based services, the JAX-WS API is as good as any and will be the
focus in Chapters 4 and 5.












<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#ch06webservicessecurity">1. Web Services Security</a></span></dt><dd><dl><dt><span class="section"><a href="#_overview_of_web_services_security">1.1. Overview of Web Services Security</a></span></dt><dt><span class="section"><a href="#_wire_level_security">1.2. Wire-Level Security</a></span></dt><dt><span class="section"><a href="#_a_very_lightweight_https_server_and_client">1.3. A Very Lightweight HTTPS Server and Client</a></span></dt><dt><span class="section"><a href="#_https_in_a_production_grade_web_server">1.4. HTTPS in a Production-Grade Web Server</a></span></dt><dt><span class="section"><a href="#_container_managed_security">1.5. Container-Managed Security</a></span></dt><dt><span class="section"><a href="#_ws_security">1.6. WS-Security</a></span></dt><dt><span class="section"><a href="#_what_8217_s_next">1.7. What’s Next?</a></span></dt></dl></dd></dl></div><div class="section" title="1. Web Services Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06webservicessecurity"></a>1. Web Services Security</h2></div></div></div><div class="section" title="1.1. Overview of Web Services Security"><div class="titlepage"><div><div><h3 class="title"><a id="_overview_of_web_services_security"></a>1.1. Overview of Web Services Security</h3></div></div></div><p>Security for web services covers a lot of territory, which cannot be explored all at once. To make the exploration more
manageable, it seems best to analyze small chunks, one at a time, before pulling the exploration results together.
Here is a sketch of how this chapter breaks up the broad topic of security into smaller pieces:</p><div class="variablelist"><dl><dt><span class="term">
Wire-level security
</span></dt><dd>
Security begins at the transport or wire level, that is, with basic protocols that govern communications
between a web service, whether SOAP-based or REST-style, and its clients. Security at this level typically provides three services.
First, the client and service need transport-level assurance that each is communicating with the other rather than with some impostor.
Second, the data sent from one side to the other need to be encrypted strongly enough so that an interceptor cannot decrypt the data
and thus gain access to the confidential information carried therein. Third, each side needs assurance that the received
message is the same as the sent
message. This chapter covers the basics of wire-level security with code examples, most of which focus on HTTPS as a
provider of wire-level security.
</dd><dt><span class="term">
User authentication and authorization
</span></dt><dd>
Web services provide clients with access to resources. If a resource is secured,
then a client needs the appropriate credentials to gain access. The credentials are presented and verified through a process
that usually has two phases. In the first phase, a client (user) presents information such as a username together with a credential
such as a password.
If the credential is not accepted, access to the requested resource is denied. The first phase is known as <span class="emphasis"><em>user authentication</em></span>.
The second phase, which is optional, consists of fine-tuning the authenticated subject’s access rights.
For example, a stock-picking web service might provide all paying customers with a username and password; but the service might divide the
customers into categories, for instance, <span class="emphasis"><em>regular</em></span> and <span class="emphasis"><em>premier</em></span>. Access to certain resources might be restricted
to <span class="emphasis"><em>premier</em></span> clients. The second phase
is known as <span class="emphasis"><em>role authorization</em></span>. This chapter introduces users-role security, a common name for the two-phase process.
</dd><dt><span class="term">
WS-Security
</span></dt><dd>
WS-Security, or WSS for short, is a collection of protocols that specify how different levels of
security can be enforced within the SOAP-messaging infrastructure rather than through a particular transport (for instance,
HTTPS) or through a particular service container (for instance, Tomcat). For example, WSS specifies
how digital signatures
and encryption information can be inserted into SOAP headers. If SOAP-based services are to be
transport-neutral, then various security features must be built into SOAP itself.
Accordingly, WSS is meant to provide comprehensive end-to-end security regardless of the
underlying transport and regardless of the container that hosts the service.
This chapter introduces WS-Security with an example.
</dd></dl></div></div><div class="section" title="1.2. Wire-Level Security"><div class="titlepage"><div><div><h3 class="title"><a id="_wire_level_security"></a>1.2. Wire-Level Security</h3></div></div></div><p>Consider a pay-for web service such as Amazon’s S3 storage service. This service needs to authenticate
requests to store and retrieve data so that only the paying clients have access to the service and that, moreover,
a particular client has privileged access to its paid-for storage. In the RESTful version of S3, Amazon uses a customization
of keyed HMAC (Hash Message Authentication Code) to authenticate client requests. Amazon allows the authentication
credential to be in either the query string (which is part of the HTTP headers) or in another header key/value pair
with <code class="literal">Authorization</code> as the key. In either case, the basic approach is the same:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Parts of the request data are concatenated together to form a single string, which becomes the input value for a hash computation.
This string is the <span class="emphasis"><em>input message</em></span>.
</li><li class="listitem">
The AWS (Amazon Web Services) <span class="emphasis"><em>secretKey</em></span>, a unique bit string that Amazon provides to each client and which has been discussed
with respect to clients against the Amazon E-Commerce service, is used to
compute the hash value of the <span class="emphasis"><em>input message</em></span> (see <a class="xref" href="#fig5_digest" title="Figure 1. A message digest">Figure 1, “A message digest”</a>). A hash value is also called a <span class="emphasis"><em>message digest</em></span>,
which is a fixed-length digest of arbitrarily many input bits. For the S3 service Amazon uses the SHA-1 (Secure Hash Algorithm-1)
version of HMAC, which produces a 160-bit digest no matter what the bit length of the input may be. Amazon calls this hash value
the <span class="emphasis"><em>signature</em></span> because the value functions like a digital signature, although technically a digital signature is an <span class="emphasis"><em>encrypted</em></span>
message digest. What Amazon calls the <span class="emphasis"><em>signature</em></span> is not encrypted but is encoded in base64.
</li></ul></div><div class="figure"><a id="fig5_digest"></a><p class="title"><b>Figure 1. A message digest</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0501.png" alt="images/jwsu_0501.png" /></div></div></div><br class="figure-break" /><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The Amazon signature is added to the request in the HTTP 1.1 <code class="literal">Authorization</code> header (or the query string).
</li><li class="listitem">
Upon receipt of the request, the Amazon S3 first validates the Amazon signature and then honors the request
only if the validation succeeds. Essentially this is the same validation process used in the <span class="emphasis"><em>predictionsSOAP</em></span> example of Chapter 5.
</li></ul></div><p>What prevents a client’s request to Amazon S3 from being intercepted and the value of its
<code class="literal">Authorization</code> header, the Amazon authentication signature, from being pirated? Amazon assumes that the request is sent over the
secure communications channel that HTTPS (HyperText Transport Protocol Secure) provides. HTTPS is HTTP
with an added security layer. Netscape did the original work in the design and implementation of this security layer and called
it SSL (Secure Sockets Layer). The IETF (International Engineering Task Force) has taken over SSL and renamed it to TLS
(Transport Layer Security). Although SSL and TLS differ in version numbers and in some technical details, they will be
treated as basically the same here. In any case, it is common to use SSL, TLS, and SSL/TLS interchangeably.</p><p>Java has various packages that support SSL/TLS in general and HTTPS in particular. The JSSE (Java Secure Sockets Extension) API,
which covers the packages <code class="literal">javax.net</code> and <code class="literal">javax.net.ssl</code>, has been
part of core Java since JDK 1.4. Of interest here is that higher levels of security, such as user authentication, usually
require wire-level security of the kind that HTTPS provides. Accordingly, the discussion of web services security begins with HTTPS
and the wire-level security that this protocol provides.</p><div class="section" title="1.2.1. HTTPS Basics"><div class="titlepage"><div><div><h4 class="title"><a id="_https_basics"></a>1.2.1. HTTPS Basics</h4></div></div></div><p>HTTPS is easily the most popular among the secure versions of HTTP. HTTPS provides three critical
security services over and above the transport services that HTTP provides. The following is a summary of
the three (see <a class="xref" href="#fig_05_alicebob" title="Figure 2. A secret message from Bob to Alice despite Eve">Figure 2, “A secret message from Bob to Alice despite Eve”</a>). In the figure, Alice needs to send a secret message to
Bob. Eve, however, may be eavesdropping. Eve may try to dupe Alice and Bob into believing that they are
communicating with one another when, in fact, each is communicating instead with Eve. This scenario is known as
the MITM (Man In The Middle) attack. For secure communications, Alice and Bob thus need these three services:</p><div class="variablelist"><dl><dt><span class="term">
Peer authentication
</span></dt><dd>
Alice needs Bob to authenticate himself so that she is sure about who is on the receiving end before
she sends the secret message. Bob, too, needs Alice to authenticate herself so that he knows that the secret message is
from her rather than an impostor such as Eve. This step also is described as <span class="emphasis"><em>mutual authentication</em></span> or <span class="emphasis"><em>mutual challenge</em></span>.
</dd><dt><span class="term">
Confidentiality
</span></dt><dd>
Once Alice and Bob have authenticated each other, Alice needs to encrypt the secret message in such a
way that only Bob can decrypt it. Even if Eve intercepts the encrypted message, Eve should not be able to decrypt the
message because doing so requires enormous computational power or incredibly good luck.
</dd><dt><span class="term">
Integrity
</span></dt><dd>
The message that Alice sends should be identical to the one that Bob receives. If not, an error condition
should be raised. The received message might differ from the sent one for various reasons; for instance, noise in the
communications channel or deliberate tampering on Eve’s part. Any difference between the sent and the received message should be detected.
</dd></dl></div><div class="figure"><a id="fig_05_alicebob"></a><p class="title"><b>Figure 2. A secret message from Bob to Alice despite Eve</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0502.png" alt="images/jwsu_0502.png" /></div></div></div><br class="figure-break" /><p>These features can be implemented in different ways. Before considering how HTTPS implements the three features,
it will be useful to look briefly at data encryption and decryption because <span class="emphasis"><em>confidentiality</em></span> is among the three
services that HTTPS provides.</p></div><div class="section" title="1.2.2. Symmetric and Asymmetric Encryption/Decryption"><div class="titlepage"><div><div><h4 class="title"><a id="_symmetric_and_asymmetric_encryption_decryption"></a>1.2.2. Symmetric and Asymmetric Encryption/Decryption</h4></div></div></div><p>Modern approaches to encryption follow two different approaches, symmetric and asymmetric. Under either approach,
the bits to be encrypted (<span class="emphasis"><em>plain bits</em></span>) are one input to an encryption engine and an encryption <span class="emphasis"><em>key</em></span> is the other
input (see <a class="xref" href="#fig_05_encrypt" title="Figure 3. Basic encryption and decryption">Figure 3, “Basic encryption and decryption”</a>).</p><div class="figure"><a id="fig_05_encrypt"></a><p class="title"><b>Figure 3. Basic encryption and decryption</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0503.png" alt="images/jwsu_0503.png" /></div></div></div><br class="figure-break" /><p>The encrypted bits are the <span class="emphasis"><em>cipher bits</em></span>. If the input bits represent text, then they are the <span class="emphasis"><em>plaintext</em></span> and the output bits are
the <span class="emphasis"><em>ciphertext</em></span>. The cipher bits are one input to the decryption engine; and a decryption key is the other input.
The decryption produces the original plain bits. In the symmetric approach, the <span class="emphasis"><em>same</em></span> key—called the <span class="emphasis"><em>secret</em></span>  or the
<span class="emphasis"><em>single</em></span> key—is used to encrypt and to
decrypt (see <a class="xref" href="#fig_05_symmetric" title="Figure 4. Single key encryption and decryption">Figure 4, “Single key encryption and decryption”</a>). The symmetric approach has the advantage of being relatively fast but the disadvantage
of what is known as the <span class="emphasis"><em>key distribution problem</em></span>. How is the secret key itself to be distributed to the sender and the receiver?</p><div class="figure"><a id="fig_05_symmetric"></a><p class="title"><b>Figure 4. Single key encryption and decryption</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0504.png" alt="images/jwsu_0504.png" /></div></div></div><br class="figure-break" /><p>In the asymmetric approach, the starting point is a <span class="emphasis"><em>key pair</em></span>, which consists of a <span class="emphasis"><em>private key</em></span> and a <span class="emphasis"><em>public key</em></span>.
As the names suggest, the private key should not be distributed but, rather, safeguarded by whoever generated the key pair.
The public key can be distributed freely and publicly. If message bits are encrypted with the public key, they
can be decrypted only with the private key—and vice-versa. <a class="xref" href="#fig_05_asymmetric" title="Figure 5. Public key encryption and decryption">Figure 5, “Public key encryption and decryption”</a> illustrates. The asymmetric
approach solves the key distribution problem; but asymmetric encryption and decryption are roughly a thousand times
slower than their symmetric counterparts.</p><div class="figure"><a id="fig_05_asymmetric"></a><p class="title"><b>Figure 5. Public key encryption and decryption</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0505.png" alt="images/jwsu_0505.png" /></div></div></div><br class="figure-break" /><p>The public key approach solves the confidentiality problem for Alice and Bob. If Alice encrypts the message with the public key
from Bob’s key pair, and Bob has the only copy of the private key from this pair, then only Bob can decrypt the message.
Even if Eve intercepts Alice’s message, she cannot decrypt the message with Bob’s public key.</p></div><div class="section" title="1.2.3. How HTTPS Provides the Three Security Services"><div class="titlepage"><div><div><h4 class="title"><a id="_how_https_provides_the_three_security_services"></a>1.2.3. How HTTPS Provides the Three Security Services</h4></div></div></div><p>Of the three required security services—peer authentication, confidentiality, and integrity—the last is the
least complicated. The message sent over HTTPS includes a digest value, which the receiver recomputes. If the sent
digest value differs from the digest value that the receiver computes, then the message was altered during transmission,
either by accident or design. If the sent digest value itself is altered during transmission, this likewise counts as integrity failure.</p><p>HTTPS handles peer authentication through the exchange of digital certificates. In many cases, however, it is
only the client that challenges the server. Consider a typical web-site application in which a shopper finalizes an order
for the contents of his shopping cart by submitting a credit card number to the vendor. Here is a summary of what typically
happens when the client-side browser and the web server negotiate to set up an HTTPS connection:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The customer’s browser challenges the vendor’s web server to authenticate itself; and the server
responds by sending one or more digital certificates to the browser.
</li><li class="listitem"><p class="simpara">
The browser checks the web server’s digital certificates against the browser’s <span class="emphasis"><em>truststore</em></span>,
which is a database of digital certificates that the browser trusts. The browser’s validation of an
incoming certificate can be and, for practical reasons, typically is indirect. For example, suppose that
the browser receives a certificate from Amazon but does not have an Amazon certificate in its truststore.
Suppose further that the Amazon certificate contains a vouching signature from VeriSign, a well-known
certificate authority (CA). If the browser’s truststore has a VeriSign certificate, then the browser
can use the VeriSign certificate to validate the VeriSign signature on the Amazon certificate.
</p><p class="simpara">How is the VeriSign certificate to be verified? For the verification process
to terminate, at least one certificate in the chain must be taken as verified.
For now the point of
interest is that the browser’s truststore is its repository of certificates that are used to verify
incoming certificates. If the browser cannot validate an incoming certificate against its truststore, then
the browser typically asks the human user whether the certificate should be trusted this time only or permanently.
If the user selects <span class="emphasis"><em>permanently</em></span>, the browser adds the certificate to its truststore.</p></li><li class="listitem">
The web server typically does <span class="emphasis"><em>not</em></span> challenge the browser. For one thing, the web site is interested in
the shopper’s credit card rather than in the identity of the user agent (in this case, the browser) that
the shopper happens to be using. In web services as opposed to web sites, two-way or peer authentication is
common.
</li></ul></div><p>The usually one-sided authentication challenge at play in web sites, with the client challenging the server
but not the other way around, shows up in Tomcat’s configuration file, <span class="emphasis"><em>TOMCAT_HOME/conf/server.xml</em></span>. Here is the entry for HTTPS:</p><pre class="screen">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false"   <a id="CO1-1"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
           sslProtocol="TLS"/&gt;</pre><p>The <code class="literal">clientAuth</code> attribute is set to <code class="literal">false</code> (line 1), thereby indicating that Tomcat does not challenge the client.
If the <code class="literal">clientAuth</code> attribute were set to <code class="literal">true</code>, then Tomcat would challenge the client’s user agent; and a setting
of <code class="literal">true</code> might be of interest for web services in particular. In this configuration file,
there is no setting for a <code class="literal">serverAuth</code> because the default client behavior is to challenge the server.</p></div><div class="section" title="1.2.4. The HTTPS Handshake"><div class="titlepage"><div><div><h4 class="title"><a id="_the_https_handshake"></a>1.2.4. The HTTPS Handshake</h4></div></div></div><p>For authentication and confidentiality, HTTPS relies on digital certificates, which are widely used in public key
cryptography precisely because the exchange of secret keys is so difficult among many users. Here is a summary of how
HTTPS authentication is intertwined with HTTPS confidentiality. The process is sometimes described as the <span class="emphasis"><em>handshake</em></span>
between client and server that culminates in a secure network connection. In this scenario, the client might be a
browser or an application functioning as a web service client. For convenience, the term <span class="emphasis"><em>web server</em></span> covers both a
standard web-site server such as Tomcat or a full-bodied
Java Application Server such as Oracle WebLogic, GlassFish, JBoss, or WebSphere:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The client challenges the web server, which sends one or more digital certificates as authentication. Modern digital
certificates usually have the X.509 format. The current X.509 version is named v3.
</li><li class="listitem">
An X.509 certificate is a <span class="emphasis"><em>public key certificate</em></span> that serves as an <span class="emphasis"><em>identity certificate</em></span> by binding the public key from
a key pair to an identity such as a person (for instance, Alice) or an organization (for instance, Bob’s employer).
The certificate contains the digital signature of a CA such as a VeriSign, although certificates can be self-signed for
testing purposes. In signing a digital certificate, a CA endorses the certificate and thereby verifies that the certificate’s
public key is bound to a particular identity. For instance, VeriSign signs Alice’s certificate and thereby verifies that the
certificate’s public key belongs to Alice’s key pair.
</li><li class="listitem">
The client can determine whether to accept the server’s digital certificates by checking these against its truststore.
The check can be direct or indirect. In a direct check, the received digital certificate is checked against a copy
in the truststore. In an indirect check, the CA’s digital signature, which occurs as part of the certificate and vouches
for its legitimacy, needs to be verified; and this verification, in turn, requires a digital certificate from the CA.
</li><li class="listitem">
The server has the option of challenging the client. For a web site, such a challenge is unusual; for a web service,
such a challenge can serve as a way of identifying and authenticating the web-service client.
</li><li class="listitem">
Once the challenge phase is over, the client begins the process of generating a secret key. The process begins with the
client’s generation of a <span class="emphasis"><em>pre-master secret</em></span>, a string that is shared with the server. The pre-master is then used
on each side to generate the same <span class="emphasis"><em>master</em></span> secret key, which is used to encrypt and decrypt the traffic between the
client and the server. At issue here is how the pre-master secret is sent securely from the client to the server.
</li><li class="listitem">
In a common scenario, the client encrypts a 48-bit pre-master secret with the server’s public key, available on the server’s
digital certificate downloaded during the peer authentication phase. The encrypted pre-master secret is sent to
the server, which decrypts the secret. If everything is still in order, each side confirms that encryption of traffic
between them is to begin. The <span class="emphasis"><em>public key</em></span>/<span class="emphasis"><em>private key</em></span> pair is thus critical in solving the key distribution problem for secret keys.
</li><li class="listitem">
At any point, either the client or the server may insist on starting the entire process all over again. For example,
if either Alice or Bob suspects that Eve is up to no good, either Alice or Bob can restart the handshake process.
</li></ul></div><p>A secret key is used to encrypt and decrypt traffic for several reasons. First, symmetric encryption has relatively high
performance. Second, if the server does not challenge the client, then the server does not have the client’s public
key to encrypt messages to the client. The server cannot encrypt messages with its own private key, as any receiver (for instance, Eve)
with access to the server’s public key then could decrypt the message. Finally, encrypting and decrypting with two
separate key pairs is inherently trickier—and significantly slower—than using a shared secret key.</p><p>The primary challenge is to get the pre-master secret securely from the client to the server; and the server’s public key,
available to the client in the server’s digital certificate after the mutual challenge phase, fits the bill
perfectly. The master secret key is generated only after the client and the server have agreed upon which <span class="emphasis"><em>cipher suite</em></span>, or
set of cryptographic algorithms, should
be used. A cipher suite, including a key-pair algorithm and a hash algorithm, will be examined through a code example shortly.</p><p>Although digital certificates now play a dominant role in mutual challenge scenarios, they are not the only game in town.
For example, SRP (Secure Remote Protocol) implements mutual challenge but without digital certificates. For more on SRP, see
<span class="emphasis"><em>srp.stanford.edu</em></span>.</p></div><div class="section" title="1.2.5. The HttpsURLConnection Class"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_httpsurlconnection_literal_class"></a>1.2.5. The <code class="literal">HttpsURLConnection</code> Class</h4></div></div></div><p>It is time to flesh out these architectural sketches with a code example. The class <code class="literal">HttpsURLConnection</code>, which extends the
<code class="literal">HttpURLConnection</code> class, supports HTTPS connections. The <code class="literal">GoogleClient</code> application (see <a class="xref" href="#google_client" title="Example 1. A client that makes an HTTPS connection to Google.">Example 1, “A client that makes an HTTPS connection to Google.”</a>) uses this class
to issue a GET request under HTTPS against Google’s home site. Note that the port number in the
URL is 443 (line 1), the standard
port for HTTPS connections.</p><div class="example"><a id="google_client"></a><p class="title"><b>Example 1. A client that makes an HTTPS connection to Google.</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import java.net.MalformedURLException;
import java.security.cert.Certificate;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class GoogleClient {
    private static final String endpoint = "https://www.google.com:443/";         <a id="CO1-2"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />

    // Send a GET request and print the response status code.
    public static void main(String[ ] args) {
        new GoogleClient().doIt();
    }
    private void doIt() {
        try {
            URL url = new URL(endpoint);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();  <a id="CO1-3"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            conn.setDoInput(true);
            conn.setRequestMethod("GET");                                         <a id="CO1-4"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            conn.connect();
            dumpDetails(conn);
        }
        catch(MalformedURLException e) { System.err.println(e); }
        catch(IOException e) { System.err.println(e); }
    }
    private void dumpDetails(HttpsURLConnection conn) {
        try {
            print("Status code:  " + conn.getResponseCode());                     <a id="CO1-5"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            print("Cipher suite: " + conn.getCipherSuite());                      <a id="CO1-6"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
            Certificate[ ] certs = conn.getServerCertificates();                  <a id="CO1-7"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            for (Certificate cert : certs) {
                print("\tCert. type: " + cert.getType());
                print("\tHash code:  " + cert.hashCode());                        <a id="CO1-8"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
                print("\tAlgorithm:  " + cert.getPublicKey().getAlgorithm());     <a id="CO1-9"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
                print("\tFormat:     " + cert.getPublicKey().getFormat());        <a id="CO1-10"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
                print("");
            }
        }
        catch(Exception e) { System.err.println(e); }
    }
    private void print(Object s) { System.out.println(s); }
}</pre></div></div><br class="example-break" /><p>The endpoint URL for an HTTPS connection to Google begins with <code class="literal">https</code> (known in HTTP as the <span class="emphasis"><em>scheme</em></span>) and the
port number, <code class="literal">443</code>, is the standard one for HTTPS connections. Modern web servers typically accept HTTP connections
on port 80 and HTTPS connections on port 443, although these numbers are configurable. For example, Tomcat by
default listens on port 8080 for HTTP connections and on port 8443 for HTTPS connections. The HTTPS URL for
Google is line 1 in the code listing.</p><p>The <code class="literal">GoogleClient</code> next opens an HTTPS connection (line 2) and prepares for a GET request against Google (line 3).
Once the connection is made, the application invokes <code class="literal">dumpDetails</code> to print information about the secure connection:
the type of certificates returned from Google during the challenge, the <span class="emphasis"><em>hash code</em></span> or <span class="emphasis"><em>fingerprint</em></span> that identifies
each certificate, the algorithm used to generate the key pair, and the format of the certificate (lines 5 through 9
in the code listing). The <code class="literal">dumpDetails</code> method also prints the response code, the by-now familiar 200 that
signals a successful GET request. On a sample run, the output from <code class="literal">dumpDetails</code> was:</p><pre class="screen">Status code:  200
Cipher suite: TLS_ECDHE_RSA_WITH_RC4_128_SHA <a id="CO1-11"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        Cert. type: X.509
        Hash code:  12584213
        Algorithm:  RSA
        Format:     X.509

        Cert. type: X.509
        Hash code:  2815543
        Algorithm:  RSA
        Format:     X.509</pre><p>Line 1 in the listing gives the <span class="emphasis"><em>cipher suite</em></span>, a collection of information about the algorithms used in the
initial handshake and in the encryption/decryption of messages exchanged after a successful handshake. Underscore
characters separate the parts of the cipher suite. Here is a summary of the parts:</p><div class="variablelist"><dl><dt><span class="term">
TLS
</span></dt><dd>
The Transport Layer Security, added to HTTP, yields HTTPS and thus accounts for the <span class="strong"><strong>S</strong></span> in HTTPS.
</dd><dt><span class="term">
ECDHE
</span></dt><dd>
The acronym stands for Elliptic Curve Diffie-Hellman key Exchange, which is the algorithm that governs the handshake.
</dd><dt><span class="term">
RSA
</span></dt><dd>
This is the <span class="emphasis"><em>public key cryptography algorithm</em></span>, named after Rivest, Shamir, and Adleman, the former MIT professors who designed it.
RSA is the most commonly used public key algorithm. It is used to encrypt the pre-master that is sent from the client to the server. Also,
the public key on exchanged digital certificates comes from an RSA-generated key pair.
</dd><dt><span class="term">
RC4_128
</span></dt><dd>
The <span class="emphasis"><em>stream cipher algorithm</em></span>, which is used to encrypt and decrypt the bit traffic between client and server, has a key
length of 128 bits. The R is for Rivest in RSA, and the C is for cipher. (Sometimes RC is said to be shorthand for <span class="emphasis"><em>Ron’s Code</em></span>,
as Rivest’s first name is Ron.) RC4 is the most commonly used stream cipher.
RC4_128 is used to encrypt the data traffic once the handshake is completed.
</dd><dt><span class="term">
SHA
</span></dt><dd>
The certificate’s 160-bit identifying hash, also called its <span class="emphasis"><em>fingerprint</em></span>, is generated with the Secure Hash Algorithm, officially
officially known as a <span class="emphasis"><em>cryptographic hash function</em></span>. There is a family of SHA algorithms but SHA-1, used here, is probably still the
most widely used member of this family.
</dd></dl></div><p>The Google web server sent two digital certificates during the mutual challenge phase. Each is an X.509
certificate generated with the RSA algorithm; and each of the SHA fingerprints is 160 bits in length.
The format of each certificate follows the X.509 specification.</p><p>How does the <code class="literal">GoogleClient</code> verify the two X.509 certificates the Google web server sends? There is nothing in
the <code class="literal">GoogleClient</code> code to suggest certificate verification. The core Java JDK ships with a default truststore
(<span class="emphasis"><em>JAVA_HOME/jre/lib/security/cacerts</em></span>). Because the <code class="literal">GoogleClient</code> opens an HTTPS connection to the Google web
server, the Java run-time intervenes to handle the certificate verification; and because Google is such a standard web
site, the <span class="emphasis"><em>cacerts</em></span> truststore has entries to verify the Google certificates. What about HTTPS connections to less
popular and prominent sites? Java’s security API makes it possible to disable peer authentication
so that a client such as the <code class="literal">GoogleClient</code> can take over certificate verification and make its own decisions about
what to accept and to reject. The <code class="literal">GoogleTrustingClient</code> (see <a class="xref" href="#google_trusting_client" title="Example 2. The GoogleTrustingClient, which turns off certificate verification.">Example 2, “The <code class="literal">GoogleTrustingClient</code>, which turns off certificate verification.”</a>)
revises the <code class="literal">GoogleClient</code> and shows how programmatic verification can be done—or by-passed altogether.</p><div class="example"><a id="google_trusting_client"></a><p class="title"><b>Example 2. The <code class="literal">GoogleTrustingClient</code>, which turns off certificate verification.</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import javax.net.ssl.SSLContext;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.net.MalformedURLException;
import java.security.cert.Certificate;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class GoogleTrustingClient {
    private static final String endpoint = "https://www.google.com:443/";

    public static void main(String[ ] args) {
        new GoogleTrustingClient().doIt();
    }
    private void doIt() {
        try {
            // Configure the HttpsURLConnection so that it does not
            // check certificates.
            SSLContext sslCtx = SSLContext.getInstance("TLS");                        <a id="CO1-12"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            TrustManager[ ] trustMgr = getTrustMgr();                                 <a id="CO1-13"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            sslCtx.init(null,                // key manager                           <a id="CO1-14"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                        trustMgr,            // trust manager                         <a id="CO1-15"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
                        new SecureRandom()); // random number generator               <a id="CO1-16"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
            HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory()); <a id="CO1-17"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />

            URL url = new URL(endpoint);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setDoInput(true);
            conn.setRequestMethod("GET");
            conn.connect();
            dumpDetails(conn);
        }
        catch(MalformedURLException e) { System.err.println(e); }
        catch(IOException e) { System.err.println(e); }
        catch(Exception e) { System.err.println(e); }
    }
    private TrustManager[ ] getTrustMgr() {                                           <a id="CO1-18"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
        // No exceptions thrown in any of the methods.
        TrustManager[ ] certs = new TrustManager[ ] {
            new X509TrustManager() {
                public X509Certificate[ ] getAcceptedIssuers() {                      <a id="CO1-19"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
                    return null;
                }
                public void checkClientTrusted(X509Certificate[ ] certs,              <a id="CO1-20"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
                                               String type) { }
                public void checkServerTrusted(X509Certificate[ ] certs,              <a id="CO1-21"></a><img src="/etc/asciidoc/images/icons//callouts/10.png" alt="10" border="0" />
                                               String type) { }
            }
        };
        return certs;
    }
    private void dumpDetails(HttpsURLConnection conn) {
        try {
            print("Status code:  " + conn.getResponseCode());
            print("Cipher suite: " + conn.getCipherSuite());
            Certificate[ ] certs = conn.getServerCertificates();
            for (Certificate cert : certs) {
                print("\tCert. type: " + cert.getType());
                print("\tHash code:  " + cert.hashCode());
                print("\tAlgorithm:  " + cert.getPublicKey().getAlgorithm());
                print("\tFormat:     " + cert.getPublicKey().getFormat());
                print("");
            }
        }
        catch(Exception e) { System.err.println(e); }
    }
    private void print(String s) { System.out.println(s); }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">GoogleTrustingClient</code> first gets an instance of an <code class="literal">SSLContext</code> (line 1) and then invokes
<code class="literal">getTrustManager</code> (line 2) to get a <code class="literal">TrustManager[ ]</code>, an array of managers for the
in-memory truststore. A <code class="literal">TrustManager</code> defines three methods:</p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">getAcceptedIssuers</code>
</span></dt><dd>
This method (line 8) returns an array of <code class="literal">X509Certificate</code> instances. In this case,
<code class="literal">null</code> is returned, which is explained shortly.
</dd><dt><span class="term">
<code class="literal">checkClientTrusted</code>
</span></dt><dd>
This method (line 9) expects, as one argument, an array of <code class="literal">X509Certificate</code>
instances and, as a second argument, a <code class="literal">String</code> that describes the certificates type (for
instance, X509). The method has <code class="literal">void</code> as the return type.
</dd><dt><span class="term">
<code class="literal">checkServerTrusted</code>
</span></dt><dd>
This method (line 10) expects the same arguments as <code class="literal">checkClientTrusted</code>.
</dd></dl></div><p>Each method is minimally defined but—and this is the critical point—no method throws a <code class="literal">CertificateException</code>, which
means that the <code class="literal">TrustManager</code> effectively accepts <span class="emphasis"><em>all</em></span> certificates. The <code class="literal">TrustManager</code> array returned from
the <code class="literal">getTrustManager</code> method (line 7) has a single member; and this member is all-trusting.
The result is that <code class="literal">GoogleTrustingClient</code>
effectively turns off certificate verification, a move that can be useful during development. In production,
the <code class="literal">TrustManager</code> could implement whatever certificate-inspection logic is appropriate.</p><p>The security details about HTTPS can be examined concretely with a lightweight HTTPS server, introduced in the next
section. The <code class="literal">Endpoint</code> utility class, used in earlier chapters to publish both REST-style and SOAP-based services,
does not support HTTPS connections. The <code class="literal">Endpoint</code> publisher is built with the <code class="literal">HttpServer</code> class, which
ships with core Java. The next section uses the related class <code class="literal">HttpsServer</code> to clarify, with
code, how HTTPS works.</p></div></div><div class="section" title="1.3. A Very Lightweight HTTPS Server and Client"><div class="titlepage"><div><div><h3 class="title"><a id="_a_very_lightweight_https_server_and_client"></a>1.3. A Very Lightweight HTTPS Server and Client</h3></div></div></div><p>An HTTPS server needs two stores for digital certificates:</p><div class="variablelist"><dl><dt><span class="term">
keystore
</span></dt><dd>
A <span class="emphasis"><em>keystore</em></span> contains digital certificates, including the certificates that an HTTPS server sends to
clients during the <span class="emphasis"><em>peer authentication</em></span> phase of the HTTPS handshake. When the server is challenged to establish
its identify, the server can send one or more certificates for its keystore to the challenger. If <span class="emphasis"><em>peer
authentication</em></span> is truly mutual, then a client as well needs a keystore with the client’s own digital certificates,
which can be sent to the server for verification.
</dd><dt><span class="term">
truststore
</span></dt><dd>
A <span class="emphasis"><em>truststore</em></span> is a keystore with a specified function: the truststore stores trusted certificates
used to verify other certificates. When a host, server or client, receives a certificate to be verified, this
received certificate can be compared against truststore entries. If the truststore does not contain such
a certificate, the truststore may contain at least a certificate from a CA such as VeriSign, whose
digital signature is on the received certificate.
</dd></dl></div><div class="example"><a id="keystore_truststore"></a><p class="title"><b>Example 3. A depiction of how a keystore and a truststore function.</b></p><div class="example-contents"><pre class="screen">  Keystore
+-----------------------+  DC1,DC2,...,DCn
| Digital certificates |---------------------------------&gt;challenging peer
+-----------------------+  DCs to challenging peer

  Truststore
+------------------------------+  DC1,DC2,...,DCn
| Trusted digital certificates |&lt;--------------------------challenged peer
+------------------------------+  DCs from challenged peer</pre></div></div><br class="example-break" /><p>Although the keystore and the truststore differ in core purpose (see <a class="xref" href="#keystore_truststore" title="Example 3. A depiction of how a keystore and a truststore function.">Example 3, “A depiction of how a keystore and a truststore function.”</a>),
one and the same file can function as both keystore and truststore; and, in development, this option is attractively simple.
In fleshing out these and related details about HTTPS security, the <code class="literal">HttpsPublisher</code> (see <a class="xref" href="#https_server" title="Example 4. The lightweight HttpsPublisher.">Example 4, “The lightweight <code class="literal">HttpsPublisher</code>.”</a>) code may be useful.</p><div class="example"><a id="https_server"></a><p class="title"><b>Example 4. The lightweight <code class="literal">HttpsPublisher</code>.</b></p><div class="example-contents"><pre class="screen">import java.net.InetSocketAddress;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;
import java.security.KeyStore;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import javax.xml.ws.http.HTTPException;
import java.io.OutputStream;
import java.io.InputStream;
import java.security.SecureRandom;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpsServer;
import com.sun.net.httpserver.HttpsConfigurator;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpsParameters;
import service.IService;

public class HttpsPublisher {
    private static final int defaultPort = 3443;
    private static final int backlog = 12;
    private static final String keystore = "test.keystore";
    private IService serviceInstance;                                           <a id="CO1-22"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />

    public static void main(String[ ] args) {
        if (args.length &lt; 2) {
            System.err.println("Usage: java HttpsPublisher &lt;service&gt; &lt;path&gt;");
            return;
        }
        // % java HttpsPublisher myService.Service /service
        new HttpsPublisher().init(args[0],  // service name
                                  args[1]); // URI
    }
    private void init(String serviceName, String uri) {
        try {
            Class serviceClass = Class.forName(serviceName);                    <a id="CO1-23"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            serviceInstance = (IService) serviceClass.newInstance();            <a id="CO1-24"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        }
        catch(Exception e) { throw new RuntimeException(e); }
        HttpsServer server = getHttpsServer(uri, defaultPort);
        if (server != null) {
            server.createContext(uri);                                          <a id="CO1-25"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            System.out.println("Server listening on port " + defaultPort);
            server.start();                                                     <a id="CO1-26"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        }
        else
            throw new RuntimeException("Cannot create server instance.");
    }
    private HttpsServer getHttpsServer(String uri, int port) {
        HttpsServer server = null;
        try {
            InetSocketAddress inet = new InetSocketAddress(port);
            server = HttpsServer.create(inet, backlog);                         <a id="CO1-27"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            SSLContext sslCtx = SSLContext.getInstance("TLS");
            // password for keystore
            char[ ] password = "qubits".toCharArray();
            KeyStore ks = KeyStore.getInstance("JKS");
            FileInputStream fis = new FileInputStream(keystore);
            ks.load(fis, password);
            KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
            kmf.init(ks, password);
            TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
            tmf.init(ks); // same as keystore
            sslCtx.init(kmf.getKeyManagers(),
                        tmf.getTrustManagers(),
                        new SecureRandom());
            // Create SSL engine and configure HTTPS to use it.
            final SSLEngine eng = sslCtx.createSSLEngine();
            server.setHttpsConfigurator(new HttpsConfigurator(sslCtx) {
                    public void configure(HttpsParameters parms) {
                        parms.setCipherSuites(eng.getEnabledCipherSuites());
                        parms.setProtocols(eng.getEnabledProtocols());
                    }
                });
            server.setExecutor(null); // use default, hence single-threaded
            server.createContext(uri, new MyHttpsHandler(this.serviceInstance));
        }
        catch(Exception e) { throw new RuntimeException(e); }
        return server;
    }
}
// The handle method is called on a particular request context,
// in this case on any request to the server that ends with /&lt;uri&gt;.
class MyHttpsHandler implements HttpHandler {
    private IService service;

    public MyHttpsHandler(IService service) {
        this.service = service;
    }
    public void handle(HttpExchange ex) {
        // Implement a simple routing table.
        String verb = ex.getRequestMethod().toUpperCase();
        if (verb.equals("GET"))         service.doGet(ex);
        else if (verb.equals("POST"))   service.doPost(ex);
        else if (verb.equals("PUT"))    service.doPut(ex);
        else if (verb.equals("DELETE")) service.doDelete(ex);
        else throw new HTTPException(405);
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">HttpsPublisher</code> can be started with a command such as:</p><pre class="screen">% java HttpsPublisher service.TestService /test</pre><p>The first command-line argument, <code class="literal">service.TestService</code> (see <a class="xref" href="#test_service" title="Example 6. The TestService published with the HttpsPublisher.">Example 6, “The <code class="literal">TestService</code> published with the <code class="literal">HttpsPublisher</code>.”</a>), is the fully qualified name of a RESTful service’s
implementation class; and the second command-line argument, in this case <code class="literal">/test</code>, is the URI that identifies
the service. Any service deployed with the <code class="literal">HttpsPublisher</code> must implement the <code class="literal">IService</code> interface
(see <a class="xref" href="#iservice_iface" title="Example 5. The IService interface.">Example 5, “The <code class="literal">IService</code> interface.”</a>), which means that the four CRUD methods <code class="literal">doGet</code>, <code class="literal">doPost</code>, <code class="literal">doPut</code>, and <code class="literal">doDelete</code> must
be defined. The <code class="literal">HttpsPublisher</code> declares a reference of data type <code class="literal">IService</code> (line 1 in the listing) and then
uses the <code class="literal">Class.forName</code> utility to load a service class such as <code class="literal">TestService</code>
from the file system (line 2) and create an instance (line 3). The <code class="literal">IService</code> interfaces thus
allows the <code class="literal">HttpPublisher</code> to publish any service that implements the RESTful CRUD operations with the
designated method names.</p><p>The <code class="literal">HttpsPublisher</code> sets the context for requests (line 4), which in this
example means that a client must use the URI <code class="literal">/test</code> to hit the <code class="literal">TestService</code>. The publisher maintains a
queue of up to <code class="literal">backlog</code> requests, currently set to 16, on the specified HTTPS port <code class="literal">3443</code>.
Finally, the
<code class="literal">start</code> method is invoked on the <code class="literal">HttpsServer</code> instance (line 5), which starts the server for an indefinitely long
run.</p><div class="example"><a id="iservice_iface"></a><p class="title"><b>Example 5. The <code class="literal">IService</code> interface.</b></p><div class="example-contents"><pre class="screen">package service;
import com.sun.net.httpserver.HttpExchange;

public interface IService {
    public void doGet(HttpExchange e);
    public void doPost(HttpExchange e);
    public void doPut(HttpExchange e);
    public void doDelete(HttpExchange e);
}</pre></div></div><br class="example-break" /><div class="example"><a id="test_service"></a><p class="title"><b>Example 6. The <code class="literal">TestService</code> published with the <code class="literal">HttpsPublisher</code>.</b></p><div class="example-contents"><pre class="screen">package service;

import java.io.OutputStream;
import com.sun.net.httpserver.HttpExchange;

public class TestService implements IService {
    public void doGet(HttpExchange e) { respond2Client(e, "doGet"); }
    public void doPost(HttpExchange e) { respond2Client(e, "doPost"); }
    public void doPut(HttpExchange e) { respond2Client(e, "doPut"); }
    public void doDelete(HttpExchange e) { respond2Client(e, "doDelete"); }

    private void respond2Client(HttpExchange ex, String response) {
        try {
            ex.sendResponseHeaders(200, 0); // 0 == as many bytes as there are
            OutputStream out = ex.getResponseBody();
            out.write(response.getBytes());
            out.close(); // effectively ends session
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>Once the RESTful service class has been loaded, the <code class="literal">HttpsServer</code> begins the tricky security
configuration. A client that opens an HTTPS connection to the <code class="literal">HttpsServer</code> is going to challenge
this server to verify its identify; and the <code class="literal">HttpsServer</code> responds with a digital certificate.
The core Java JDK comes with a <span class="emphasis"><em>keytool</em></span> utility that can be used to create a <span class="emphasis"><em>self-signed</em></span> rather
than a CA-certified digital certificate. For development, the self-signed digital certificate is good enough; for
production, a CA-certified digital certificate would be needed. The command</p><pre class="screen">% keytool -genkey -keyalg RSA -keystore test.keystore</pre><p>eventually creates the file <span class="emphasis"><em>test.keystore</em></span>, which contains an X.509 digital certificate generated using the RSA algorithm. This
file is the keystore. The <span class="emphasis"><em>keytool</em></span> utility is interactive, prompting the user with questions that must be
answered. The first such question is about a password to protect access to the keystore. In this case, the password
is <span class="emphasis"><em>qubits</em></span>. For the current example, the keystore file <span class="emphasis"><em>test.keystore</em></span> (the name is arbitrary) performs
various functions.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The file acts as a regular keystore that contains the digital certificate that the <code class="literal">HttpsPublisher</code> sends to any challenger, in this
case the <code class="literal">HttpsClient</code>, which is introduced shortly.
</li><li class="listitem">
The file doubles as the <code class="literal">HttpsPublisher</code> truststore and as the <code class="literal">HttpsClient</code> truststore. Accordingly, the fix is in.
When the <code class="literal">HttpsPublisher</code> sends the one and only digital certificate in the keystore <span class="emphasis"><em>test.keystore</em></span>, the <code class="literal">HttpsClient</code> verifies this
digital certificate by checking it against the very same keystore—but a keystore now functioning as a truststore. Were the <code class="literal">HttpsPublisher</code>
to challenge the <code class="literal">HttpsClient</code>, the client would send the same digital certificate as its identity voucher—and the <code class="literal">HttpsPublisher</code>
would verify this digital certificate against itself, in effect.
</li></ul></div><p>Using the keystore for multiple purposes simplifies the set-up and keeps the focus on the technical coding details. In a
production environment, of course, there would be four keystores involved in this scenario: the <code class="literal">HttpsPublisher</code> would have
a keystore with its certificates and a truststore with the certificates that it trusts; and the same would hold for the
<code class="literal">HttpsClient</code>.</p><p>The <code class="literal">HttpsPublisher</code> reads into memory the digital certificate stored in the file named <span class="emphasis"><em>test.keystore</em></span>. Here is a block of initialization
code:</p><pre class="screen">SSLContext sslCtx = SSLContext.getInstance("TLS");                      <a id="CO1-28"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
char[ ] password = "qubits".toCharArray();                              <a id="CO1-29"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
KeyStore ks = KeyStore.getInstance("JKS");
FileInputStream fis = new FileInputStream(keystore);
ks.load(fis, password);                                                 <a id="CO1-30"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
kmf.init(ks, password);                                                 <a id="CO1-31"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks); // same as keystore
sslCtx.init(kmf.getKeyManagers(),                                       <a id="CO1-32"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
            tmf.getTrustManagers(),                                     <a id="CO1-33"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            new SecureRandom());
final SSLEngine eng = sslCtx.createSSLEngine();
server.setHttpsConfigurator(new HttpsConfigurator(sslCtx) {
   public void configure(HttpsParameters parms) {
      parms.setCipherSuites(eng.getEnabledCipherSuites());              <a id="CO1-34"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
      parms.setProtocols(eng.getEnabledProtocols());                    <a id="CO1-35"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
   }});
server.setExecutor(null); // use default, hence single-threaded         <a id="CO1-36"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
server.createContext(uri, new MyHttpsHandler(this.serviceInstance));    <a id="CO1-37"></a><img src="/etc/asciidoc/images/icons//callouts/10.png" alt="10" border="0" /></pre><p>The <code class="literal">SSLContext</code> (line 1) is the central data structure; and this context supports secure (that is, TLS-based)
communications from clients to the <code class="literal">HttpsPublisher</code>. After the password bytes are stored in an array (line 2), the
contents of the keystore file, <span class="emphasis"><em>test.keystore</em></span>, are loaded into memory (line 3) and a <code class="literal">KeyManagerFactory</code>
is initialized with the contents of this keystore file (line 4). There is now an in-memory version of the file <span class="emphasis"><em>test.keystore</em></span>.
The <code class="literal">TrustStoreFactory</code> (line 5) is initialized with the contents of the very same
keystore file. At this point, the <code class="literal">SSLContext</code> is initialized with the <span class="emphasis"><em>key managers</em></span> of the
keystore file and the <span class="emphasis"><em>trust managers</em></span> of the truststore file, which are the same file.</p><p>The next security initialization steps involve setting the appropriate cipher suites (line 7), which are
used during the handshake negotiations with a client. The security protocols that are available to the
server are likewise part of the initialization (line 8). For demonstration purposes, the <code class="literal">HttpsPublisher</code>
remains single-threaded, which explains the <code class="literal">null</code> in line 9. To make the publisher multi-threaded, a
non-<code class="literal">null</code> value for the <code class="literal">Executor</code> (that is, the thread manager) would be used. Finally, the
HTTPS server specifies a <span class="emphasis"><em>handler</em></span> to handle requests against the URI, in this case <code class="literal">/test</code> (line 10).</p><p>The set-up code is tricky but its gist can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
An <code class="literal">SSLContext</code> data structure is populated with security information, in particular the
keystore and truststore contents that the <code class="literal">HttpsPublisher</code> needs to conduct the handshake with
a prospective client.
</li><li class="listitem">
The <code class="literal">HttpsPublisher</code> also uses the <code class="literal">SSLContext</code> to create an <code class="literal">SSLEngine</code>, which manages
the cipher suites and related security protocols.
</li></ul></div><p>When the set-up is complete, the <code class="literal">HttpsPublisher</code> is ready to accept HTTPS connections from
potential clients. Client requests are dispatched to an instance of the class <code class="literal">MyHttpsHandler</code>:</p><pre class="screen">server.createContext(uri, new MyHttpsHandler(this.serviceInstance));</pre><p>The constructor call to <code class="literal">MyHttpsHandler</code> has, as its single argument, a reference to the
<code class="literal">IService</code> instance so that GET requests can be forwarded to the <code class="literal">serviceInstance</code>
method <code class="literal">doGet</code>,
POST requests to <code class="literal">doPost</code>, and so on. The <code class="literal">MyHttpsHandler</code> class implements
the <code class="literal">HttpHandler</code> interface, which has a single method: <code class="literal">handle</code>. Here is the implementation:</p><pre class="screen">public void handle(HttpExchange ex) {
    String verb = ex.getRequestMethod().toUpperCase();
    if (verb.equals("GET"))         service.doGet(ex);
    else if (verb.equals("POST"))   service.doPost(ex);
    else if (verb.equals("PUT"))    service.doPut(ex);
    else if (verb.equals("DELETE")) service.doDelete(ex);
    else throw new HTTPException(405); // bad verb
}</pre><p>The flow of control (see <a class="xref" href="#handler_routing" title="Example 7. The routing in the HttpsPublisher.">Example 7, “The routing in the <code class="literal">HttpsPublisher</code>.”</a>) is straightforward: a request targeted at the
URI <code class="literal">/test</code> goes to the <code class="literal">MyHttpsHandler</code> instance, which implements the <code class="literal">handle</code> method.
The <code class="literal">handle</code> method dispatches GET requests to the service’s <code class="literal">doGet</code> method, POST requests
to the service’s <code class="literal">doPost</code> method, and so on. The critical point is that the communications
between the <code class="literal">HttpsPublisher</code> and the client are over a secure HTTPS channel.</p><div class="example"><a id="handler_routing"></a><p class="title"><b>Example 7. The routing in the <code class="literal">HttpsPublisher</code>.</b></p><div class="example-contents"><pre class="screen">             +----------------+    +----------------+    +----------+ doPost
requests----&gt;| HttpsPublisher |---&gt;| MyHttpsHandler |---&gt;| IService | doGet
             +----------------+    +----------------+    +----------+ doPut
                                                                      doDelete</pre></div></div><br class="example-break" /><p>In the current implementation, the <code class="literal">TestService</code> instance encapsulates minimalist versions of <code class="literal">doGet</code>, <code class="literal">doPost</code>,
<code class="literal">doPut</code>, and <code class="literal">doDelete</code> operations. The point of interest is the security configuration, not the
actual behavior of the RESTful service. Each CRUD operation returns a string confirming that the
operation has been invoked. For HTTPS requests with bodies (that is, POST and PUT), the <code class="literal">HttpsClient</code>
(see <a class="xref" href="#https_client" title="Example 8. The sample HttpsClient against the TestService.">Example 8, “The sample <code class="literal">HttpsClient</code> against the <code class="literal">TestService</code>.”</a>) sends a short string that the service operations ignore.</p><div class="example"><a id="https_client"></a><p class="title"><b>Example 8. The sample <code class="literal">HttpsClient</code> against the <code class="literal">TestService</code>.</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.SecureRandom;

public class HttpsClient {
    private static final String endpoint = "https://localhost:3443/test/";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
        new HttpsClient().runTests();
    }
    private void runTests() {
        try {
            SSLContext sslCtx = SSLContext.getInstance("TLS");
            // password for truststore (same as server's keystore)
            char[ ] password = "qubits".toCharArray();
            KeyStore ks = KeyStore.getInstance("JKS");
            FileInputStream fis = new FileInputStream(truststore);
            ks.load(fis, password);
            TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
            tmf.init(ks); // same as keystore
            sslCtx.init(null,                   // not needed, not challenged
                        tmf.getTrustManagers(),
                        null);                  // use default: SecureRandom
            HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
            URL url = new URL(endpoint);
            HttpsURLConnection conn = getConnection(url, "GET");
            getTest(conn);
            conn = getConnection(url, "POST");
            postTest(conn);
            conn = getConnection(url, "PUT");
            putTest(conn);
            conn = getConnection(url, "DELETE");
            deleteTest(conn);
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url, String verb) {
        try {
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setRequestMethod(verb);
            // Guard against "bad hostname" errors during handshake.
            conn.setHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String host, SSLSession session) {
                        return host.equals("localhost"); // for development
                    }
                });
            return conn;
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest(HttpsURLConnection conn) {                <a id="CO1-38"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        try {
            conn.connect();
            readResponse("GET request: ", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest(HttpsURLConnection conn) {               <a id="CO1-39"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        try {
            conn.connect();
            writeBody(conn);
            readResponse("POST request: ", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void putTest(HttpsURLConnection conn) {                <a id="CO1-40"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        try {
            conn.connect();
            writeBody(conn);
            readResponse("PUT request: ", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(HttpsURLConnection conn) {             <a id="CO1-41"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        try {
            conn.connect();
            readResponse("PUT request: ", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
        try {
            OutputStream out = conn.getOutputStream();
            out.write("foo bar baz".getBytes()); // anything will do
            out.flush();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
        try {
            byte[ ] buffer = new byte[512]; // plenty for testing
            InputStream in = conn.getInputStream();
            in.read(buffer);
            System.out.println(msg + new String(buffer));
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">HttpsClient</code> (see <a class="xref" href="#https_client" title="Example 8. The sample HttpsClient against the TestService.">Example 8, “The sample <code class="literal">HttpsClient</code> against the <code class="literal">TestService</code>.”</a>) makes requests against the four CRUD operations (lines 1, 2, 3, and 4) in the <code class="literal">TestService</code>
published with the <code class="literal">HttpsPublisher</code>
This client is similar in structure to the <code class="literal">GoogleTrustingClient</code> examined earlier except that the
<code class="literal">HttpsClient</code> does demand a digital certificate from the <code class="literal">HttpsPublisher</code> and does verify this certificate
against a truststore. As noted earlier, the client’s truststore is the same file, <span class="emphasis"><em>test.keystore</em></span>, as the server’s
keystore; hence, the verification is guaranteed to succeed. The <code class="literal">HttpsClient</code> reads the truststore data into memory
and uses these data to initialize the all-important <code class="literal">SSLContext</code>. Here is the relevant code:</p><pre class="screen">FileInputStream fis = new FileInputStream(truststore);
ks.load(fis, password);
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ks); // same as keystore
sslCtx.init(null, // not needed, not challenged   <a id="CO1-42"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            tmf.getTrustManagers(),
            new SecureRandom());</pre><p>In the call to <code class="literal">init</code> (line 1), the first argument is <code class="literal">null</code>, which represents the keystore managers. The
assumption is that the <code class="literal">HttpsPublisher</code> will not challenge the <code class="literal">HttpsClient</code>, which therefore does not need a
keystore for the handshake. Were <span class="emphasis"><em>mutual</em></span> challenge in operation, then the <code class="literal">HttpsClient</code> set-up would be the
same, with respect to the keystore and the truststore, as in the <code class="literal">HttpsPublisher</code>.</p><p>Of course, a non-Java client also can connect over HTTPS to the <code class="literal">HttpsPublisher</code>. As proof of concept,
here is a very short Perl client that connects but does not bother to verify the digital certificates
that the <code class="literal">HttpsPublisher</code> sends to the client:</p><pre class="screen">use Net::SSLeay qw(get_https);
my ($type, $start_line, $misc, $extra) = get_https('localhost', 3443, '/test');
print "Type/value:  $type\n";
print "Start line:  $start_line\n";
print "Misc:        $misc =&gt; $extra\n";</pre><p>The output from a sample run was:</p><pre class="screen">Type/value:  doGet
Start line:  HTTP/1.1 200 OK
Misc:        CONNECTION =&gt; close</pre><p>Changing from HTTP to HTTPS transport does not imperil the language neutrality and interoperability of
web services—assuming, of course, that the languages used on client-side and the service-side include
HTTPS libraries, as modern languages usually do.</p></div><div class="section" title="1.4. HTTPS in a Production-Grade Web Server"><div class="titlepage"><div><div><h3 class="title"><a id="_https_in_a_production_grade_web_server"></a>1.4. HTTPS in a Production-Grade Web Server</h3></div></div></div><p>The <code class="literal">HttpsPublisher</code> is simple enough in structure to illustrate the basics of wire-level security. Among the
several reasons for going with a production-grade web server such as Tomcat or Jetty is that these
servers provide such good support for HTTPS, at the application and at the administrative level.
Although these web servers provide first-rate HTTPS support,
they do require set-up comparable to that illustrated with the <code class="literal">HttpsPublisher</code>. This section focuses on Tomcat.</p><p>Tomcat does not ship with a keystore of digital certificates and, accordingly, does not enable HTTPS by default. The
service must be turned on by editing the configuration file <span class="emphasis"><em>TOMCAT_HOME/conf/server.xml</em></span>, with details
provided shortly. The same keystore file used in the <code class="literal">HttpsPublisher</code> example, <span class="emphasis"><em>test.keystore</em></span>, could be
re-used for Tomcat. A modern browser connecting over HTTPS to Tomcat should complain that the
digital certificate in <span class="emphasis"><em>test.keystore</em></span> is self-signed and, therefore, worthless as a security credential.
In production, a keystore with commercial-grade keystore digital certificates would be needed. Yet the point of immediate interest is
that Tomcat does require the programmer to jump through a few hoops in order to switch from an HTTP-accessible
to an HTTPS-accessible service. There are only three such hoops:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
HTTPS connections must be enabled in Tomcat by editing the <span class="emphasis"><em>server.xml</em></span> file. Details follow shortly.
</li><li class="listitem">
A keystore must be made available so that Tomcat can perform the handshake with potential clients
and afterwards support the encryption and decryption of exchanged messages.
</li><li class="listitem">
The configuration file <span class="emphasis"><em>web.xml</em></span> must turn on HTTPS support for the web site or web service. No change
is required to the site or service code, however.
</li></ul></div><p>The first two changes are covered in the sidebar (see <a class="xref" href="#tomcat_https" title="Setting up Tomcat for HTTPS support.">Setting up Tomcat for HTTPS support.</a>).</p><div class="sidebar" title="Setting up Tomcat for HTTPS support."><a id="tomcat_https"></a><p class="title"><b>Setting up Tomcat for HTTPS support.</b></p><p>The primary configuration file for Tomcat is <span class="emphasis"><em>TOMCAT_HOME/conf/server.xml</em></span>. If this file is edited,
Tomcat must be re-started in order for the changes to take effect. The file contains several
elements tagged <code class="literal">Connector</code>. For example, here is the entry for the HTTP connector:</p><pre class="screen">&lt;Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;</pre><p>The Tomcat port of HTTP connection is 8080 but this could be changed to, for instance, port 80.
The last attribute in this XML element has <code class="literal">redirectPort</code> as its key and <code class="literal">8433</code> as its value. Suppose
that a web site or web service requires HTTPS access but that a client tries to hit the site or
service using HTTP. Tomcat then counters with an <span class="emphasis"><em>HTTP redirect</em></span>, instructing the client (for instance,
a browser in the case of a web site) to redirect to port 8443, the port at which Tomcat awaits
HTTPS connections. Tomcat, however, is not yet configured for HTTPS.</p><p>The <code class="literal">Connector</code> element for HTTPS is commented out in <span class="emphasis"><em>server.xml</em></span>:</p><pre class="screen">&lt;!--
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS" /&gt;
--&gt;</pre><p>After removing the comment delimiters and restarting Tomcat, HTTPS should be enabled.</p><p>One further change is in order. Tomcat needs access to a keystore. The <span class="emphasis"><em>test.keystore</em></span> from the
<code class="literal">HttpsPublisher</code> example could be used, of course, or a fresh keystore could be created. In any case,
the recommended change is to have the HTTPS <code class="literal">Connector</code> element point explicitly to this file:</p><pre class="screen">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true"
           maxThreads="150" scheme="https" secure="true"
           clientAuth="false" sslProtocol="TLS"
           keystoreFile="${user.home}/tcKeystore.keystore"   <a id="CO1-43"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
           keystorePass="qubits"/&gt;                           <a id="CO1-44"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" /></pre><p>Line 1 is the change, with the keystore file <span class="emphasis"><em>tcKeystore.keystore</em></span> stored in my home directory with
the password <span class="emphasis"><em>qubits</em></span> (line 2).
The keystore file can be located anywhere on the local file system. Recall that Tomcat now must be
restarted for these changes to take effect.</p><p>With these changes in place, entering the URL</p><pre class="screen">https://localhost:8443/</pre><p>in a browser or as an argument to the <span class="emphasis"><em>curl</em></span> utility results in the fetch of Tomcat’s familiar welcome
page, the same page accessible through the HTTP URL</p><pre class="screen">http://localhost:8080/</pre><p>The attributes in the HTTPS <code class="literal">Connector</code> element are intuitive. The <code class="literal">maxThreads</code> value of 150 signals that
Tomcat will queue up to 150 requests against an HTTPS service before issuing a <span class="emphasis"><em>connection refused</em></span> response to
a client attempting to connect. The SSL protocol is the current standard, TLS; and the HTTP scheme used to
connect over HTTPS is, as expected, <span class="emphasis"><em>https</em></span>.</p></div><div class="section" title="1.4.1. Enforcing HTTPS Access to a Web Service"><div class="titlepage"><div><div><h4 class="title"><a id="_enforcing_https_access_to_a_web_service"></a>1.4.1. Enforcing HTTPS Access to a Web Service</h4></div></div></div><p>A web site or a web service can instruct Tomcat to enforce HTTPS access to either the entire resource (for instance,
all of the HTML pages in the web site and all of the operations in the web service) or only parts thereof (for
instance, to administrative HTML pages in the site or to selected operations in the service). The instructions
to Tomcat occur in a <code class="literal">security-constraint</code> section of the <span class="emphasis"><em>web.xml</em></span> deployment file. To illustrate, the RESTful
<span class="emphasis"><em>predictions2</em></span> service of Chapter 2, originally deployed with HTTP access only, can be redeployed with
HTTPS access only. This requires no change whatsoever in the code.
The revised <span class="emphasis"><em>web.xml</em></span> is <a class="xref" href="#revised_web" title="Example 9. The web.xml revised for security.">Example 9, “The <span class="emphasis"><em>web.xml</em></span> revised for security.”</a>.</p><div class="example"><a id="revised_web"></a><p class="title"><b>Example 9. The <span class="emphasis"><em>web.xml</em></span> revised for security.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;predictor&lt;/servlet-name&gt;
    &lt;servlet-class&gt;predictions2.PredictionsServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;security-constraint&gt;                                          <a id="CO1-45"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    &lt;web-resource-collection&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;                              <a id="CO1-46"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;    <a id="CO1-47"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;predictor&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><br class="example-break" /><p>The changes are limited to the <code class="literal">security-constraint</code> section (line 1). In this example,
the security constraint is enforced on the entire resource because the <code class="literal">url-pattern</code> (line 2)
has <code class="literal">/*</code> as its value. The deployed WAR file <span class="emphasis"><em>predictions2.war</em></span> (created, as usual, with the
Ant script) could be partitioned in subdirectories, for example:</p><pre class="screen">/admin    ;; contains administrative operations
/public   ;; contains publicly accessible operations</pre><p>Under this partition, the service operations in the <code class="literal">/admin</code> directory might require HTTPS
but not the ones in the <code class="literal">/public</code> directory. To enforce this policy, the <code class="literal">url-pattern</code> in line 2
would change to <code class="literal">/admin/*</code>. The <code class="literal">transport-guarantee</code> element, with a value of
<code class="literal">CONFIDENTIAL</code> (line 3), instructs Tomcat to enforce HTTPS access on the specified resource, in this
example on the entire <span class="emphasis"><em>predictions2</em></span> WAR file. If a client tried to access the
<span class="emphasis"><em>predictions2</em></span> service under HTTP, Tomcat would respond with an HTTP status code of 302 and the
appropriate <span class="emphasis"><em>https</em></span> URL, thereby signaling to the client that a new request with an HTTPS connection should be
attempted.</p><p>Within the <code class="literal">web-resource-collection</code> element of <span class="emphasis"><em>web.xml</em></span>, access constraints can be specified
that depend on the HTTP verb of the client request. For example, the <span class="emphasis"><em>web.xml</em></span> segment</p><pre class="screen">&lt;web-resource-collection&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;http-method&gt;POST&lt;/http-method&gt; <a id="CO1-48"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
  &lt;http-method&gt;PUT&lt;/http-method&gt;  <a id="CO1-49"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
&lt;/web-resource-collection&gt;</pre><p>specifies that access to the resource, in this case the entire <span class="emphasis"><em>predictions2</em></span> service, is constrained only on
POST and PUT requests (lines 1 and 2). If no specific HTTP verbs are specified, then the constraint covers them all.</p></div><div class="section" title="1.4.2. An HTTPS Client against the predictions2 Service"><div class="titlepage"><div><div><h4 class="title"><a id="_an_https_client_against_the_emphasis_predictions2_emphasis_service"></a>1.4.2. An HTTPS Client against the <span class="emphasis"><em>predictions2</em></span> Service</h4></div></div></div><div class="example"><a id="https_predictions_client"></a><p class="title"><b>Example 10. The <code class="literal">HttpsPredictionsClient</code> against the <span class="emphasis"><em>predictions2</em></span> service</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.security.SecureRandom;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;

public class PredictionsHttpsClient {
    private static final String endpoint = "https://localhost:8443/predictions2";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
        new PredictionsHttpsClient().runTests();
    }
    private void runTests() {
        try {
            SSLContext sslCtx = SSLContext.getInstance("TLS");
            char[ ] password = "qubits".toCharArray();
            KeyStore ks = KeyStore.getInstance("JKS");
            FileInputStream fis = new FileInputStream(truststore);
            ks.load(fis, password);
            TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
            tmf.init(ks); // same as keystore
            sslCtx.init(null,                   // not needed, not challenged
                        tmf.getTrustManagers(),
                        new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
            getTest();
            postTest();
            getTestAll();     // confirm POST test
            deleteTest("31");
            getTestAll();     // confirm DELETE test
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url, String verb) {
        try {
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setRequestMethod(verb);
            conn.setHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String host, SSLSession session) {
                        return host.equals("localhost"); // for development
                    }
                });
            return conn;
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest() {
        getTestAll();
        getTestOne("31");
    }
    private void getTestAll() {
        try {
            URL url = new URL(endpoint);
            HttpsURLConnection conn = getConnection(url, "GET");
            conn.connect();
            readResponse("GET all request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTestOne(String id) {
        try {
            URL url = new URL(endpoint + "?id=" + id);
            HttpsURLConnection conn = getConnection(url, "GET");
            conn.connect();
            readResponse("GET request for " + id + ":\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest() {
        try {
            URL url = new URL(endpoint);
            HttpsURLConnection conn = getConnection(url, "POST");
            conn.connect();
            writeBody(conn);
            readResponse("POST request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(String id) {
        try {
            URL url = new URL(endpoint + "?id=" + id);
            HttpsURLConnection conn = getConnection(url, "DELETE");
            conn.connect();
            readResponse("DELETE request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
        try {
            String pairs = "who=Freddy&amp;what=Avoid Friday nights if possible.";
            OutputStream out = conn.getOutputStream();
            out.write(pairs.getBytes());
            out.flush();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
        try {
            byte[ ] buffer = new byte[4096];
            InputStream in = conn.getInputStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            int n = 0;
            while ((n = in.read(buffer)) != -1) out.write(buffer, 0, n);
            in.close();
            System.out.println(new String(out.toByteArray())); // stringify and print
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PredictionsHttpsClient</code>  (see <a class="xref" href="#https_predictions_client" title="Example 10. The HttpsPredictionsClient against the predictions2 service">Example 10, “The <code class="literal">HttpsPredictionsClient</code> against the <span class="emphasis"><em>predictions2</em></span> service”</a>) is a test client against
the HTTPS-deployed version of the <span class="emphasis"><em>predictions2</em></span> service. This client is roughly similar to the
<code class="literal">HttpsClient</code> (<a class="xref" href="#https_client" title="Example 8. The sample HttpsClient against the TestService.">Example 8, “The sample <code class="literal">HttpsClient</code> against the <code class="literal">TestService</code>.”</a>) but methods such as <code class="literal">readResponse</code> and <code class="literal">writeBody</code> now are
beefed up in order to make realistic CRUD requests against the service. For example, the
<code class="literal">postTest</code> adds new <code class="literal">Prediction</code> to the collection, which requires that <code class="literal">writeBody</code> insert
the key/value pairs for the key <code class="literal">who</code> (the predictor) and the key <code class="literal">what</code> (the prediction); and the
<code class="literal">getTestAll</code> must read all of the bytes returned from the service in order to display the
<code class="literal">Prediction</code> list.</p><p>Tomcat’s approach to HTTPS exemplifies the separation-of-concerns principle. A web service (or a web site)
need not be changed at the code level to move from HTTP to HTTPS access. It bears repeating that no code in the
original <span class="emphasis"><em>predictions2</em></span> service had to be changed; instead, only the deployment
descriptor <span class="emphasis"><em>web.xml</em></span> needs to change and then only a little.
Tomcat also assumes responsibility for
enforcing HTTPS access in accordance with the policy given in the <span class="emphasis"><em>web.xml</em></span> document: a client that now tries to
hit the <span class="emphasis"><em>predictions2</em></span> service with an HTTP-based request is signaled that an HTTPS-based request should be used
instead.</p></div></div><div class="section" title="1.5. Container-Managed Security"><div class="titlepage"><div><div><h3 class="title"><a id="_container_managed_security"></a>1.5. Container-Managed Security</h3></div></div></div><p>Wire-level security and users/roles security are related as follows. Under users/roles security, a client furnishes an identification such as a
<span class="emphasis"><em>username</em></span> or even a digital certificate together with a security credential that vouches for the identification (for instance, a <span class="emphasis"><em>password</em></span> or
a signature on the digital certificate from a certificate authority). To avoid hijacking, the identification and the credential should be sent
from the client to the server through a secure channel, for instance, over an HTTPS connection. Wire-level security is thus the foundation upon which
users/roles security should be implemented; and HTTPS is an ideal way to provide wire-level security for <span class="emphasis"><em>web</em></span>-based systems such as
web services.</p><div class="example"><a id="users_roles"></a><p class="title"><b>Example 11. Users/roles security.</b></p><div class="example-contents"><pre class="screen">   id       +----------------+     +---------------+     +----------+
-----------&gt;| user           |----&gt;| role          |----&gt;| secured  |
credential  | authentication |     | authorization |     | resource |
            +----------------+     +---------------+     +----------+
                required              optional</pre></div></div><br class="example-break" /><p>Users/roles security is a two-phase process (see <a class="xref" href="#users_roles" title="Example 11. Users/roles security.">Example 11, “Users/roles security.”</a>). In the first and required phase, the user provides an
identification and a credential that vouches for the identification. A successful <span class="emphasis"><em>user authentication</em></span> phase results in
an <span class="emphasis"><em>authenticated subject</em></span>. In the optional second phase, <span class="emphasis"><em>role authorization</em></span>, the access permissions of the
authenticated subject can be refined as needed. For example, in a software development organization there might be
a distinction between a <span class="emphasis"><em>senior engineer</em></span> and a <span class="emphasis"><em>starting programmer</em></span> in that the former can access resources (for instance,
sensitive records in a database) that the latter cannot access. This distinction could be implemented with different
authorization roles.</p><p>At what level should users/roles security be enforced? Enforcement at the application level does not scale easily in that
every web service (or web site) would require code, perhaps consolidated into a library, dedicated to security; a web
service still would need to link to such library code. The
preferred approach is hand over the security concerns to the service container, that is, to Tomcat or Jetty. This is
<span class="emphasis"><em>container-managed security</em></span>, which is considered best practice. Tomcat’s implementation of container-managed security,
like its management of wire-level security, is unobtrusive at the service level: no changes are required in the
web service code to enable users/roles security. Once again the configuration document <span class="emphasis"><em>web.xml</em></span> is the key.</p><p>The RESTful <span class="emphasis"><em>predictions2</em></span> service once again can be augmented with container-managed security—and without any
change to the code. The revised <span class="emphasis"><em>web.xml</em></span> document is displayed in <a class="xref" href="#https_aa" title="Example 12. The revised web.xml to support both HTTPS and users/roles security.">Example 12, “The revised <span class="emphasis"><em>web.xml</em></span> to support both HTTPS and users/roles security.”</a>.</p><div class="example"><a id="https_aa"></a><p class="title"><b>Example 12. The revised <span class="emphasis"><em>web.xml</em></span> to support both HTTPS and users/roles security.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;predictor&lt;/servlet-name&gt;
    &lt;servlet-class&gt;predictions2.PredictionsServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;security-role&gt;                                                <a id="CO1-50"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    &lt;role-name&gt;bigshot&lt;/role-name&gt;                               <a id="CO1-51"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    &lt;!-- other roles as needed --&gt;
  &lt;/security-role&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;                                            <a id="CO1-52"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
      &lt;role-name&gt;bigshot&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;login-config&gt;                                                 <a id="CO1-53"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;                             <a id="CO1-54"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
  &lt;/login-config&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;predictor&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><br class="example-break" /><p>The numbered lines in the revised <span class="emphasis"><em>web.xml</em></span> need clarification.</p><div class="variablelist"><dl><dt><span class="term">
Security role declaration
</span></dt><dd>
Line 1 declares a <code class="literal">security-role</code>, which is an <span class="emphasis"><em>authorization</em></span> role; and
line 2 sets the role’s name to <code class="literal">bigshot</code>. On the Tomcat side, a data store must contain the same
role name, with details to follow.
</dd><dt><span class="term">
Authorization constraint
</span></dt><dd>
The <code class="literal">security-constraint</code> element, introduced earlier, now contains two
specific constraints: the <code class="literal">user-data-constraint</code>, which enforces HTTPS transport, from the earlier
example; and the new <code class="literal">auth-constraint</code> (line 3), which is an authorization rather than an
authentication constraint in the context of
users/roles security. The authorization constraint specifies that access to the <span class="emphasis"><em>predictions2</em></span>
resource, the service and its operations, is restricted to a client authorized as a <code class="literal">bigshot</code>.
</dd><dt><span class="term">
User authentication method
</span></dt><dd><p class="simpara">
The <code class="literal">login-config</code> element (line 4) designates <code class="literal">BASIC</code> as the
user-authentication method (line 5). HTTP 1.1 supports four <span class="emphasis"><em>authentication types</em></span>: BASIC, FORM,
DIGEST, and CLIENT-CERT. These four types were designed with web sites in mind but are adaptable
to web services as well. Here is a summary of the differences:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The BASIC type, a holdover from HTTP 1.0, centers on a <span class="emphasis"><em>username</em></span> and a <span class="emphasis"><em>password</em></span>, each
passed from the client to the server for authentication. The username/password pair is encoded in
base64 but not encrypted unless, of course, HTTPS is also in play.
</li><li class="listitem">
The FORM type refines the BASIC type by providing a form-based authentication mechanism, with
specified names for the input fields in the form. This type also requires an error form to handle
authentication failures. Further, the authentication procedure is laid out in detail for the FORM variant,
unlike the BASIC variant.
For modern web sites, FORM-based authentication is best practice. The FORM type, like the BASIC
type, requires HTTPS or equivalent transport-level support to provide data encryption.
</li><li class="listitem">
The BASIC and FORM types require that the username and the <span class="emphasis"><em>password</em></span> be stored on the server side
because the server needs to compare the submitted username/password pair against the server’s own
copies of these. A modern user, aware of the threat that security breaches represent, may be
understandably wary of having a password stored on devices that the user does not control.  The
DIGEST type meets this challenge by sending a digest (hash value) of the password rather than the
password itself. Accordingly, only a digest of the password needs to be stored on the server.
The server-side login process computes the digest, compares the computed digest against the stored digest,
and grants
access only if these match. In general, digest or hash functions are <span class="emphasis"><em>one-way secure</em></span>: given the
digest and even the algorithm used to compute the digest, it is still computationally intractable to
recover the original password. Indeed, message digests are fixed-length; hence, from the digest itself
it is a taunting task to recover even the <span class="emphasis"><em>length</em></span> of the original password. The DIGEST type as well
requires HTTPS or the equivalent transport-level support to provide data encryption.
</li><li class="listitem">
The CLIENT-CERT type uses a digital certificate instead of a username/password or username/password-digest
pair for authentication. For user access to web sites, this approach may be impractical because a user may
wish to hit a web site from a device that does not have a copy of the user’s digital certificate. Also, such
certificates have expiration dates and so must be refreshed periodically. For web-service clients, by
contrast, the CLIENT-CERT type may have more appeal. For example, the client application might access the
digital certificate from a database or similar datastore that is managed automatically to ensure up-to-date
digital certificates.
</li></ul></div></dd></dl></div><p>The very simplicity of the BASIC type is attractive for clients against RESTful services, especially if
BASIC authentication is combined with HTTPS transport, which then provides the required username/password
encryption.</p><div class="section" title="1.5.1. Linking the Service web.xml with a Tomcat Security Realm"><div class="titlepage"><div><div><h4 class="title"><a id="_linking_the_service_emphasis_web_xml_emphasis_with_a_tomcat_security_realm"></a>1.5.1. Linking the Service <span class="emphasis"><em>web.xml</em></span> with a Tomcat Security Realm</h4></div></div></div><p>The revised <span class="emphasis"><em>web.xml</em></span> document specifies the type of HTTP authentication in use, BASIC, as well as the
authorization role, <code class="literal">bigshot</code>, required of client that accesses the <span class="emphasis"><em>predictions2</em></span> service. The next question is how
Tomcat puts this security information to use, in other words, how Tomcat’s container-managed security
works under the hood. Tomcat implements container-managed security with <span class="emphasis"><em>realms</em></span>, which are akin to
<span class="emphasis"><em>groups</em></span> in Unix-type operating systems. In simplest form, a realm is collection
of usernames and passwords together the authorization roles, if any, associated with the usernames. The purpose of a realm is
to coordinate various security resources in support of a single policy on access control. On the service side, security
information needs to be saved in datastore such as a relational database system; and Tomcat realms provide the details
about how the security information is to be saved and accessed.</p><p>Tomcat7 comes with six standard plug-ins, all of which have <code class="literal">Realm</code> in their names.
Developers are free to develop additional <code class="literal">Realm</code> plug-ins.
Here are the six native Tomcat plug-ins with a short description of each:</p><div class="variablelist"><dl><dt><span class="term">
JDBCRealm
</span></dt><dd>
The authentication information is stored in a relational database accessible through a JDBC driver.
</dd><dt><span class="term">
DataSourceRealm
</span></dt><dd>
The authentication information again is stored in a relational database and accessible through a
Java JDBC <code class="literal">DataSource</code>, which in turn is available through a JNDI (Java Naming and Directory Interface) lookup service.
</dd><dt><span class="term">
JNDIRealm
</span></dt><dd>
The authentication information is stored in an LDAP-based (Lightweight Directory Access Protocol) directory service, which is available
through a JNDI provider.
</dd><dt><span class="term">
UserDatabaseRealm
</span></dt><dd>
The authentication information is stored in a JNDI resource coordinated by default with the file
<span class="emphasis"><em>TOMCAT_HOME/conf/tomcat-users.xml</em></span>. This is the default realm in Tomcat7.
</dd><dt><span class="term">
MemoryRealm
</span></dt><dd>
The authentication information is read into memory, at Tomcat startup, from the file <span class="emphasis"><em>tomcat-users.xml</em></span>.
This is an earlier version of the <code class="literal">UserDatabaseRealm</code> and remains as an option for backward compatibility.
</dd><dt><span class="term">
JAASRealm
</span></dt><dd>
The authentication information is available through a JAAS (Java Authentication and Authorization Service) framework.
This is the most powerful but also the most complicated realm. Java Application Servers such as WebSphere and JBoss rely upon
JAAS providers for users/roles security; and this option is available in Tomcat as well.
</dd></dl></div><p>Under any of these choices, it is the Tomcat container rather than the application that becomes the security provider. With respect
to the options, the path of
least resistance leads to the default, the <code class="literal">UserDatabaseRealm</code>. Here is the datastore, the XML file
<span class="emphasis"><em>tomcat-users.xml</em></span>.
The five elements commented out act as Tomcat’s tutorial about how the file is to be used. My additions are lines
1 and 2: line 1 declares the security role used in line 2, which specifies a username and an associated
password:</p><pre class="screen">&lt;tomcat-users&gt;
  &lt;role rolename="bigshot"/&gt;                                         <a id="CO1-55"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
  &lt;user username="moe" password="MoeMoeMoe" roles="bigshot"/&gt;        <a id="CO1-56"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
&lt;/tomcat-users&gt;</pre><p>With the <code class="literal">UserDatabaseRealm</code> now configured, the security process can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The revised deployment file <span class="emphasis"><em>web.xml</em></span> requires not only HTTPS transport but also users/roles
authentication and authorization.
</li><li class="listitem">
To access the secured <span class="emphasis"><em>predictions2</em></span> service, a client must
provide a username and a password that match an entry in <span class="emphasis"><em>tomcat-users.xml</em></span>.
</li><li class="listitem">
For the authorization phase to succeed, a matching <code class="literal">user</code> entry in the file <span class="emphasis"><em>tomcat-users.xml</em></span> must
include <code class="literal">bigshot</code> among the <code class="literal">roles</code>.
</li></ul></div></div><div class="section" title="1.5.2. The Client-Side in Users/Roles Security"><div class="titlepage"><div><div><h4 class="title"><a id="_the_client_side_in_users_roles_security"></a>1.5.2. The Client-Side in Users/Roles Security</h4></div></div></div><p>On the service-side, Tomcat is responsible for conducting the user authentication and role authorization.
The burden
now shifts to the client, which must properly format, within an HTTPS request, the username
and password information. On the service side, the required changes are limited to the
web service’s configuration file, <span class="emphasis"><em>web.xml</em></span>, and to the Tomcat <code class="literal">UserDatabaseRealm</code> file,
<span class="emphasis"><em>tomcat-users.xml</em></span>. No code in the <span class="emphasis"><em>predictions2</em></span> service needs to change.</p><div class="example"><a id="https_aa_predictions_client"></a><p class="title"><b>Example 13. The <code class="literal">PredictionsHttpsClientAA</code> client against the <span class="emphasis"><em>predictions2</em></span> service.</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.security.cert.X509Certificate;
import java.security.SecureRandom;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import org.apache.commons.codec.binary.Base64;

public class PredictionsHttpsClientAA {
    private static final String endpoint = "https://localhost:8443/predictions2";
    private static final String truststore = "test.keystore";

    public static void main(String[ ] args) {
        new PredictionsHttpsClientAA().runTests();
    }
    private void runTests() {
        try {
            SSLContext sslCtx = SSLContext.getInstance("TLS");
            char[ ] password = "qubits".toCharArray();
            KeyStore ks = KeyStore.getInstance("JKS");
            FileInputStream fis = new FileInputStream(truststore);
            ks.load(fis, password);
            TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
            tmf.init(ks); // same as keystore
            sslCtx.init(null,                   // not needed, not challenged
                        tmf.getTrustManagers(),
                        new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
            // Proof of concept tests.
            String uname = "moe";
            String passwd = "MoeMoeMoe";
            getTest(uname, passwd);
            postTest(uname, passwd);
            getTestAll(uname, passwd);     // confirm POST test
            deleteTest(uname, passwd, "31");
            getTestAll(uname, passwd);     // confirm DELETE test
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private HttpsURLConnection getConnection(URL url,
                                             String verb,
                                             String uname,
                                             String passwd) {
        try {
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setRequestMethod(verb);
            // authentication (although header name is Authorization)
            String userpass = uname + ":" + passwd;
            String basicAuth = "Basic " +
               new String(new Base64().encode(userpass.getBytes()));
            conn.setRequestProperty ("Authorization", basicAuth);
            conn.setHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String host, SSLSession session) {
                        return host.equals("localhost"); // for development
                    }
                });
            return conn;
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTest(String uname, String passwd) {
        getTestAll(uname, passwd);
        getTestOne(uname, passwd, "31");
    }
    private void getTestAll(String uname, String passwd) {
        try {
            URL url = new URL(endpoint);
            HttpsURLConnection conn = getConnection(url, "GET", uname, passwd);
            conn.connect();
            readResponse("GET all request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void getTestOne(String uname, String passwd, String id) {
        try {
            URL url = new URL(endpoint + "?id=" + id);
            HttpsURLConnection conn = getConnection(url, "GET", uname, passwd);
            conn.connect();
            readResponse("GET request for " + id + ":\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void postTest(String uname, String passwd) {
        try {
            URL url = new URL(endpoint);
            HttpsURLConnection conn = getConnection(url, "POST", uname, passwd);
            conn.connect();
            writeBody(conn);
            readResponse("POST request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void deleteTest(String uname, String passwd, String id) {
        try {
            URL url = new URL(endpoint + "?id=" + id);
            HttpsURLConnection conn = getConnection(url, "DELETE", uname, passwd);
            conn.connect();
            readResponse("DELETE request:\n", conn);
            conn.disconnect();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void writeBody(HttpsURLConnection conn) {
        try {
            String pairs = "who=Freddy&amp;what=Avoid Friday nights if possible.";
            OutputStream out = conn.getOutputStream();
            out.write(pairs.getBytes());
            out.flush();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private void readResponse(String msg, HttpsURLConnection conn) {
        try {
            byte[ ] buffer = new byte[4096];
            InputStream in = conn.getInputStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            int n = 0;
            while ((n = in.read(buffer)) != -1) out.write(buffer, 0, n);
            in.close();
            System.out.println(new String(out.toByteArray())); // stringify and print
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PredictionsHttpsClientAA</code> (see <a class="xref" href="#https_aa_predictions_client" title="Example 13. The PredictionsHttpsClientAA client against the predictions2 service.">Example 13, “The <code class="literal">PredictionsHttpsClientAA</code> client against the <span class="emphasis"><em>predictions2</em></span> service.”</a>) adds users/roles security
on the client side to the earlier HTTPS client against the <span class="emphasis"><em>predictions2</em></span> service. The changes
are quite small. The <code class="literal">getConnection</code> method has three new lines:</p><pre class="screen">String userpass = uname + ":" + passwd;                                  <a id="CO1-57"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
String basicAuth = "Basic " +
                   new String(new Base64().encode(userpass.getBytes())); <a id="CO1-58"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
conn.setRequestProperty ("Authorization", basicAuth);                    <a id="CO1-59"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" /></pre><p>A <code class="literal">userpass</code> string is created as a key/value pair, with the colon <code class="literal">:</code> as the separator,
from the parameters <code class="literal">uname</code> and <code class="literal">passwd</code> (line 1). The <code class="literal">userpass</code> is then encoded in base64
and has <code class="literal">Basic</code> prepended (line 2). The result is inserted into the HTTPS headers, with
<code class="literal">Authorization</code> as the key. For <code class="literal">moe</code> as the username and <code class="literal">MoeMoeMoe</code> as the password, the
resulting header is:</p><pre class="screen">Authorization: Basic bW9lOk1vZU1vZU1vZQ==</pre><p>This set-up follows HTTP 1.1 guidelines and meets Tomcat expectations about how the
authentication/authorization information is to be formatted in the HTTPS request. As usual,
a client against a RESTful service needs to stay close to the HTTP/HTTPS metal.</p></div><div class="section" title="1.5.3. Using the curl Utility for HTTPS Testing"><div class="titlepage"><div><div><h4 class="title"><a id="_using_the_emphasis_curl_emphasis_utility_for_https_testing"></a>1.5.3. Using the <span class="emphasis"><em>curl</em></span> Utility for HTTPS Testing</h4></div></div></div><p>The <span class="emphasis"><em>curl</em></span> utility is an alternative to a full-blown RESTful client written in Java or some
other language. For the <span class="emphasis"><em>predictions2</em></span> service accessible through HTTPS and with
user-authentication/role-authorization in play, this <span class="emphasis"><em>curl</em></span> command sends a GET request:</p><pre class="screen">% curl --verbose --insecure --user moe:MoeMoeMoe \
       https://localhost:8443/predictions2</pre><p>The <code class="literal">--insecure</code> flag means that <span class="emphasis"><em>curl</em></span> goes through handshake process but does not verify
the digital certificates sent from the server; the verification would require that <span class="emphasis"><em>curl</em></span>
be pointed to the appropriate truststore file. In any case, the output from a sample run, edited
slightly for readability, is shown in <a class="xref" href="#curl_out" title="Example 14. The output from a curl request over HTTPS.">Example 14, “The output from a <span class="emphasis"><em>curl</em></span> request over HTTPS.”</a>.</p><div class="example"><a id="curl_out"></a><p class="title"><b>Example 14. The output from a <span class="emphasis"><em>curl</em></span> request over HTTPS.</b></p><div class="example-contents"><pre class="screen">* About to connect() to localhost port 8443 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 8443 (#0)
* successfully set certificate verify locations:
*   CAfile: none
  CApath: /etc/ssl/certs
* SSLv3, TLS handshake, Client hello (1):
* SSLv3, TLS handshake, Server hello (2):
* SSLv3, TLS handshake, CERT (11):
* SSLv3, TLS handshake, Server key exchange (12):
* SSLv3, TLS handshake, Server finished (14):
* SSLv3, TLS handshake, Client key exchange (16):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSL connection using EDH-RSA-DES-CBC3-SHA
* Server certificate:
    ...
*   SSL certificate verify result: self signed certificate (18), <a id="CO1-60"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    continuing anyway.
* Server auth using Basic with user 'moe'
&gt; GET /predictions2 HTTP/1.1
&gt; Authorization: Basic bW9lOk1vZU1vZU1vZQ==
&gt; User-Agent: curl/7.19.7 (x86_64-pc-linux-gnu) libcurl/7.19.7
              OpenSSL/0.9.8k zlib/1.2.3.3 libidn/1.15
&gt; Host: localhost:8443
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Cache-Control: private
&lt; Expires: Wed, 31 Dec 1969 18:00:00 CST
&lt; Transfer-Encoding: chunked
...
&lt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.6.0_21" class="java.beans.XMLDecoder"&gt;
...</pre></div></div><br class="example-break" /><p>In the <span class="emphasis"><em>curl</em></span> output, the character <code class="literal">&gt;</code> introduces text lines sent from <span class="emphasis"><em>curl</em></span> to the server, whereas
the character <code class="literal">&lt;</code> introduces text lines from from the server to <span class="emphasis"><em>curl</em></span>. The lines that begin
with a star <code class="literal">*</code> trace the TLS handshake process. Although <span class="emphasis"><em>curl</em></span> recognizes (line 1) that the
self-signed certificate from the server is worthless as a security credential, <span class="emphasis"><em>curl</em></span> continues the
process, again because of the
<code class="literal">--insecure</code> flag, by sending a GET request over HTTPS to the <span class="emphasis"><em>predictions2</em></span> service; and the
service responds with a list of the predictions.</p></div><div class="section" title="1.5.4. A @WebService under HTTPS with Users/Roles Security"><div class="titlepage"><div><div><h4 class="title"><a id="_a_webservice_under_https_with_users_roles_security"></a>1.5.4. A @WebService under HTTPS with Users/Roles Security</h4></div></div></div><p>Tomcat supports HTTPS transport and users/roles security for SOAP-based services as well.
A SOAP-based client built atop <span class="emphasis"><em>wsimport</em></span>-generated artifacts can use a slightly higher-level API than
its REST-style counterpart to insert the required security credentials into an HTTPS request. This
section uses a minimal SOAP-based service to focus on security in the client against the service.</p><div class="example"><a id="temp_convert"></a><p class="title"><b>Example 15. The SOAP-based <code class="literal">TempConvert</code> service.</b></p><div class="example-contents"><pre class="screen">package tc;
import javax.jws.WebService;
import javax.jws.WebMethod;

@WebService
public class TempConvert {
    @WebMethod
    public float c2f(float t) { return 32.0f + (t * 9.0f / 5.0f); }
    @WebMethod
    public float f2c(float t) { return (5.0f / 9.0f) * (t - 32.0f); }
}</pre></div></div><br class="example-break" /><p>The SOAP-based <code class="literal">TempConvert</code> service (see <a class="xref" href="#temp_convert" title="Example 15. The SOAP-based TempConvert service.">Example 15, “The SOAP-based <code class="literal">TempConvert</code> service.”</a>) has two operations: <code class="literal">f2c</code> converts temperatures
from fahrenheit to centigrade and <code class="literal">c2f</code> converts them from centigrade to fahrenheit. With respect to
security, the <span class="emphasis"><em>web.xml</em></span> for this service is essentially the same as for the RESTful and secure
<span class="emphasis"><em>predictions2</em></span> service. However, the <span class="emphasis"><em>web.xml</em></span> for the SOAP-based service needs to reference the Metro
<code class="literal">WSServlet</code> (line 2), which acts as the intermediary between the servlet container and the service (see
<a class="xref" href="#soap_web" title="Example 16. The web.xml document for the SOAP-based TempConvert service.">Example 16, “The <span class="emphasis"><em>web.xml</em></span> document for the SOAP-based <code class="literal">TempConvert</code> service.”</a>); and the
additional configuration file, <span class="emphasis"><em>sun-jaxws.xml</em></span>, is likewise required.</p><div class="example"><a id="soap_web"></a><p class="title"><b>Example 16. The <span class="emphasis"><em>web.xml</em></span> document for the SOAP-based <code class="literal">TempConvert</code> service.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;
&lt;web-app&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServletContextListener    <a id="CO1-61"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;wsservlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServlet                   <a id="CO1-62"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    &lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;security-role&gt;
    &lt;role-name&gt;bigshot&lt;/role-name&gt;
    &lt;!-- other roles as needed --&gt;
  &lt;/security-role&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;bigshot&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;
      &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;/login-config&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;wsservlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><br class="example-break" /><p>Lines 1 and 2 are the only changes to the <span class="emphasis"><em>web.xml</em></span> used in the earlier <span class="emphasis"><em>predictions2</em></span> service.
With the <span class="emphasis"><em>web.xml</em></span> and <span class="emphasis"><em>sun-jaxws.xml</em></span> in place, the <code class="literal">TempConvert</code> service can be
deployed in the usual way:</p><pre class="screen">% ant deploy -Dwar.name=tc</pre><p>How should the <span class="emphasis"><em>wsimport</em></span>-generated artifacts be generated for a service accessible only through
HTTPS? The attempt</p><pre class="screen">% wsimport -p tcClient -keep https://localhost:8443/tc?wsdl</pre><p>generates a <code class="literal">sun.security.validator.ValidatorException</code> precisely because <span class="emphasis"><em>wsimport</em></span> is unable to
conduct the HTTPS handshake: the utility does not have access to a truststore against which the
server’s digital certificate(s) can be verified.
The service is HTTPS-secured and, therefore, so is the service’s dynamically
generated WSDL. The <span class="emphasis"><em>wsgen</em></span> utility provides a workaround. The command</p><pre class="screen">% wsgen -cp . tc.TempConvert -wsdl</pre><p>generates the <span class="emphasis"><em>TempConvertService.wsdl</em></span> file and the <span class="emphasis"><em>TempConvertService_schema1.xsd</em></span> file. The
<span class="emphasis"><em>wsimport</em></span> utility now can be targeted at the WSDL:</p><pre class="screen">% wsmport -p tcClient -keep TempConvertService.wsdl</pre><p>The only drawback is that the service’s URL is not in the class <code class="literal">TempConvertService</code>
because the WSDL used is not generated dynamically. The <code class="literal">TempConvertClient</code> (see <a class="xref" href="#temp_convert_client" title="Example 17. The TempConvertClient against the SOAP-based TempConvert service.">Example 17, “The <code class="literal">TempConvertClient</code> against the SOAP-based <code class="literal">TempConvert</code> service.”</a>)
shows how to overcome this drawback.</p><div class="example"><a id="temp_convert_client"></a><p class="title"><b>Example 17. The <code class="literal">TempConvertClient</code> against the SOAP-based <code class="literal">TempConvert</code> service.</b></p><div class="example-contents"><pre class="screen">import tcClient.TempConvertService;
import tcClient.TempConvert;
import javax.xml.ws.BindingProvider;
import java.util.Map;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HttpsURLConnection;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

public class TempConvertClient {
    private static final String endpoint = "https://localhost:8443/tc";
    // Make the client "trusting" and handle the hostname verification.
    static {                                                                   <a id="CO1-63"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
                public boolean verify(String name, SSLSession session) {
                    return true; // allow everything
                }
            });
        try {
            TrustManager[ ] trustMgr = new TrustManager[ ] {
                new X509TrustManager() {
                    public X509Certificate[ ] getAcceptedIssuers() { return null; }
                    public void checkClientTrusted(X509Certificate[ ] cs, String t) { }
                    public void checkServerTrusted(X509Certificate[ ] cs, String t) { }
                }
            };
            SSLContext sslCtx = SSLContext.getInstance("TLS");
            sslCtx.init(null, trustMgr, null);
            HttpsURLConnection.setDefaultSSLSocketFactory(sslCtx.getSocketFactory());
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    public static void main(String args[ ]) {
        if (args.length &lt; 2) {
            System.err.println("Usage: TempConvertClient &lt;uname&gt; &lt;passwd&gt;");
            return;
        }
        String uname = args[0];
        String passwd = args[1];
        TempConvertService service = new TempConvertService();
        TempConvert port = service.getTempConvertPort();
        BindingProvider prov = (BindingProvider) port;                         <a id="CO1-64"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        prov.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
                                     endpoint);                                <a id="CO1-65"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        prov.getRequestContext().put(BindingProvider.USERNAME_PROPERTY,
                                     uname);                                   <a id="CO1-66"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        prov.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY,
                                     passwd);                                  <a id="CO1-67"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        System.out.println("f2c(-40.1) = " + port.f2C(-40.1f));
        System.out.println("c2f(-40.1) = " + port.c2F(-40.1f));
        System.out.println("f2c(+98.7) = " + port.f2C(+98.7f));
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">TempConvertClient</code> uses a <code class="literal">static</code> block (line 1) to make itself into a <span class="emphasis"><em>trusting</em></span> client
that does not check the server’s digital certificate during the HTTPS handshake; the <code class="literal">static</code>
block also instructs the <code class="literal">HostnameVerifier</code> to allow client access to any host,
including <span class="emphasis"><em>localhost</em></span>. The <code class="literal">static</code> block isolates the transport-level security
so that the focus can be kept on the users/roles security. By the way, the <code class="literal">static</code> block exploits the fact that
a JAX-WS client uses, under the hood, the <code class="literal">HttpsURLConnection</code> of earlier RESTful examples.</p><p>To gain access to the transport-level, in particular to the headers in the HTTPS request, the
<code class="literal">TempConvertClient</code> casts the <code class="literal">port</code> reference to a <code class="literal">BindingProvider</code> (line 2). The endpoint
then is set (line 3) to the correct URL because the <span class="emphasis"><em>wsimport</em></span>-generated classes do not have
a usable URL. The username and password, entered as command-line arguments,
are likewise placed in the HTTPS headers. This SOAP-based client need not bother with creating a
single string out the username and password or with encoding these in base64. Instead, the client
uses the intuitive</p><pre class="screen">BindingProvider.USERNAME_PROPERTY
BindingProvider.PASSWORD_PROPERTY</pre><p>keys and sets the value for each. After the set-up, the client makes three calls against the SOAP-based service. The output is:</p><pre class="screen">f2c(-40.1) = -40.055557
c2f(-40.1) = -40.18
f2c(+98.7) = 37.055557</pre></div><div class="section" title="1.5.5. Using a Digested Password Instead of a Password"><div class="titlepage"><div><div><h4 class="title"><a id="_using_a_digested_password_instead_of_a_password"></a>1.5.5. Using a Digested Password Instead of a Password</h4></div></div></div><p>A downside of BASIC authentication is that a client’s password must be stored, as is, on the server-side
so that the received password can be compared against the stored password. The DIGEST option requires
only that the <span class="emphasis"><em>hash value</em></span> of the password be stored on the server. The set-up for the DIGEST option
is trickier than for the BASIC option, however. Yet the BASIC option can be tweaked so that it behaves
just like the DIGEST option. This section illustrates.</p><p>Tomcat comes with a <span class="emphasis"><em>digest</em></span> utility: <span class="emphasis"><em>digest.sh</em></span> for Unixy systems and <span class="emphasis"><em>digest.bat</em></span> for Windows. The
command</p><pre class="screen">% digest.sh -a SHA MoeMoeMoe</pre><p>generates a 20-byte hash value, in hex, using the SHA-1 algorithm. Here is the value:</p><pre class="screen">0f9e52090a322d7f788db2ae6b603e8efbd7fbd1</pre><p>In the <span class="emphasis"><em>TOMCAT_HOME/conf/tomcat-users.xml</em></span> file, this value replaces the password for <code class="literal">moe</code> (line 1):</p><pre class="screen">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;tomcat-users&gt;
  &lt;role rolename="bigshot"/&gt;
  &lt;user username="moe"
        password="0f9e52090a322d7f788db2ae6b603e8efbd7fbd1"  <a id="CO1-68"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        roles="bigshot"/&gt;
&lt;/tomcat-users&gt;</pre><p>The file is otherwise unchanged.</p><p>The <span class="emphasis"><em>digest</em></span> utility is implemented with the <code class="literal">RealmBase.Digest</code> method, which can be used in a Java client. The
revised client against the <code class="literal">TempConvertService</code>, named <code class="literal">TempConvertClient2</code> (see <a class="xref" href="#temp_convert2" title="Example 18. The revised TempConvertClient2.">Example 18, “The revised <code class="literal">TempConvertClient2</code>.”</a>), illustrates.</p><div class="example"><a id="temp_convert2"></a><p class="title"><b>Example 18. The revised <code class="literal">TempConvertClient2</code>.</b></p><div class="example-contents"><pre class="screen">import tcClient.TempConvertService;
import tcClient.TempConvert;
...
import org.apache.catalina.realm.RealmBase;                                      <a id="CO1-69"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />

public class TempConvertClient2 {
    private static final String endpoint = "https://localhost:8443/tc";

    static {
       ...
    }
    public static void main(String args[ ]) {
        if (args.length &lt; 2) {
            System.err.println("Usage: TempConvertClient &lt;uname&gt; &lt;passwd&gt;");
            return;
        }
        String uname = args[0];
        String passwd = args[1];
        String passwdHash = RealmBase.Digest(passwd,  // password                <a id="CO1-70"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                                             "SHA",   // algorithm
                                             null);   // default encoding: utf-8
        TempConvertService service = new TempConvertService();
        TempConvert port = service.getTempConvertPort();
        BindingProvider prov = (BindingProvider) port;
        prov.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
                                     endpoint);
        prov.getRequestContext().put(BindingProvider.USERNAME_PROPERTY,
                                     uname);
        prov.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY,
                                     passwdHash);                                <a id="CO1-71"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        ...
    }
}</pre></div></div><br class="example-break" /><p>Most of the code in the <code class="literal">TempConvertClient2</code> client is the same as that in the original.
The <code class="literal">import</code> in line 1 is the first difference: the Tomcat libraries include the <code class="literal">RealmBase</code> class
whose <code class="literal">Digest</code> method is of interest (line 2). The <code class="literal">Digest</code> method generates the hash value for the
sample password, in this case <code class="literal">MoeMoeMoe</code>, which is given as a command-line argument. The hash value
instead of the actual password then is placed in the HTTPS headers (line 3). On the service-side,
the send hash value is compared against the hash value stored in the revised <span class="emphasis"><em>tomcat-users.xml</em></span>. The
ZIP with the sample code includes <span class="emphasis"><em>runClient.xml</em></span>, an Ant script to compile and execute the
<code class="literal">TempConvertClient2</code>. A sample invocation with output is:</p><pre class="screen">% ant -f runClient.xml -Darg1=moe -Darg2=MoeMoeMoe

Buildfile: run.xml
compile:
run:
     [java] f2c(-40.1) = -40.055557
     [java] c2f(-40.1) = -40.18
     [java] f2c(+98.7) = 37.055557</pre></div></div><div class="section" title="1.6. WS-Security"><div class="titlepage"><div><div><h3 class="title"><a id="_ws_security"></a>1.6. WS-Security</h3></div></div></div><p>WS-Security is a family of specifications (see <a class="xref" href="#fig_05_wss" title="Figure 6. The WS-Security specifications">Figure 6, “The WS-Security specifications”</a>) designed to augment wire-level security (<span class="emphasis"><em>e.g.</em></span>, HTTPS) and
container-managed security (<span class="emphasis"><em>e.g.</em></span>, Tomcat) by providing a
unified, transport-neutral, container-neutral, end-to-end framework for higher levels of security such
as message confidentiality and authentication/authorization.</p><div class="figure"><a id="fig_05_wss"></a><p class="title"><b>Figure 6. The WS-Security specifications</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0506.png" alt="images/jwsu_0506.png" /></div></div></div><br class="figure-break" /><p>The layered blocks above WS-Security in <a class="xref" href="#fig_05_wss" title="Figure 6. The WS-Security specifications">Figure 6, “The WS-Security specifications”</a> can be clarified briefly as follows. The first layer
consists of WS-Policy, WS-Trust, and WS-Privacy. The second layer of WS-SecureConversation, WS-Federation, and
WS-Authorization builds upon this first layer. The architecture is thus modular but also complicated. Here is a
short description of each specification, starting with the first layer:</p><div class="variablelist"><dl><dt><span class="term">
WS-Policy
</span></dt><dd>
This specification describes general security capabilities, constraints, and policies. For example, a
WS-Policy assertion could stipulate that a message requires security tokens or that a particular encryption algorithm be used.
</dd><dt><span class="term">
WS-Trust
</span></dt><dd>
This specification deals primarily with how security tokens are to be issued, renewed, and validated.
In general, the specification covers brokered trust relationships.
</dd><dt><span class="term">
WS-Privacy
</span></dt><dd>
This specification explains how services can state and enforce privacy policies. The specification also covers
 how a service can determine whether a requester intends to follow such policies.
</dd><dt><span class="term">
WS-SecureConversation
</span></dt><dd>
This specification covers, as the name indicates, secure web service conversations across different sites
and, therefore, across different security contexts and trust domains. The specification focuses on how a security context is
created and how security keys are derived and exchanged.
</dd><dt><span class="term">
WS-Federation
</span></dt><dd>
This specification addresses the challenge of managing security identities across different platforms and
organizations. At the heart of the challenge is how to maintain a single, authenticated identity (for example, Alice’s
security identity) in a heterogeneous security environment.
</dd><dt><span class="term">
WS-Authorization
</span></dt><dd>
This specification covers the management of authorization data such as security tokens and underlying
policies for granting access to secured resources.
</dd></dl></div><p>WS-Security is often associated with federated
      security in the broad sense, which has the goal of cleanly separating web service logic from the high-level security
concerns, in particular authentication/authorization, that challenge web service deployment. This separation of concerns is
meant to ease collaboration across computer systems and trust realms.</p><p>Recall that SOAP-based web services are meant to be transport-neutral. Accordingly, SOAP-based services cannot depend simply on
the reliable transport that HTTP and HTTPS provide, although most SOAP messages are transported over HTTP. HTTP and
HTTPS rest on TCP/IP (Transmission Control Protocol/Internet Protocol), which supports reliable messaging. What if TCP/IP
infrastructure is not available? The WS-ReliableMessaging specification addresses precisely the issue of delivering
SOAP-based services over unreliable infrastructure.</p><p>A SOAP-based service can rely on the authentication/authorization support that a web container such as Tomcat or an
application server such as Oracle WebLogic, JBoss, GlassFish, or WebSphere may provide. In this case, the service
outsources users/roles security to the service container. The WS-Security specifications are a guide to how
security in general can be handled from <span class="emphasis"><em>within</em></span> SOAP messaging. Accordingly, the WS-Security specifications
address security issues as part of SOAP itself rather than as the part of the infrastructure
that happens to be in place for a particular SOAP-based service. The goals of WS-Security are often summarized with
the phrase <span class="emphasis"><em>end-to-end</em></span> security, which means that security matters are not delegated to the either the transport level
(<span class="emphasis"><em>e.g.</em></span>, HTTPS)
or a particular service container (<span class="emphasis"><em>e.g.</em></span>, Tomcat) but, rather, handled directly through an appropriate security API.
A framework for end-to-end security needs to cover the
situation in which a message is routed through intermediaries, each of which may have to process the message, before
reaching the ultimate receiver; and end-to-end security thus focuses on message content rather than on the underlying transport
or the service container. As a result, SOAP messaging becomes considerably more complicated.</p><div class="section" title="1.6.1. Securing a @WebService with WS-Security"><div class="titlepage"><div><div><h4 class="title"><a id="_securing_a_webservice_with_ws_security"></a>1.6.1. Securing a @WebService with WS-Security</h4></div></div></div><p>In order to focus squarely on WS-Security, the sample web service (see <a class="xref" href="#echo_service" title="Example 19. The bare-bones Echo service.">Example 19, “The bare-bones <code class="literal">Echo</code> service.”</a>) is deliberately bare-bones.
Further, the <code class="literal">Endpoint</code> publisher is used to host the service despite the fact that <code class="literal">Endpoint</code> supports neither
wire-level security nor users/roles authentication and authorization. The very point of WS-Security is to provide security
<span class="emphasis"><em>within</em></span> SOAP messaging. The <code class="literal">Echo</code> service focuses on how WS-Security supports user authentication in particular.</p><div class="example"><a id="echo_service"></a><p class="title"><b>Example 19. The bare-bones <code class="literal">Echo</code> service.</b></p><div class="example-contents"><pre class="screen">package echoService;
import javax.jws.WebService;
import javax.jws.WebMethod;

@WebService
public class Echo {
    @WebMethod
    public String echo(String msg) { return "Echoing: " + msg; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">Echo</code> class gives no hint of WS-Security, which is
delegated to the handler level, in this case to the message handler <code class="literal">ServiceHandler</code>.
This separation of concerns means that, at the application level, the <code class="literal">Echo</code> service looks like any other
<code class="literal">@WebService</code>: the service is a collection of operations, in this case only the <code class="literal">echo</code> method.</p><div class="example"><a id="wss_publisher"></a><p class="title"><b>Example 20. The <code class="literal">EchoPublisher</code>, which publishes the <code class="literal">Echo</code> service.</b></p><div class="example-contents"><pre class="screen">package echoService;

import javax.xml.ws.Endpoint;
import javax.xml.ws.Binding;
import java.util.List;
import java.util.LinkedList;
import javax.xml.ws.handler.Handler;

public class EchoPublisher {
    public static void main(String[ ] args) {
        Endpoint endpoint = Endpoint.create(new Echo());    <a id="CO1-72"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        Binding binding = endpoint.getBinding();            <a id="CO1-73"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        List&lt;Handler&gt; hchain = new LinkedList&lt;Handler&gt;();   <a id="CO1-74"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        hchain.add(new ServiceHandler());                   <a id="CO1-75"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        binding.setHandlerChain(hchain);                    <a id="CO1-76"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        endpoint.publish("http://localhost:7777/echo");     <a id="CO1-77"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        System.out.println("http://localhost:7777/echo");
    }
}</pre></div></div><br class="example-break" /><p>The publisher (see <a class="xref" href="#wss_publisher" title="Example 20. The EchoPublisher, which publishes the Echo service.">Example 20, “The <code class="literal">EchoPublisher</code>, which publishes the <code class="literal">Echo</code> service.”</a>) first sets an <code class="literal">Echo</code> instance as the service endpoint (line 1)
and then gets the <code class="literal">Binding</code> (line 2) in order to register a service-side handler (lines 3, 4, and 5).
The publisher finishes its work by publishing the service at the specified URL (line 6).</p><p>At this point, a shift to the client-side may be helpful because the client, too, has a handler; and
the service-side handler validates the information that the client-side handler puts into the
SOAP request message.
The client-side handler inserts a username and a password into the header of every SOAP request
from the client. The service-side handler then verifies the identity of the user by using the password as
the credential that vouches for the identity. The client’s request hits the <code class="literal">Echo</code> service only if the
service-side handler is successful in its verification.</p><p>On the client-side and on the service-side, the labor is divided in similar ways. The client-side
message handler inserts the username and password into the outgoing SOAP message but relies upon the
<code class="literal">Prompter</code>, which in turn is a <code class="literal">CallbackHandler</code>, to prompt for and read in the username and password;
this <code class="literal">Callback</code> handler obscures but, in this example, does not encrypt the password.
The client-side message handler also inserts other security information into the SOAP request message
(see <a class="xref" href="#client_arch" title="Example 21. The client-side architecture in the Echo service.">Example 21, “The client-side architecture in the <code class="literal">Echo</code> service.”</a>).</p><div class="example"><a id="client_arch"></a><p class="title"><b>Example 21. The client-side architecture in the <code class="literal">Echo</code> service.</b></p><div class="example-contents"><pre class="screen">+---------------+  original  +---------------+  revised
| EchoClientWSS |-----------&gt;| ClientHandler |------------&gt;to service
+---------------+  SOAP msg  +---------------+  SOAP msg
                                 /|\
                 +----------+     |
                 | Prompter |-----+
                 +----------+
                  Get username/password</pre></div></div><br class="example-break" /><p>On the service-side, the message handler delegates verification to a <code class="literal">CallbackHandler</code> of
its own, the <code class="literal">Verifier</code> (see <a class="xref" href="#service_arch" title="Example 22. The service-side architecture in the Echo service.">Example 22, “The service-side architecture in the <code class="literal">Echo</code> service.”</a>). The <code class="literal">Verifier</code>, in turn, relies on other <code class="literal">CallbackHandler</code> instances
to extract the authentication information and to verify the sent username/password against
service-side copies of these. The architecture on the service-side thereby complements the architecture on the client-side.</p><div class="example"><a id="service_arch"></a><p class="title"><b>Example 22. The service-side architecture in the <code class="literal">Echo</code> service.</b></p><div class="example-contents"><pre class="screen">             request    +----------------+ verified  +--------------+
from client------------&gt;| ServiceHandler |----------&gt;| Echo service |
             SOAP msg   +-------+--------+ SOAP msg  +--------------+
                                |
                                |       +----------+
                                +------&gt;| Verifier |
                                        +----------+
                                         Verify username/password</pre></div></div><br class="example-break" /><p>An examination of a familiar request/response exchange, starring from a client request through the service response,
should cast light on the implementation details.
The <code class="literal">EchoClientWSS</code> client (see <a class="xref" href="#echo_client" title="Example 23. The sample EchoClientWSS against the Echo service.">Example 23, “The sample <code class="literal">EchoClientWSS</code> against the <code class="literal">Echo</code> service.”</a>) relies on the usual <span class="emphasis"><em>wsimport</em></span>-generated artifacts (lines 1 and 2)
to get a <code class="literal">port</code> reference (line 3), which is cast to the data type <code class="literal">BindingProvider</code> (line 4) so that the client-side
<code class="literal">SOAPHandler</code>, an instance of the <code class="literal">ClientHandler</code> class, can be linked dynamically with the client (line 5). With
this set-up in place, the <code class="literal">EchoClientWSS</code> then makes a call against the <code class="literal">Echo</code> service (line 6) and
prints the response for confirmation (line 7). All of the WS-Security code is relegated to the
<code class="literal">ClientHandler</code>.</p><div class="example"><a id="echo_client"></a><p class="title"><b>Example 23. The sample <code class="literal">EchoClientWSS</code> against the <code class="literal">Echo</code> service.</b></p><div class="example-contents"><pre class="screen">import java.util.List;
import java.util.LinkedList;
import javax.xml.ws.handler.Handler;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.Binding;
import echoClient.EchoService;                                       <a id="CO1-78"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
import echoClient.Echo;                                              <a id="CO1-79"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />

public class EchoClientWSS {
    public static void main(String[ ] args) {
        try {
            List&lt;Handler&gt; hchain = new LinkedList&lt;Handler&gt;();
            hchain.add(new ClientHandler());
            EchoService service = new EchoService();
            Echo port = service.getEchoPort();                       <a id="CO1-80"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            Binding binding = ((BindingProvider) port).getBinding(); <a id="CO1-81"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            binding.setHandlerChain(hchain);                         <a id="CO1-82"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
            String response = port.echo("Goodbye, cruel world!");    <a id="CO1-83"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            System.out.println("From Echo service: " + response);    <a id="CO1-84"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
        }
        catch (Exception e) { throw new RuntimeExceptione(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">ClientHandler</code> receives, from the underlying SOAP libraries on the client-side, a SOAP message that
represents a call to the <code class="literal">echo</code> operation in the <code class="literal">Echo</code> service. This message is
passed to the <code class="literal">ClientHandler</code> (see <a class="xref" href="#client_handler" title="Example 24. The client-side ClientHandler, which uses the Prompter.">Example 24, “The client-side <code class="literal">ClientHandler</code>, which uses the <code class="literal">Prompter</code>.”</a>), which does the WS-Security
work. The result of this work impacts only the SOAP header, not the
SOAP body; hence, the <code class="literal">ClientHandler</code> must be a <code class="literal">SOAPHandler</code>
in order to access the SOAP header.</p><div class="example"><a id="client_handler"></a><p class="title"><b>Example 24. The client-side <code class="literal">ClientHandler</code>, which uses the <code class="literal">Prompter</code>.</b></p><div class="example-contents"><pre class="screen">import java.util.Set;
import java.util.HashSet;
import javax.xml.namespace.QName;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;
import java.io.FileInputStream;
import java.io.File;
import com.sun.xml.wss.ProcessingContext;
import com.sun.xml.wss.SubjectAccessor;
import com.sun.xml.wss.XWSSProcessorFactory;
import com.sun.xml.wss.XWSSProcessor;

public class ClientHandler implements SOAPHandler&lt;SOAPMessageContext&gt; {
    private XWSSProcessor xwssClient;
    private boolean trace;

    public ClientHandler() {
        XWSSProcessorFactory fact = null;
        try {
            fact = XWSSProcessorFactory.newInstance();                              <a id="CO1-85"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            FileInputStream config = new FileInputStream(new File("client.xml"));   <a id="CO1-86"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            xwssClient =                                                            <a id="CO1-87"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                fact.createProcessorForSecurityConfiguration(config, new Prompter());
            config.close();
        }
        catch (Exception e) { throw new RuntimeException(e); }
        trace = true; // set to true to enable message dumps
    }
    // Add a security header block
    public Set&lt;QName&gt; getHeaders() {                                                <a id="CO1-88"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        String uri = "http://docs.oasis-open.org/wss/2004/01/" +
                     "oasis-200401-wss-wssecurity-secext-1.0.xsd";
        QName securityHdr = new QName(uri, "Security", "wsse");
        HashSet&lt;QName&gt; headers = new HashSet&lt;QName&gt;();
        headers.add(securityHdr);
        return headers;
    }
    public boolean handleMessage(SOAPMessageContext msgCtx) {
        Boolean outbound = (Boolean)
            msgCtx.get (MessageContext.MESSAGE_OUTBOUND_PROPERTY);
        SOAPMessage msg = msgCtx.getMessage();
        if (outbound.booleanValue()) {
            ProcessingContext pCtx = null;
            try {
                pCtx = xwssClient.createProcessingContext(msg);                     <a id="CO1-89"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
                pCtx.setSOAPMessage(msg);                                           <a id="CO1-90"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
                SOAPMessage secureMsg = xwssClient.secureOutboundMessage(pCtx);     <a id="CO1-91"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
                msgCtx.setMessage(secureMsg);                                       <a id="CO1-92"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />

                if (trace) dump("Outgoing message:", secureMsg);
            }
            catch (Exception e) { throw new RuntimeException(e); }
        }
        return true;
    }
    public boolean handleFault(SOAPMessageContext msgCtx) { return true; }
    public void close(MessageContext msgCtx) { }
    private void dump(String msg, SOAPMessage soapMsg) {
        try {
            System.out.println(msg);
            soapMsg.writeTo(System.out);
            System.out.println();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">ClientHandler</code> no-argument constructor creates an <code class="literal">XWSSProcessor</code> (lines 1 through 3),
which generates the WS-Security artifacts that go into the revised SOAP message. Two arguments
are required for the creation of the <code class="literal">XWSSProcessor</code>: a file from which configuration
information can be read and a <code class="literal">CallbackHandler</code>, in this case the <code class="literal">Prompter</code>, that provides the
username and password. The configuration file is minimalist:</p><pre class="screen">&lt;xwss:SecurityConfiguration
   xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"
   dumpMessages="true" &gt;
    &lt;xwss:UsernameToken digestPassword="false"/&gt;
&lt;/xwss:SecurityConfiguration&gt;</pre><p>The code for the <code class="literal">Prompter</code> (see <a class="xref" href="#prompter" title="Example 27. The Prompter callback handler, which helps the ClientHandler.">Example 27, “The <code class="literal">Prompter</code> callback handler, which helps the <code class="literal">ClientHandler</code>.”</a>) is examined shortly.</p><p>A SOAP message handler must define four methods: <code class="literal">getHeaders</code>, <code class="literal">handleMessage</code>, <code class="literal">handleFault</code>, and
<code class="literal">close</code>. Of the four methods, <code class="literal">getHeaders</code> executes first.
Earlier examples of SOAP handlers defined the <code class="literal">getHeaders</code> method but never put this method
to work. In this case, the <code class="literal">getHeaders</code> method (line 4) is put to work: the method adds an
empty header block in the SOAP message:</p><pre class="screen">&lt;S:Header&gt;
  &lt;wsse:Security
     xmlns:wsse="http://docs.oasis-open.org/ \
                 wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
     S:mustUnderstand="1"&gt;
  &lt;/wsse:Security&gt;
&lt;/S:Header&gt;</pre><p>Although this header block is empty, it does contain the <code class="literal">mustUnderstand</code> attribute, with a value of
<code class="literal">1</code> for <span class="emphasis"><em>true</em></span>; and WS-Security requires the attribute. Once the <code class="literal">getHeaders</code> method has done its part,
the <code class="literal">handleMessage</code> method then takes over to complete the work. This method creates a WS-Security
<span class="emphasis"><em>processing context</em></span> (line 5) that is used to transform the current SOAP message (line 6), with its newly added
<code class="literal">wsse:Security</code> header block, into a <span class="emphasis"><em>secured SOAP message</em></span> whose header contains the username and
password (lines 7 and 8). Behind the scenes, the <code class="literal">Prompter</code> instance works with the <code class="literal">XWSSProcessor</code> to provide
the required username and password. When the <code class="literal">handleMessage</code> method exits, the SOAP message has been
transformed into something much larger.
The client-side SOAP message before the handler operates is small (see <a class="xref" href="#before_msg" title="Example 25. The SOAP request before the ClientHandler transforms the message.">Example 25, “The SOAP request before the <code class="literal">ClientHandler</code> transforms the message.”</a>); but the
this message becomes significantly larger after the handler has done its work (see <a class="xref" href="#wss_request" title="Example 26. The SOAP request after the ClientHandler transforms the message.">Example 26, “The SOAP request after the <code class="literal">ClientHandler</code> transforms the message.”</a>).</p><div class="example"><a id="before_msg"></a><p class="title"><b>Example 25. The SOAP request before the <code class="literal">ClientHandler</code> transforms the message.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;S:Body&gt;
    &lt;ns2:echo xmlns:ns2="http://echoService/"&gt;
      &lt;arg0&gt;Goodbye, cruel world!&lt;/arg0&gt;
    &lt;/ns2:echo&gt;
  &lt;/S:Body&gt;
&lt;/S:Envelope&gt;</pre></div></div><br class="example-break" /><div class="example"><a id="wss_request"></a><p class="title"><b>Example 26. The SOAP request after the <code class="literal">ClientHandler</code> transforms the message.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;S:Header&gt;
    &lt;wsse:Security
       xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/\
                   oasis-200401-wss-wssecurity-secext-1.0.xsd"
       S:mustUnderstand="1"&gt;
      &lt;wsse:UsernameToken
         xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/\
                    oasis-200401-wss-wssecurity-utility-1.0.xsd"
         wsu:Id="XWSSGID-1365549760320-535388749"&gt;
        &lt;wsse:Username&gt;fred&lt;/wsse:Username&gt;                                    <a id="CO1-93"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        &lt;wsse:Password                                                         <a id="CO1-94"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
           Type="http://docs.oasis-open.org/wss/2004/01/\
                 oasis-200401-wss-username-token-profile-1.0#PasswordText"&gt;
          ****
        &lt;/wsse:Password&gt;
        &lt;wsse:Nonce                                                            <a id="CO1-95"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
           EncodingType="http://docs.oasis-open.org/wss/2004/01/\
                         oasis-200401-wss-soap-message-security-1.0#Base64Binary"&gt;
          Q945eYMcu3NWuq90IjmNXjDy
        &lt;/wsse:Nonce&gt;
        &lt;wsu:Created&gt;...&lt;/wsu:Created&gt;
      &lt;/wsse:UsernameToken&gt;
    &lt;/wsse:Security&gt;
  &lt;/S:Header&gt;
  &lt;S:Body&gt;
    &lt;ns2:echo xmlns:ns2="http://echoService/"&gt;
      &lt;arg0&gt;Goodbye, cruel world!&lt;/arg0&gt;
    &lt;/ns2:echo&gt;
  &lt;/S:Body&gt;
&lt;/S:Envelope&gt;</pre></div></div><br class="example-break" /><p>The outgoing SOAP request now has, in the header, three items of security interest:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The username, which is the client’s identity (line 1).
</li><li class="listitem">
The obscured but not encrypted password, which is the credential that vouches for the username (line 2).
</li><li class="listitem">
A <span class="emphasis"><em>cryptographic nonce</em></span>, a randomly generated value that is used just once
in order to thwart so-called <span class="emphasis"><em>replay attacks</em></span> (line 3). Each time that the <code class="literal">EchoClientWSS</code> sends a request
to the <code class="literal">Echo</code> service, the username and password might be the same but the nonce would differ
from preceding ones; and the WSS libraries on the service-side validate the nonce.
</li></ul></div><p>The low-level work on the client-side falls to the <code class="literal">Prompter</code> class (see <a class="xref" href="#prompter" title="Example 27. The Prompter callback handler, which helps the ClientHandler.">Example 27, “The <code class="literal">Prompter</code> callback handler, which helps the <code class="literal">ClientHandler</code>.”</a>, which implements
the <code class="literal">CallbackHandler</code> interface by defining the <code class="literal">handle</code> method. The details are tedious but the
gist is clear: the <code class="literal">Prompter</code>, in a production environment, would prompt for a username and
password by using a <code class="literal">UsernameCallback</code> (line 1) and a <code class="literal">PasswordCallback</code>, respectively. The
<code class="literal">XWSSProcessor</code>, which has access to the two callbacks through the <span class="emphasis"><em>processing context</em></span>,
extracts the username and password so that these can be inserted into the outgoing SOAP message.</p><div class="example"><a id="prompter"></a><p class="title"><b>Example 27. The <code class="literal">Prompter</code> callback handler, which helps the <code class="literal">ClientHandler</code>.</b></p><div class="example-contents"><pre class="screen">import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import com.sun.xml.wss.impl.callback.PasswordCallback;
import com.sun.xml.wss.impl.callback.PasswordValidationCallback;
import com.sun.xml.wss.impl.callback.UsernameCallback;
import java.io.BufferedReader;
import java.io.InputStreamReader;

// For ease of testing, the username and password are
// hard-wired in the handle method with local variables
// username and password. For production, the hard-wirings
// would be removed.
public class Prompter implements CallbackHandler {
    private String readLine() {
        String line = null;
        try {
            line = new BufferedReader(new InputStreamReader(System.in)).readLine();
        }
        catch(Exception e) { throw new RuntimeException(e); }
        return line;
    }
    // Prompt for and read the username and the password.
    public void handle(Callback[ ] callbacks) {
        try {
            for (int i = 0; i &lt; callbacks.length; i++) {
                if (callbacks[i] instanceof UsernameCallback) {
                    UsernameCallback cb = (UsernameCallback) callbacks[i];   <a id="CO1-96"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
                    /* Disable for testing.
                    System.out.print("Username: ");
                    String username = readLine();
                    */
                    String username = "fred"; // hard-wire for testing
                    if (username != null) cb.setUsername(username);
                }
                else if (callbacks[i] instanceof PasswordCallback) {
                    PasswordCallback cb = (PasswordCallback) callbacks[i];   <a id="CO1-97"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                    /* Disable for testing
                    System.out.print("Password: ");
                    String password = readLine();
                    */
                    String password = "rockbed"; // hard-wire for testing
                    if (password != null) cb.setPassword(password);
                }
            }
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>On the client-side, the <code class="literal">XWSSProcessor</code> could do could more than it does in this example. For instance,
the security processor could encrypt the blocks in the SOAP header, particularly the one with the password,
and encrypt even the payload in the
SOAP body. However, this first look at WS-Security is focused on the architecture and flow of control; and these additional steps
would distract from that focus. It is now time to move over to the service-side.</p><p>On the service-side, the incoming SOAP message goes to the <code class="literal">ServiceHandler</code> (see <a class="xref" href="#wss_handler" title="Example 28. The service-side ServiceHandler.">Example 28, “The service-side <code class="literal">ServiceHandler</code>.”</a>), which
verifies the security header blocks that the <code class="literal">ClientHandler</code> injects into the SOAP request. This handler
also pares down the incoming message (see <a class="xref" href="#wss_request" title="Example 26. The SOAP request after the ClientHandler transforms the message.">Example 26, “The SOAP request after the <code class="literal">ClientHandler</code> transforms the message.”</a>) to an ordinary-looking SOAP request:</p><pre class="screen">&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;S:Header/&gt;
  &lt;S:Body&gt;
    &lt;ns2:echo xmlns:ns2="http://echoService/"&gt;
      &lt;arg0&gt;Goodbye, cruel world!&lt;/arg0&gt;
    &lt;/ns2:echo&gt;
  &lt;/S:Body&gt;
&lt;/S:Envelope&gt;</pre><p>This is almost the very request that the <code class="literal">EchoClientWSS</code> generates <span class="emphasis"><em>before</em></span> the client-side handler
goes into action. The one difference is that the pared-down, incoming message has a SOAP header—but an empty one.</p><div class="example"><a id="wss_handler"></a><p class="title"><b>Example 28. The service-side <code class="literal">ServiceHandler</code>.</b></p><div class="example-contents"><pre class="screen">package echoService;

import java.util.Set;
import java.util.HashSet;
import javax.xml.namespace.QName;
import javax.xml.soap.SOAPMessage;
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;
import java.io.ByteArrayInputStream;
import com.sun.xml.wss.ProcessingContext;
import com.sun.xml.wss.SubjectAccessor;
import com.sun.xml.wss.XWSSProcessorFactory;
import com.sun.xml.wss.XWSSProcessor;

public class ServiceHandler implements SOAPHandler&lt;SOAPMessageContext&gt; {
    private XWSSProcessor xwssServer = null;
    private boolean trace;

    public ServiceHandler() {
        XWSSProcessorFactory fact = null;
        try {
            fact = XWSSProcessorFactory.newInstance();                     <a id="CO1-98"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            ByteArrayInputStream config = getConfig();                     <a id="CO1-99"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            xwssServer =                                                   <a id="CO1-100"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                fact.createProcessorForSecurityConfiguration(config,
                                                             new Verifier());
        }
        catch (Exception e) { throw new RuntimeException(e); }
        trace = true; // set to true to enable message dumps
    }
    public Set&lt;QName&gt; getHeaders() {                                       <a id="CO1-101"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        String uri = "http://docs.oasis-open.org/wss/2004/01/" +
                     "oasis-200401-wss-wssecurity-secext-1.0.xsd";
        QName securityHdr = new QName(uri, "Security", "wsse");            <a id="CO1-102"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        HashSet&lt;QName&gt; headers = new HashSet&lt;QName&gt;();
        headers.add(securityHdr);
        return headers;                                                    <a id="CO1-103"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
    }
    public boolean handleMessage(SOAPMessageContext msgCtx) {
        Boolean outbound = (Boolean)
            msgCtx.get (MessageContext.MESSAGE_OUTBOUND_PROPERTY);
        SOAPMessage msg = msgCtx.getMessage();
        if (!outbound.booleanValue()) {
            // Validate the message.
            try{
                ProcessingContext pCtx =
                   xwssServer.createProcessingContext(msg);
                pCtx.setSOAPMessage(msg);
                SOAPMessage verifiedMsg =
                   xwssServer.verifyInboundMessage(pCtx);                  <a id="CO1-104"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
                msgCtx.setMessage(verifiedMsg);                            <a id="CO1-105"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
                if (trace) dump("Incoming message:", verifiedMsg);
            }
            catch(Exception e) { throw new RuntimeException(e); }
        }
        return true;
    }
    public boolean handleFault(SOAPMessageContext msgCtx) { return true; }
    public void close(MessageContext msgCtx) { }
    private void dump(String msg, SOAPMessage soapMsg) {
        try {
            System.out.println(msg);
            soapMsg.writeTo(System.out);
            System.out.println();
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    private ByteArrayInputStream getConfig() {                             <a id="CO1-106"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
        String config =
            "&lt;xwss:SecurityConfiguration " +
            "xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\" " +
            "dumpMessages=\"true\"&gt;&lt;xwss:RequireUsernameToken " +
            "passwordDigestRequired=\"false\"/&gt; " +
            "&lt;/xwss:SecurityConfiguration&gt;";
        return new ByteArrayInputStream(config.getBytes());
    }
}</pre></div></div><br class="example-break" /><p>The structure of the <code class="literal">ServiceHandler</code> is very close to that of the <code class="literal">ClientHandler</code>. In the
<code class="literal">ServiceHandler</code>, the <code class="literal">handleMessage</code> method is interested only in in-coming SOAP messages,
that is, requests. This handler has a <code class="literal">XWSSProcessor</code> (lines 1 through 3) created from a hard-wired configuration
document (line 9) and associated with a <code class="literal">Verifier</code> instance, a <code class="literal">Callbackhandler</code> that extracts the
security information—the nonce, the username, and the password—from the SOAP header for verification.
Once the SOAP request has been validated, the newly verified and simplified SOAP message is passed on to
the usual SOAP libraries, which transform the XML document into the appropriate Java objects so that the
<code class="literal">Echo</code> service can do its thing.</p><p>The <code class="literal">ServiceHandler</code> also makes use of the <code class="literal">getHeaders</code> method, which is particularly important with respect to
the SOAP response from the <code class="literal">EchoService</code>.
Recall that the <code class="literal">ServiceHandler</code>, like every handler, is inherently
bi-directional. The <code class="literal">handleMessage</code> method is coded so that this method ignores outgoing messages; but
the <code class="literal">getHeaders</code> method injects, into the SOAP response from the <code class="literal">Echo</code> service, a WS-Security
header with the <code class="literal">mustUnderstand</code> attribute set to <span class="emphasis"><em>true</em></span>. In effect, the <code class="literal">ServiceHandler</code> is demanding
that any receiver of the SOAP response, including the <code class="literal">EchoClientWSS</code>, stick by the WS-Security rules.
If the <code class="literal">getHeaders</code> method simply returned <code class="literal">null</code>, a client-side exception would be thrown because the
incoming message would not be formatted according to WS-Security standards.</p><p>The service-side <code class="literal">Verifier</code>, like the client-side <code class="literal">Prompter</code>, is a <code class="literal">CallbackHandler</code> delegated to
do grunt work. In a production environment, the <code class="literal">Verifier</code> might check the username and
password against a database record; but here, for simplicity, these are hard-wired in the code.
The <code class="literal">Verifier</code> also uses a <code class="literal">PlainTextPasswordVerifier</code> because the password itself rather than
a hash value of the password were sent in the message.</p><div class="example"><a id="verifier"></a><p class="title"><b>Example 29. The service-side <code class="literal">Verifier</code>, a callback handler that helps the <code class="literal">ServiceHandler</code>.</b></p><div class="example-contents"><pre class="screen">package echoService;

import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import com.sun.xml.wss.impl.callback.PasswordCallback;
import com.sun.xml.wss.impl.callback.PasswordValidationCallback;
import com.sun.xml.wss.impl.callback.UsernameCallback;

// Verifier handles service-side callbacks for password validation.
public class Verifier implements CallbackHandler {
    // Username/password hard-coded for simplicity and clarity.
    private static final String _username = "fred";
    private static final String _password = "rockbed";

    // For password validation, set the validator to the inner class below.
    public void handle(Callback[ ] callbacks) throws UnsupportedCallbackException {
        for (int i = 0; i &lt; callbacks.length; i++) {
            if (callbacks[i] instanceof PasswordValidationCallback) {
                PasswordValidationCallback cb =
                    (PasswordValidationCallback) callbacks[i];
                if (cb.getRequest() instanceof
                    PasswordValidationCallback.PlainTextPasswordRequest)
                    cb.setValidator(new PlainTextPasswordVerifier());
            }
            else
                throw new UnsupportedCallbackException(null, "Not needed");
        }
    }
    // Encapsulated validate method verifies the username/password.
    private class PlainTextPasswordVerifier
        implements PasswordValidationCallback.PasswordValidator {               <a id="CO1-107"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        public boolean validate(PasswordValidationCallback.Request req)
              throws PasswordValidationCallback.PasswordValidationException {
            PasswordValidationCallback.PlainTextPasswordRequest plain_pwd =
                (PasswordValidationCallback.PlainTextPasswordRequest) req;
            return_username.equals(plain_pwd.getUsername()) &amp;&amp;
                  _password.equals(plain_pwd.getPassword());
        }
    }
}</pre></div></div><br class="example-break" /><p>On a successful verification, the <code class="literal">Verifier</code> validates <code class="literal">fred</code> (the username) as an <span class="emphasis"><em>authenticated subject</em></span>
whose <span class="emphasis"><em>public credential</em></span> is the name <code class="literal">fred</code> and whose <span class="emphasis"><em>private credential</em></span> is the password that vouches
for Fred’s identity.</p><p>The security illustrated in this sample could be ratcheted up to Mutual Challenge
Security (MCS) with digital certificates used on both sides for peer authentication. Further, the
contents of SOAP messages could be encrypted at the SOAP level, which would result in significantly larger
SOAP headers that specified all of the cryptographic information: encryption and message digest
algorithms, digital certificate formats, policies on confidentiality, encoding practices, specification
of which parts of the SOAP message are to be encrypted and even digitally signed, and so on.</p><div class="sidebar" title="Compiling and running the Echo service and the EchoClientWSS."><a id="wss_jar"></a><p class="title"><b>Compiling and running the <code class="literal">Echo</code> service and the <code class="literal">EchoClientWSS</code>.</b></p><p>The WS-Security packages do not ship with core Java but can be downloaded, in a single JAR file, from
<span class="emphasis"><em>download.java.net/maven/1/com.sun.xml.wss/jars</em></span>. The current version, <span class="emphasis"><em>xws-security-3.0.jar</em></span>, is included
in the ZIP file with the sample code. The ZIP file also includes an executable JAR for the service and
Ant script to compile and execute the
client.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
The <span class="emphasis"><em>EchoPublisher.jar</em></span> file can be used to launch the publisher:
</p><pre class="screen">% java -jar EchoPublisher.jar</pre></li><li class="listitem"><p class="simpara">
The script <span class="emphasis"><em>runClient.xml</em></span> can be used to compile and execute the <code class="literal">EchoClientWSS</code>:
</p><pre class="screen">% ant -f runClient.xml</pre><p class="simpara">The client-side message handler, like its service-side counterpart, has a <code class="literal">dump</code> utility that can
be turned on or off in the code. With the <code class="literal">dump</code> turned off, the output should be similar to:</p><pre class="screen">Buildfile: runClient.xml
compile:
    [javac] Compiling 4 source files to /home/mkalin/jwsur2/ch6/wss
run:
     [java] com.sun.xml.wss.impl.filter.DumpFilter process
     [java] From Echo service: Echoing: Goodbye, cruel world!</pre></li></ul></div><p>The client uses <span class="emphasis"><em>wsimport</em></span>-generated artifacts, which are created in the usual way:</p><pre class="screen">% wsimport -p echoClient -keep http://localhost:777/echo?wsdl</pre><p>In a production environment, the <code class="literal">Prompter</code> on the client-side would read the
username and password either from a data store or interactively, with the latter as
the default. It is easier to execute the client from the Ant script <span class="emphasis"><em>runClient.xml</em></span>
without any interaction; hence, for testing purposes, the username and password
are hard-wired in the code. For a more realistic experience, the
<code class="literal">Prompter</code> sections currently commented out can be uncommented. In this case,
the <code class="literal">Prompter</code> awaits client input. At the command-prompt, the input should be</p><pre class="screen">fred
rockbed</pre><p>These are the username and password that the <code class="literal">ServiceHandler</code> will verify.</p><p>Also in a production environment, the <code class="literal">Verifier</code> on the service-side would
verify a received username/password pair against a data store such as database.
Again for simplicity, the <code class="literal">Verifier</code> has the data hard-wired in the code.</p></div></div></div><div class="section" title="1.7. What’s Next?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_8217_s_next"></a>1.7. What’s Next?</h3></div></div></div><p>The examples so far have published RESTful and SOAP-based services with command-line utilities such as
<code class="literal">Endpoint</code> and production-grade web servers such as Tomcat and Jetty.
At the production level, Tomcat or Jetty represent a lightweight option; and a
Java Application Server (JAS) such as  IBM WebSphere, JBoss, GlassFish (the reference implementation), or
Oracle WebLogic (formerly BEA WebLogic) represents a heavier-weight option. In the early 2000s, the
<span class="emphasis"><em>lightweight Java movement</em></span>, often associated with the Spring framework (<span class="emphasis"><em>www.springsource.org</em></span>), emerged as
a reaction against the complexities of J2EE and the JASes used to deliver J2EE applications.
In the meantime, the move from J2EE to Java EE 5 and 6 has meant significant weight loss for JASes
because Java EE 5/6 offers a lightweight alternative to the earlier J2EE. The popular JASes now support
the updated Java EE specifications. Packaging and configuration
have become significantly easier with the new JAS versions, which have administrative and other utilities that
make the JAS an attractive option for deploying web services. For example, Java EE applications now can
express configuration information with annotations instead of with complicated XML documents; indeed, a Java EE
application, including a web service, officially can be deployed without any configuration document, although
the <span class="emphasis"><em>web.xml</em></span> remains the rule rather than the exception for both web sites and web services. The next chapter considers
the publication of REST-style and SOAP-based services under GlassFish and TomcatEE, emphasizing the nuts-and-bolts
details of such software but also the trade-offs involved in using a JAS for deployment.</p></div></div></div></body></html>

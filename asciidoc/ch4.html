<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#jwsur_2nd_chapter_4">1. SOAP-Based Web Services</a></span></dt><dd><dl><dt><span class="section"><a href="#_jax_ws">1.1. JAX-WS</a></span></dt><dt><span class="section"><a href="#_a_soap_based_web_service">1.2. A SOAP-based Web Service</a></span></dt><dt><span class="section"><a href="#_the_literal_randservice_literal_in_two_files">1.3. The <code class="literal">RandService</code> in Two Files</a></span></dt><dt><span class="section"><a href="#_clients_against_the_literal_randservice_literal">1.4. Clients against the <code class="literal">RandService</code></a></span></dt><dt><span class="section"><a href="#_the_wsdl_service_contract_in_detail">1.5. The WSDL Service Contract in Detail</a></span></dt><dt><span class="section"><a href="#_soap_based_clients_against_amazon_8217_s_e_commerce_service">1.6. SOAP-based Clients against Amazon’s E-Commerce Service</a></span></dt><dt><span class="section"><a href="#_what_8217_s_next">1.7. What’s Next?</a></span></dt></dl></dd></dl></div><div class="section" title="1. SOAP-Based Web Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="jwsur_2nd_chapter_4"></a>1. SOAP-Based Web Services</h2></div></div></div><div class="section" title="1.1. JAX-WS"><div class="titlepage"><div><div><h3 class="title"><a id="_jax_ws"></a>1.1. JAX-WS</h3></div></div></div><p>JAX-WS (Java API for XML - Web Services) is an API for producing and consuming web services, REST-style and SOAP-based.
Chapter 2 introduced, with a Restful example, the JAX-WS <code class="literal">@WebServiceProvider</code> annotation, which can be used for either
a REST-style or a SOAP-based service. This chapter introduces the <code class="literal">@WebService</code> annotation, in effect a refinement of
<code class="literal">@WebServiceProvider</code>; and a <code class="literal">@WebService</code> is emphatically SOAP-based.
JAX-WS
is thus sufficiently rich and varied that it might better be described as a collection of APIs. JAX-WS
is the successor to JAX-RPC, which derives from the XML-RPC discussed in Chapter 1.
The reference implementation for JAX-WS is part of the open-source GlassFish project and is named
GlassFish Metro or just Metro for short (<span class="emphasis"><em>metro.java.net</em></span>). The current version of JAX-WS is 2.2.x.
JAX-WS officially is part of enterprise Java but, with JDK 1.6 or greater, JAX-WS services can be compiled and published
using only core Java.
SOAP-based services in JAX-WS can be published with a standard Java web server such as Tomcat or
Jetty; and there is also a convenient <code class="literal">Endpoint</code> publisher, used earlier to publish a RESTful service.</p><p>Apache Axis2 (<span class="emphasis"><em>apache.axis.org</em></span>) is an alternative implementation of JAX-WS. Axis2, the successor to Axis,
is based on JAX-WS but has additional features. Yet another JAX-WS implementation is Apache CXF (<span class="emphasis"><em>cxf.apache.org</em></span>).
This chapter focuses on the Metro implementation of JAX-WS but
the next chapter includes an Axis2 service and client. The Metro, Axis2, and Apache CXF implementations of JAX-WS are
sufficiently close that a programmer fluent in one implementation should be able to move easily into any other
implementation.</p><p>SOAP is an XML dialect that has two W3C-sanctioned versions: 1.1 and 1.2; and SOAP officially is no longer an
acronym. The differences between the versions of SOAP are more about
infrastructure than API. For example, the media type for a SOAP 1.1 message is <code class="literal">text/xml</code>, whereas this type
changes in SOAP 1.2 to <code class="literal">application/soap+xml</code>. The SOAP 1.2 processing model is more thoroughly and precisely specified
than is the SOAP 1.1 model; and SOAP 1.2 has an official <span class="emphasis"><em>binding framework</em></span> that opens the
way to using transport protocols other than HTTP for delivering SOAP messages. In practice, however, HTTP remains the
dominant transport for both SOAP 1.1 and SOAP 1.2.
In the major SOAP frameworks of Java and DotNet, SOAP 1.1 is the default; but both systems support SOAP 1.2 as well.</p><p>SOAP has a <span class="emphasis"><em>basic profile</em></span>, which comes from the WS-I (Web Services-Interoperability) consortium to encourage and
support interoperability among web service languages and technologies. Beyond the basic profile are various initiatives, some
of which are covered in later chapters; these initiatives (for instance, WS-Reliability and WS-Security)
often are grouped under the acronym WS-*.
WSIT (Web Services Interoperability Technology)
is a related set of guidelines that promotes interoperability specifically between Java and DotNet, in particular DotNet’s
WCF (Windows Communication Foundation). WCF is a framework for developing service-oriented applications that would include but also
go beyond SOAP-based web services (<span class="emphasis"><em>metro.java.net/guide</em></span>). From time to time, this chapter refers to one or another SOAP specification in
order to clarify a particular service or client; but the emphasis in this chapter remains on coding services and their
clients. Under otherwise specified, the examples are in SOAP 1.1.</p></div><div class="section" title="1.2. A SOAP-based Web Service"><div class="titlepage"><div><div><h3 class="title"><a id="_a_soap_based_web_service"></a>1.2. A SOAP-based Web Service</h3></div></div></div><p>JAX-WS, like JAX-RS, uses annotations and machine-generated JAX-WS code is awash with these. The first
example is stingy in its use of annotations in order to underscore exactly what is required for a
SOAP-based service. Later examples introduce additional annotations.</p><p>The <code class="literal">RandService</code> class (see <a class="xref" href="#Ex1" title="Example 1. A SOAP-based service with two operations.">Example 1, “A SOAP-based service with two operations.”</a>) defines a SOAP-based service with two operations, each an annotated Java method:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Operation <code class="literal">next1</code> takes no arguments and returns one randomly generated integer.
</li><li class="listitem">
Operation <code class="literal">nextN</code> takes one argument, the number of randomly generated integers desired, and
returns a list (in this implementation, an array) of integers.
</li></ul></div><div class="example"><a id="Ex1"></a><p class="title"><b>Example 1. A SOAP-based service with two operations.</b></p><div class="example-contents"><pre class="screen">package rand;

import javax.jws.WebService;
import javax.jws.WebMethod;
import java.util.Random;

@WebService                                                        <a id="CO1-1"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
public class RandService {
    private static final int maxRands = 16;

    @WebMethod // optional but helpful annotation                 <a id="CO1-2"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    public int next1() { return new Random().nextInt(); }
    @WebMethod // optional but helpful annotation                 <a id="CO1-3"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
    public int[ ] nextN(final int n) {
        final int k = (n &gt; maxRands) ? maxRands : Math.abs(n);
        int[ ] rands = new int[k];
        Random r = new Random();
        for (int i = 0; i &lt; k; i++) rands[i] = r.nextInt();
        return rands;
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">@WebService</code> annotation (line 1) marks the <code class="literal">RandService</code> POJO class as a web service; and the
<code class="literal">@WebMethod</code> annotation (lines 2 and 3) then specifies which of the encapsulated methods
is a service operation. In this example, the <code class="literal">RandService</code> class has only two
methods and each of these is annotated as <code class="literal">@WebMethod</code>. The <code class="literal">@WebMethod</code> annotation is optional but
recommended. In a class annotated as a <code class="literal">@WebService</code>, a <code class="literal">public</code> instance
method is thereby a service <span class="emphasis"><em>operation</em></span> even if the method is
not annotated.
This SOAP service code is compiled in the
usual way, assuming JDK 1.6 or greater.</p><p>Recall that core Java 6 or greater includes the <code class="literal">Endpoint</code> class for publishing web services,
SOAP-based (<code class="literal">@WebService</code>) and REST-style (<code class="literal">@WebServiceProvider</code>) alike.
The class <code class="literal">RandPublisher</code> (see <a class="xref" href="#Ex2" title="Example 2. An Endpoint published for the RandService SOAP-based web service.">Example 2, “An <code class="literal">Endpoint</code> published for the <code class="literal">RandService</code> SOAP-based web service.”</a>) is the
<code class="literal">Endpoint</code> publisher for the <code class="literal">RandService</code>.</p><div class="example"><a id="Ex2"></a><p class="title"><b>Example 2. An <code class="literal">Endpoint</code> published for the <code class="literal">RandService</code> SOAP-based web service.</b></p><div class="example-contents"><pre class="screen">package rand;

import javax.xml.ws.Endpoint;
public class RandPublisher {
    public static void main(String[ ] args) {
        final String url = "http://localhost:8888/rs";                    <a id="CO1-4"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        System.out.println("Publishing RandService at endpoint " + url);
        Endpoint.publish(url, new RandService());                         <a id="CO1-5"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">publish</code> method used here (line 2) takes two arguments: a URL that specifies the
service endpoint (line 1) and an instance of the service implementation class, in this
case the <code class="literal">RandService</code> class (line 2).
In the URL, the port number 8888 and the URI <code class="literal">/rs</code> are arbitrary, although a port number greater than
1023 is recommended because modern operating systems typically reserve port numbers below 1024
for particular applications (<span class="emphasis"><em>e.g.</em></span>, port 80 is typically reserved for HTTP requests to a
web server).
The <code class="literal">RandPublisher</code> as coded here runs indefinitely but there are various
way to control an <code class="literal">Endpoint</code> publisher’s life span.</p><p>The web service publisher can be executed in the usual way:</p><pre class="screen">% java rand.RandPublisher</pre><p>The output should be similar to this:</p><pre class="screen">Publishing RandService at endpoint http://localhost:8888/rs

com.sun.xml.internal.ws.model.RuntimeModeler getRequestWrapperClass
INFO: Dynamically creating request wrapper Class rand.jaxws.Next1
com.sun.xml.internal.ws.model.RuntimeModeler getResponseWrapperClass
Dynamically creating response wrapper bean Class rand.jaxws.Next1Response
com.sun.xml.internal.ws.model.RuntimeModeler getRequestWrapperClass
INFO: Dynamically creating request wrapper Class rand.jaxws.NextN
com.sun.xml.internal.ws.model.RuntimeModeler getResponseWrapperClass
INFO: Dynamically creating response wrapper bean Class rand.jaxws.NextNResponse</pre><p>The first line of output is from the <code class="literal">RandPublisher</code> but the others are from the Java
run-time. The dynamically created wrapper classes such as <code class="literal">Next1</code> and
<code class="literal">Next1Response</code> are JAX-B artifacts that represent the
incoming SOAP request (<code class="literal">Next1</code>) and the outgoing SOAP response (<code class="literal">Next1Response</code>).</p><p>Once the service is published, a utility such as <span class="emphasis"><em>curl</em></span> can be used to confirm that the service is indeed up and
running:</p><pre class="screen">% curl http://localhost:8888/rs?xsd=1</pre><p>This <span class="emphasis"><em>curl</em></span> request contains the query string entry <code class="literal">xsd=1</code> that asks for the XML Schema associated with this
service; the schema, like the JAX-B artifacts, is generated dynamically (see Example 3).</p><div class="example"><a id="schema"></a><p class="title"><b>Example 3. The XML Schema generated dynamically for the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:tns="http://rand/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0" targetNamespace="http://rand/"&gt;
  &lt;xs:element name="next1" type="tns:next1"&gt;&lt;/xs:element&gt;
  &lt;xs:element name="next1Response" type="tns:next1Response"&gt;&lt;/xs:element&gt;
  &lt;xs:element name="nextN" type="tns:nextN"&gt;&lt;/xs:element&gt;
  &lt;xs:element name="nextNResponse" type="tns:nextNResponse"&gt;&lt;/xs:element&gt;
  &lt;xs:complexType name="next1"&gt;&lt;xs:sequence&gt;&lt;/xs:sequence&gt;&lt;/xs:complexType&gt;
  &lt;xs:complexType name="next1Response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="return" type="xs:int"&gt;&lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="nextN"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="arg0" type="xs:int"&gt;&lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="nextNResponse"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="return" type="xs:int" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></div></div><br class="example-break" /><p>The schema will be studied carefully later. For now, the point of interest is that
the schema provides a data type for each SOAP message that travels, in either direction,
between the
service and the client. Each message is of an XML Schema <code class="literal">complexType</code> as opposed to an
simple type such as <code class="literal">xsd:date</code>, <code class="literal">xsd:string</code>, or <code class="literal">xsd:integer</code>.</p><p>In the <code class="literal">RandService</code> there are two SOAP messages (for instance, the messages <code class="literal">Next1</code> and
<code class="literal">Next1Response</code>) per web service operation (in this case, the <code class="literal">next1</code> operation) because each operation
implements the familiar <span class="emphasis"><em>request/response</em></span> pattern: a client issues a request, delivered to the
service as a
<code class="literal">Next1</code> SOAP message, and gets a response, in this case a <code class="literal">Next1Response</code> message, in return.
Accordingly, the schema contains four typed SOAP messages because the <code class="literal">RandService</code> has two
operations in the request/response pattern, which means two messages per operation. The number
of <code class="literal">complexType</code> occurrences in the XML Schema may exceed the total number of messages needed
to implement the service’s operations because special error messages, SOAP <span class="emphasis"><em>faults</em></span>, also may
be defined in the XML Schema. SOAP faults are covered in the next chapter.</p><p>The XML Schema types such as <code class="literal">Next1</code> and <code class="literal">Next1Response</code> are the XML counterparts to
the JAX-B artifacts, noted earlier, with the same names. The schema types and the
JAX-B types together allow the SOAP libraries to transform Java objects into XML documents (in particular, SOAP <code class="literal">Envelope</code>
instances)
and SOAP <code class="literal">Envelope</code> instances into Java objects. The <code class="literal">Endpoint</code> publisher’s underlying SOAP libraries
handle the generation of the JAX-B artifacts and the generation of the XML Schema.</p><div class="sidebar" title="Publishing a SOAP-based service with a standalone web server."><p class="title"><b>Publishing a SOAP-based service with a standalone web server.</b></p><p>Publishing a <code class="literal">@WebService</code> with Tomcat or Jetty is almost the same as publishing a <code class="literal">@WebServiceProvider</code> (see
Section 2.5) with
these web servers. Here, for quick review, are the details.</p><p>Two configuration files are needed:
the usual file <span class="emphasis"><em>web.xml</em></span> and the additional file <span class="emphasis"><em>sun-jaxws.xml</em></span>. Here is the <span class="emphasis"><em>web.xml</em></span>, which would work for
any implementation annotated as <code class="literal">@WebService</code> or <code class="literal">@WebServiceProvider</code>:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServletContextListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;jaxws&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      com.sun.xml.ws.transport.http.servlet.WSServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;jaxws&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>The Metro classes <code class="literal">WSServletContextListener</code> and <code class="literal">WSServlet</code> are in the JAR file
currently named <span class="emphasis"><em>webservices-rt.jar</em></span>, which can be downloaded with the rest of Metro
JARs from <span class="emphasis"><em>metro.java.net</em></span>. A second Metro library file <span class="emphasis"><em>webservices-api.jar</em></span> is also
required.
The JAR files in question should be in the <span class="emphasis"><em>src</em></span> directory so that
the Ant script can package them in the deployed WAR file. In any case, the
<code class="literal">WSServletContextListener</code> parses the <span class="emphasis"><em>sun-jaxws.xml</em></span> file, with more details shortly.
The <code class="literal">WSServlet</code> acts the interceptor: the servlet receives incoming requests and
dispatches these to the <code class="literal">RandService</code>.</p><p>The second configuration file, <span class="emphasis"><em>sun-jaxws.xml</em></span>, is:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;endpoints version="2.0"
           xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"&gt;
  &lt;endpoint implementation="rand.RandService" <a id="CO1-6"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            name="RandService"
            url-pattern="/*"/&gt;
&lt;/endpoints&gt;</pre><p>This file completes the routing by notifying the <code class="literal">WSServletContextListener</code> that
the <code class="literal">WSServlet</code> should dispatch requests to a <code class="literal">RandService</code> instance (line 1).</p><p>With the two configuration files and the Metro library JARs in the <span class="emphasis"><em>src</em></span>
directory, the <code class="literal">RandService</code> can be deployed to Tomcat in the usual way:</p><pre class="screen">% ant -Dwar.name=rand deploy</pre><p>Once the <code class="literal">@WebService</code> has been deployed, a <span class="emphasis"><em>curl</em></span> call or a browser can be used to
verify at least that the service is up and running:</p><pre class="screen">% curl http://localhost:8080/myWarFileName?xsd=1</pre><p>If successful, this command returns the XML Schema associated with the service.</p></div><p>Even this first and rather simple example underscores a major appeal of SOAP-based services: underlying
SOAP libraries handle the conversions between native languages types (in this case, Java types) and
XML Schema types. <a class="xref" href="#fig_ch4_soap" title="Figure 1. The architecture of a typical SOAP-based service.">Figure 1, “The architecture of a typical SOAP-based service.”</a> depicts the architecture.</p><div class="figure"><a id="fig_ch4_soap"></a><p class="title"><b>Figure 1. The architecture of a typical SOAP-based service.</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0101.png" alt="images/jwsu_0101.png" /></div></div></div><br class="figure-break" /></div><div class="section" title="1.3. The RandService in Two Files"><div class="titlepage"><div><div><h3 class="title"><a id="_the_literal_randservice_literal_in_two_files"></a>1.3. The <code class="literal">RandService</code> in Two Files</h3></div></div></div><p>The <code class="literal">RandService</code> in the first example (see <a class="xref" href="#Ex1" title="Example 1. A SOAP-based service with two operations.">Example 1, “A SOAP-based service with two operations.”</a>) combines, in a single source file,
what JAX-WS calls the SEI (Service Endpoint Interface) and
the SIB (Service Implementation Bean). The SEI specifies, at a high level that befits an interface,
the service operations; and the SIB provides an implementation of the operations. A SIB can be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A POJO class such as <code class="literal">RandService</code> annotated as <code class="literal">@WebService</code> and encapsulating service
operations, each annotated as a <code class="literal">@WebMethod</code>.
</li><li class="listitem">
A <code class="literal">@Stateless</code> Session EJB that is likewise annotated as a <code class="literal">@WebService</code>. EJBs in general
predate JAX-WS; hence, this second type of SIB is an inviting way to expose legacy EJBs
as web services.
</li></ul></div><p>Chapter 7 covers the EJB-implementation of a <code class="literal">@WebService</code>.
For now, the SIBs will be POJO classes. For convenience, most of my examples take the
single-file approach, which combines the SEI and the SIB into one class annotated as
a <code class="literal">@WebService</code>. The two-file approach is illustrated with the SEI <code class="literal">RandService</code> (see <a class="xref" href="#Ex4" title="Example 4. The Service Endpoint Interface for the revised RandService.">Example 4, “The Service Endpoint Interface for the revised <code class="literal">RandService</code>.”</a>)
in one file and the SIB <code class="literal">RandImpl</code> (see <a class="xref" href="#Ex5" title="Example 5. The Service Implementation Bean for the revised RandService.">Example 5, “The Service Implementation Bean for the revised <code class="literal">RandService</code>.”</a>) in another file. The <code class="literal">RandService</code> is now an
<code class="literal">interface</code>, whereas the <code class="literal">RandImpl</code> is a <code class="literal">class</code> that <code class="literal">implements</code> this interface.</p><div class="example"><a id="Ex4"></a><p class="title"><b>Example 4. The Service Endpoint Interface for the revised <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">package rand2;

import javax.jws.WebService;
import javax.jws.WebMethod;
import java.util.Random;

@WebService
public interface RandService {
    @WebMethod
    public int next1();
    @WebMethod
    public int[ ] nextN(final int n);
}</pre></div></div><br class="example-break" /><div class="example"><a id="Ex5"></a><p class="title"><b>Example 5. The Service Implementation Bean for the revised <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">package rand2;

import javax.jws.WebService;
import javax.jws.WebMethod;
import java.util.Random;

@WebService(endpointInterface = "rand2.RandService")
public class RandImpl implements RandService {
    private static final int maxRands = 16;

    @WebMethod
    public int next1() { return new Random().nextInt(); }
    @WebMethod
    public int[ ] nextN(final int n) {
        final int k = (n &gt; maxRands) ? maxRands : Math.abs(n);
        int[ ] rands = new int[k];
        Random r = new Random();
        for (int i = 0; i &lt; k; i++) rands[i] = r.nextInt();
        return rands;
    }
}</pre></div></div><br class="example-break" /><p>In the SIB class <code class="literal">RandImpl</code>, the <code class="literal">@WebService</code> interface has an attribute, the key/value pair</p><pre class="screen">endpointInterface = "rand2.RandService"</pre><p>that names the SEI. It is still important for the
class <code class="literal">RandImpl</code> to employ the standard <code class="literal">implements</code> clause because only the <code class="literal">implements</code>
clause prompts the compiler to make sure that the public methods declared in the SEI, in this
case the two methods annotated with <code class="literal">@WebMethod</code>, are defined appropriately in the SIB.</p><p>The revised <code class="literal">RandService</code> has the same functionality as the original. The <code class="literal">Endpoint</code> publisher
changes slightly:</p><pre class="screen">Endpoint.publish(url, new RandImpl()); // SIB, not SEI</pre><p>The second argument to the <code class="literal">publish</code> changes to <code class="literal">RandImpl</code> precisely because, in the revision,
<code class="literal">RandService</code> is an interface. In general, the second argument to the <code class="literal">static</code> version of
<code class="literal">publish</code> is always the SIB. In a single-file case such as the original version of <code class="literal">RandService</code>, a
single class is the combined SEI and SIB.</p></div><div class="section" title="1.4. Clients against the RandService"><div class="titlepage"><div><div><h3 class="title"><a id="_clients_against_the_literal_randservice_literal"></a>1.4. Clients against the <code class="literal">RandService</code></h3></div></div></div><p>The claim that SOAP-based services are language neutral needs to be taken on faith a bit longer. The first
client against the <code class="literal">RandService</code> is in Java but the two thereafter are in C# and Perl. Starting with a Java client will help
to clarify how the critical <span class="emphasis"><em>service contract</em></span>, the WSDL (Web Service Definition Language) document, can be
put to good use in writing a client. The WSDL will be studied in detail but putting the WSDL to work first
should help to motivate the detailed study.</p><div class="section" title="1.4.1. A Java Client against the RandService"><div class="titlepage"><div><div><h4 class="title"><a id="_a_java_client_against_the_literal_randservice_literal"></a>1.4.1. A Java Client against the <code class="literal">RandService</code></h4></div></div></div><p>Recall the XML Schema (see Example 3) that the <code class="literal">Endpoint</code> publisher generates dynamically when the
<code class="literal">RandService</code> is published. The publisher likewise
generates a WSDL, which can be requested as follows:</p><pre class="screen">% curl http://localhost:8888/rs?wsdl</pre><p>JDK 1.6 and greater ships with a utility, <span class="emphasis"><em>wsimport</em></span>, that uses a WSDL to generate Java classes in
support of programming a client against the service described in the WSDL. Here is how the utility can
be used in the current example:</p><pre class="screen">% wsimport -p client -keep http://localhost:8888/rs?wsdl</pre><p>The <code class="literal">-p</code> flag stands for <span class="emphasis"><em>package</em></span>: the utility creates a directory named <span class="emphasis"><em>client</em></span> and puts the
generated Java code in this directory/package. The <code class="literal">-keep</code> flag generates source (<span class="emphasis"><em>.java</em></span>) as well as
compiled (<span class="emphasis"><em>.class</em></span>) files; without this flag, only compiled files would be in the <span class="emphasis"><em>client</em></span> directory.
Sixteen files are generated in total, half source and half compiled. Among these files are with
names such as <code class="literal">Next1</code> and <code class="literal">Next1Response</code>, the very names of the classes generated at the
publication of the <code class="literal">RandService</code>. In any case, these client-side artifacts correspond to SOAP
types described in the XML Schema document for the <code class="literal">RandService</code>.</p><p>How are the <span class="emphasis"><em>wsimport</em></span>-generated files to be used? Two of these are of special interest:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The class <code class="literal">RandServiceService</code> begins with the name of the published SOAP service, <code class="literal">RandService</code>, and
has another <code class="literal">Service</code> stuck on the end. The <code class="literal">@WebService</code> annotation could be used to specify
a less awkward name but, for now, the key point is that this class represents, to the client,
the deployed web service.
</li><li class="listitem">
The interface <code class="literal">RandService</code> has the same name as the published service but there is a critical difference:
this <code class="literal">RandService</code> is an <span class="emphasis"><em>interface</em></span>, whereas the published <code class="literal">RandService</code> is a <span class="emphasis"><em>class</em></span>. This
interface, like any Java interface, declares methods—hence, the interface declares the
operations encapsulated in published service and thereby specifies the invocation syntax for
each operation. In this example, there are two such operations: <code class="literal">next1</code> and <code class="literal">nextN</code>.
</li></ul></div><p>The <code class="literal">RandServiceService</code> and <code class="literal">RandService</code> types are used in an idiomatic way to write the Java client
against the service. The <code class="literal">RandClient</code> (see <a class="xref" href="#Ex6" title="Example 6. A Java client built with wsimport-generated artifacts.">Example 6, “A Java client built with <span class="emphasis"><em>wsimport</em></span>-generated artifacts.”</a>) is a sample client that illustrates.</p><div class="example"><a id="Ex6"></a><p class="title"><b>Example 6. A Java client built with <span class="emphasis"><em>wsimport</em></span>-generated artifacts.</b></p><div class="example-contents"><pre class="screen">import client.RandServiceService;
import client.RandService;
import java.util.List;

public class RandClient {
    public static void main(String[ ] args) {
        // set-up
        RandServiceService service = new RandServiceService(); <a id="CO1-7"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        RandService port = service.getRandServicePort();       <a id="CO1-8"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        // sample calls
        System.out.println(port.next1());                      <a id="CO1-9"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        System.out.println();
        List&lt;Integer&gt; nums = port.nextN(4);                    <a id="CO1-10"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        for (Integer num : nums) System.out.println(num);      <a id="CO1-11"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">RandClient</code> imports two types from the <span class="emphasis"><em>wsimport</em></span>-generated artifacts: the class <code class="literal">RandServiceService</code>
and the interface <code class="literal">RandService</code>. In the set-up phase of the client code, the class’s no-argument constructor
is invoked to create an object that represents, on the client side, the service itself (line 1).
Once this object is constructed, there is a <span class="emphasis"><em>get</em></span> call with a distinct pattern:</p><pre class="screen">service.get&lt;name of interface type&gt;Port() // line 2 pattern</pre><p>In this case, the interface is named <code class="literal">RandService</code> and so the call is</p><pre class="screen">service.getRandServicePort() // line 2</pre><p>This <span class="emphasis"><em>get</em></span> method returns a reference to an object that encapsulates the two operations in the <code class="literal">RandService</code>,
<code class="literal">next1</code> and <code class="literal">nextN</code>. The reference is named <code class="literal">port</code>, although any name would do, for reasons
that will become clear once the WSDL is studied in detail. The <code class="literal">port</code> reference then is used to
make two sample calls against the service. On a sample run, the output was:</p><pre class="screen">53378846         // from line 3
-818435924       // from lines 4 and 5
104886422
1714126390
-2140389441</pre><p>The first integer is returned from the call to <code class="literal">next1</code> and and the next four integers from the
call to <code class="literal">nextN</code>.</p><p>The <code class="literal">RandClient</code> does reveal an oddity about the <span class="emphasis"><em>wsimport</em></span>-generated artifacts. In the
<code class="literal">RandService</code>, the method <code class="literal">nextN</code> begins:</p><pre class="screen">public int[ ] nextN(...</pre><p>The return type is <code class="literal">int[ ]</code>, an array of <code class="literal">int</code> values. In the <span class="emphasis"><em>wsimport</em></span>-generated
interface <code class="literal">RandService</code>, the method <code class="literal">nextN</code> begins:</p><pre class="screen">public List&lt;Integer&gt; nextN(...</pre><p>The <span class="emphasis"><em>wsimport</em></span> utility is within its rights to replace <code class="literal">int[ ]</code> with <code class="literal">List&lt;Integer&gt;</code>, as a
<code class="literal">List</code> has a <code class="literal">toArray</code> method that returns an array; and, with automatic boxing/unboxing,
the Java types <code class="literal">Integer</code> and <code class="literal">int</code> are interchangeable in the current context. The point is
that the programmer typically needs to inspect at least the <span class="emphasis"><em>wsimport</em></span>-generated interface,
in this example <code class="literal">RandService</code>, in order to determine the argument and return types of every
operation.</p><p>A final, obvious point about the interaction between the Java client and the Java service
deserves mention: the SOAP is completely transparent. The underlying SOAP libraries generate
the SOAP on the sending side and parse the SOAP on the receiving side so that the Java code
on both sides can remain agnostic about what type of payload is being sent and received.
SOAP transparency is a major selling point for SOAP-based services.</p><div class="sidebar" title="Companion utilities: wsimport and wsgen"><p class="title"><b>Companion utilities: <span class="emphasis"><em>wsimport</em></span> and <span class="emphasis"><em>wsgen</em></span></b></p><p>The <span class="emphasis"><em>wsimport</em></span> utility eases the task of writing a Java client against a service that
has a WSDL as the service contract. This utility has a client-side focus, although the
utility can be helpful on the server side as well; a later example illustrates. The
<span class="emphasis"><em>wsgen</em></span> utility, which also ships with core Java 1.6 or greater, has a server-side
focus. For example, <span class="emphasis"><em>wsgen</em></span> can be used to
generate a WSDL. The command</p><pre class="screen">% wsgen -cp . -wsdl rand.RandService</pre><p>generates a WSDL file named <span class="emphasis"><em>RandServiceService.wsdl</em></span>. However, this WSDL has a
placeholder for the service endpoint rather than a usable URL:</p><pre class="screen">...
&lt;soap:address location="REPLACE_WITH_ACTUAL_URL"/&gt;
...</pre><p>When a service publisher such as <code class="literal">Endpoint</code>, Tomcat, Jetty, and the like generate the
WSDL, the WSDL includes a usable URL.</p><p>The <span class="emphasis"><em>wsgen</em></span> utility has another use. When the <code class="literal">RandService</code> is published with
<code class="literal">Endpoint</code>, the publisher outputs information about dynamically generated classes, in this
case <code class="literal">Next1</code>, <code class="literal">Next1Response</code>, <code class="literal">NetxN</code>, and <code class="literal">NextNResponse</code>. As noted earlier, these are
JAX-B artifacts that the Java run-time uses to convert Java types into XML types and
vice-versa. The <span class="emphasis"><em>wsgen</em></span> utility can be used to generate the JAX-B artifacts as files
on the local system. For example, the command</p><pre class="screen">% wsgen -cp . rand.RandService</pre><p>automatically creates a package/directory <span class="emphasis"><em>rand/jaxws</em></span> and then populates this directory
with <span class="emphasis"><em>Next1.class</em></span>, <span class="emphasis"><em>Next1Response.class</em></span>, <span class="emphasis"><em>NextN.class</em></span>, and <span class="emphasis"><em>NextNResonse.class</em></span>. Now if the
<code class="literal">Endpoint</code> publisher is started after these files have been created, the publisher
does not generate the JAX-B artifacts dynamically but instead uses the ones that
<span class="emphasis"><em>wsgen</em></span> already has created.</p></div></div><div class="section" title="1.4.2. A C# Client against the RandService"><div class="titlepage"><div><div><h4 class="title"><a id="_a_c_client_against_the_literal_randservice_literal"></a>1.4.2. A C# Client against the <code class="literal">RandService</code></h4></div></div></div><p>The next client is in C#, a DotNet language similar to Java; and DotNet has a <span class="emphasis"><em>wsdl</em></span> utility
similar to Java’s <span class="emphasis"><em>wsimport</em></span> utility. The <span class="emphasis"><em>wsdl</em></span> utility can be targeted at the dynamically
generated WSDL for the <code class="literal">RandService</code>:</p><pre class="screen">% wsdl http://localhost:8888/rs?wsdl</pre><p>This command generates a single file with the awkward name <span class="emphasis"><em>RandServiceService.cs</em></span> (see <a class="xref" href="#Ex7a" title="Example 7. A C# client, built with wsdl-generated code, against the RandService.">Example 7, “A C# client, built with <span class="emphasis"><em>wsdl</em></span>-generated code, against the <code class="literal">RandService</code>.”</a>).</p><div class="example"><a id="Ex7a"></a><p class="title"><b>Example 7. A C# client, built with <span class="emphasis"><em>wsdl</em></span>-generated code, against the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// This source code was auto-generated by wsdl, Version=4.0.30319.1.
...
public partial class RandServiceService :
        System.Web.Services.Protocols.SoapHttpClientProtocol {
    private System.Threading.SendOrPostCallback next1OperationCompleted;
    private System.Threading.SendOrPostCallback nextNOperationCompleted;

    public RandServiceService() { this.Url = "http://localhost:8888/rs"; }
    ...
    public int next1() {
        object[] results = this.Invoke("next1", new object[0]);
        return ((int)(results[0]));
    }
    ...
    public System.Nullable&lt;int&gt;[] nextN([System.Xml.Serialization.XmlElementAttribute(
                Form=System.Xml.Schema.XmlSchemaForm.Unqualified)] int arg0) {
        object[] results = this.Invoke("nextN", new object[] {arg0});
        return ((System.Nullable&lt;int&gt;[])(results[0]));
    }
    ...
}
...</pre></div></div><br class="example-break" /><p>The code excised from the C# <code class="literal">RandServiceService</code> class supports asynchronous calls against the Java <code class="literal">RandService</code>.
Java, too,
supports both synchronous (blocking) and asynchronous (non-blocking) calls against a web service’s
operations, as a sample client against the <code class="literal">RandService</code> later illustrates. For now, only
synchronous calls are of interest.
Here is a sample C# client that uses the <span class="emphasis"><em>wsdl</em></span>-generated code to make calls against the <code class="literal">RandService</code>:</p><pre class="screen">class RandClient {
  static void Main() {
     RandServiceService service = new RandServiceService();      <a id="CO1-12"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
     Console.WriteLine("Call to next1():\n" + service.next1());  <a id="CO1-13"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
     Console.WriteLine("\nCall to nextN(4):");
     int?[] nums = service.nextN(4);                             <a id="CO1-14"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
     foreach (int num in nums) Console.WriteLine(num);
  }
}</pre><p>The C# client code is simpler than its Java counterpart because the <code class="literal">new</code> operation with the no-argument
constructor <code class="literal">RandServiceService()</code> (line 1) creates an object that encapsulates the client-side operations
<code class="literal">next1</code> and <code class="literal">nextN</code>. The C# code does not require the <code class="literal">getRandServicePort()</code> call from the Java client.
The call to <code class="literal">next1</code> (line 2) is basically the same in the C# and Java clients but the C# call to
<code class="literal">nextN</code> has unusual syntax. The return type <code class="literal">int?[]</code> (line 3) signifies an integer array that may
have <code class="literal">null</code> as its value; the type <code class="literal">int[]</code> signifies an integer array that cannot be <code class="literal">null</code>.
On a sample run, the C# client output:</p><pre class="screen">Call to next1():
680641940
Call to nextN(4):
1783826925
260390049
-48376976
-914903224</pre><p>The C# example does illustrate language-interoperability for SOAP-based services, although C# and Java
are at least cousins among programming languages. The next sample client is written in a language quite
different from Java.</p></div><div class="section" title="1.4.3. A Perl Client against the RandService"><div class="titlepage"><div><div><h4 class="title"><a id="_a_perl_client_against_the_literal_randservice_literal"></a>1.4.3. A Perl Client against the <code class="literal">RandService</code></h4></div></div></div><p>The final client (see <a class="xref" href="#Ex7" title="Example 8. A Perl client against the RandService.">Example 8, “A Perl client against the <code class="literal">RandService</code>.”</a>) against the Java <code class="literal">RandService</code> is in Perl. This client makes it easy
to display the SOAP messages that go back and forth between client and service; the Perl
library <code class="literal">SOAP::Lite</code> has an excellent, easy-to-use tracer.</p><div class="example"><a id="Ex7"></a><p class="title"><b>Example 8. A Perl client against the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">#!/usr/bin/perl -w

use SOAP::Lite +trace =&gt; 'debug';
use strict;

my $soap =                                                               <a id="CO1-15"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    SOAP::Lite-&gt;uri('http://rand/')-&gt;proxy('http://localhost:8888/rs/');
my $num = $soap-&gt;next1()-&gt;result();                                      <a id="CO1-16"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
print "Response is: $num\n";                                             <a id="CO1-17"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" /></pre></div></div><br class="example-break" /><p>In line 1, the Perl client constructs a <code class="literal">SOAP::Lite</code> object (the reference is
<code class="literal">$soap</code>) that communicates with the <code class="literal">RandService</code>. The <code class="literal">uri</code> value of
<code class="literal">http://rand/</code> is the namespace that identifies a particular service available
at the <code class="literal">proxy</code> (that is, the URL) value of <code class="literal">http://localhost:8888/rs</code>. A given
service endpoint, a URL, could host any number of services, with a URI
identifying each. In line 2, the call to <code class="literal">next1</code> returns a SOAP message:</p><pre class="screen">&lt;?xml version="1.0" ?&gt;
&lt;S:Envelope
    xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;S:Body&gt;
    &lt;ns2:next1Response xmlns:ns2="http://rand/"&gt;
      &lt;return&gt;1774649411&lt;/return&gt;
    &lt;/ns2:next1Response&gt;
  &lt;/S:Body&gt;
&lt;/S:Envelope&gt;</pre><p>The cascaded call to <code class="literal">result</code> (also line 2) extracts the value <code class="literal">1774649411</code> from
the SOAP envelope; and the value is assigned to the variable <code class="literal">$num</code>. The client program
prints the value and exits. This Perl-to-Java request again confirms the language
transparency of a SOAP-based
service.</p><div class="example"><a id="Ex8"></a><p class="title"><b>Example 9. The HTTP request from the Perl client to the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">POST http://localhost:8888/rs HTTP/1.1
Accept: text/xml
Accept: multipart/*
Accept: application/soap
Content-Length: 420
Content-Type: text/xml; charset=utf-8
SOAPAction: ""

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
               xmlns:tns="http://rand/"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema"
               soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
   &lt;soap:Body&gt;
      &lt;tns:next1 xsi:nil="true" /&gt; <a id="CO1-18"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;</pre></div></div><br class="example-break" /><div class="example"><a id="Ex9"></a><p class="title"><b>Example 10. The HTTP response from the <code class="literal">RandService</code> to the Perl client.</b></p><div class="example-contents"><pre class="screen">HTTP/1.1 200 OK
Content-Type: text/xml;charset="utf-8"
Client-Peer: 127.0.0.1:8888
Client-Response-Num: 1
Client-Transfer-Encoding: chunked

&lt;?xml version="1.0" ?&gt;
&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt;
   &lt;S:Body&gt;
      &lt;ns2:next1Response xmlns:ns2="http://rand/"&gt;
         &lt;return&gt;1774649411&lt;/return&gt;                     <a id="CO1-19"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
      &lt;/ns2:next1Response&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;</pre></div></div><br class="example-break" /><p>The Perl client is especially useful because of its trace capabilities. <a class="xref" href="#Ex8" title="Example 9. The HTTP request from the Perl client to the RandService.">Example 9, “The HTTP request from the Perl client to the <code class="literal">RandService</code>.”</a> is the HTTP
request that the Perl client generates on a sample run; and <a class="xref" href="#Ex9" title="Example 10. The HTTP response from the RandService to the Perl client.">Example 10, “The HTTP response from the <code class="literal">RandService</code> to the Perl client.”</a> is the HTTP response
from the Java service. In the request, the body of the POST request contains a
SOAP <span class="emphasis"><em>envelope</em></span>, so named because of the local name <code class="literal">Envelope</code> in the XML tag’s qualified
name <code class="literal">soap:Envelope</code>. Also in the request, the</p><pre class="screen">&lt;tns:next1 xsi:nil="true"/&gt;</pre><p>in line 1 means that the <code class="literal">next1</code> operation takes no arguments. The HTTP response
is more complicated than the request because there is a return value (line 1):</p><pre class="screen">&lt;return&gt;1774649411&lt;/return&gt;</pre><p>The WSDL document specifies that the response from the <code class="literal">RandService</code> occurs in an
element tagged <code class="literal">return</code>.</p><div class="sidebar" title="Why does the Perl client not invoke nextN as well as next1?"><p class="title"><b>Why does the Perl client not invoke <code class="literal">nextN</code> as well as <code class="literal">next1</code>?</b></p><p>The Perl client invokes the <code class="literal">next1</code> operation but not the parametrized <code class="literal">nextN</code> operation in the
<code class="literal">RandService</code>. Were the
Perl client to invoke <code class="literal">nextN</code>, the response from the <code class="literal">RandService</code> would be an empty list. When the
published <code class="literal">RandService</code> receives a request, the Java run-time uses a SAX (Simple API for XML)
parser to parse the incoming request; and this parser belches on the SOAP request that the Perl
library generates. In particular, the SAX parser fails to extract the <code class="literal">nextN</code> argument, which specifies how
many randomly generated integers are to be returned.
A glitch such as this is not uncommon in web services, including SOAP-based ones. Web services,
REST-style and SOAP-based alike, are remarkably but not perfectly interoperable among programming
languages.</p></div><p>The examples so far illustrate that the WSDL document can be used even if its detailed structure
remains unknown. Now is the time to take a close look at how the WSDL
is structured.</p></div></div><div class="section" title="1.5. The WSDL Service Contract in Detail"><div class="titlepage"><div><div><h3 class="title"><a id="_the_wsdl_service_contract_in_detail"></a>1.5. The WSDL Service Contract in Detail</h3></div></div></div><p>The WSDL document, which is XML, is structured as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The document or root element is named <code class="literal">definitions</code>. This is appropriate because the WSDL
defines the web service thoroughly enough that utilities such as <span class="emphasis"><em>wsimport</em></span> can use the WSDL
to generate code, typically but not exclusively client-side support code.
</li><li class="listitem">
The first child element of <code class="literal">definitions</code>, named <code class="literal">types</code>, is technically optional but almost always present in a modern WSDL.
This element contains (or links to) an XML Schema or the equivalent, that is, a grammar that
specifies the data types for the messages involved in the service. In a modern SOAP-based web service, the
arguments passed to web service operations are typed—but the SOAP messages themselves are also typed. For this
reason, the receiver of a SOAP message can check, typically at the library level,
whether the received message satisfies the constraints that the message’s type impose.
</li><li class="listitem">
Next come one or more <code class="literal">message</code> elements, which list the messages whose data types are given in the
<code class="literal">types</code> section immediately above. Every <code class="literal">message</code> has a corresponding <code class="literal">complexType</code> entry in the
schema from the <code class="literal">types</code> section, assuming that the <code class="literal">types</code> section is non-empty.
</li><li class="listitem">
The <code class="literal">portType</code> section comes next. There is always exactly one <code class="literal">portType</code> element. The <code class="literal">portType</code> is
essentially the service <span class="emphasis"><em>interface</em></span>: a specification of the service’s operations and the
message patterns that the operations exemplify. For example, in the request/response pattern, the
client begins the conversation with a request message and the service counters with a response message.
In the solicit/response pattern, by contrast, the service starts the conversation with a solicitation
message and the client counters with a response. There is also the one-way pattern (client to server only)
and the notification pattern (server to client only). Richer conversational patterns can be built out of
these simpler ones. The <code class="literal">message</code> items in the preceding section are the components of an operation; and
the <code class="literal">portType</code> section defines an <code class="literal">operation</code> by placing <code class="literal">message</code> items in a specific order.
</li><li class="listitem">
Next come one or more <code class="literal">binding</code> sections, which provide implementation detail such as the transport
used in the service (for instance, HTTP rather than SMTP), the service <span class="emphasis"><em>style</em></span>, and the SOAP version (that
is, 1.1 or 1.2). By default, Java generates a single <code class="literal">binding</code> section but DotNet generates two: one for
SOAP 1.1 and another for SOAP 1.2.
</li><li class="listitem"><p class="simpara">
The last section, named <code class="literal">service</code>, brings all of the previous details together to define key attributes
such as the <span class="emphasis"><em>service endpoint</em></span>, that is, the URL at which the service can be accessed. Nested in the
<code class="literal">service</code> element are one or more <code class="literal">port</code> sub-elements, where a <code class="literal">port</code> is a <code class="literal">portType</code> plus a <code class="literal">binding</code>:
</p><pre class="screen">port = portType + binding</pre><p class="simpara">Since there is only one <code class="literal">portType</code> in a WSDL, the number of <code class="literal">port</code> sub-elements
equals the number of <code class="literal">binding</code> elements.</p></li></ul></div><p>The biggest section in a WSDL is typically the <code class="literal">types</code> section because an XML Schema tends to be wordy.
An example from Amazon, introduced shortly, illustrates. For now, the WSDL (see <a class="xref" href="#Ex10" title="Example 11. The dynamically generated WSDL for the RandService.">Example 11, “The dynamically generated WSDL for the <code class="literal">RandService</code>.”</a>) for the <code class="literal">RandService</code>
is only about a page or so in size.</p><div class="example"><a id="Ex10"></a><p class="title"><b>Example 11. The dynamically generated WSDL for the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns:tns="http://rand/"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             targetNamespace="http://rand/" name="RandServiceService"&gt;
  &lt;types&gt;
    &lt;xsd:schema&gt;
      &lt;xsd:import namespace="http://rand/"
                  schemaLocation="http://localhost:8888/rs?xsd=1"&gt;&lt;/xsd:import&gt;
    &lt;/xsd:schema&gt;
  &lt;/types&gt;
  &lt;message name="next1"&gt;
    &lt;part name="parameters" element="tns:next1"&gt;&lt;/part&gt;
  &lt;/message&gt;
  &lt;message name="next1Response"&gt;
    &lt;part name="parameters" element="tns:next1Response"&gt;&lt;/part&gt;
  &lt;/message&gt;
  &lt;message name="nextN"&gt;
    &lt;part name="parameters" element="tns:nextN"&gt;&lt;/part&gt;
  &lt;/message&gt;
  &lt;message name="nextNResponse"&gt;
    &lt;part name="parameters" element="tns:nextNResponse"&gt;&lt;/part&gt;
  &lt;/message&gt;
  &lt;portType name="RandService"&gt;
    &lt;operation name="next1"&gt;
      &lt;input message="tns:next1"&gt;&lt;/input&gt;
      &lt;output message="tns:next1Response"&gt;&lt;/output&gt;
    &lt;/operation&gt;
    &lt;operation name="nextN"&gt;
      &lt;input message="tns:nextN"&gt;&lt;/input&gt;
      &lt;output message="tns:nextNResponse"&gt;&lt;/output&gt;
    &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name="RandServicePortBinding" type="tns:RandService"&gt;
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http"
                  style="document"&gt;&lt;/soap:binding&gt;
    &lt;operation name="next1"&gt;
      &lt;soap:operation soapAction=""&gt;&lt;/soap:operation&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"&gt;&lt;/soap:body&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"&gt;&lt;/soap:body&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
    &lt;operation name="nextN"&gt;
      &lt;soap:operation soapAction=""&gt;&lt;/soap:operation&gt;
      &lt;input&gt;
        &lt;soap:body use="literal"&gt;&lt;/soap:body&gt;
      &lt;/input&gt;
      &lt;output&gt;
        &lt;soap:body use="literal"&gt;&lt;/soap:body&gt;
      &lt;/output&gt;
    &lt;/operation&gt;
  &lt;/binding&gt;
  &lt;service name="RandServiceService"&gt;
    &lt;port name="RandServicePort" binding="tns:RandServicePortBinding"&gt;
      &lt;soap:address location="http://localhost:8888/rs"&gt;&lt;/soap:address&gt;
    &lt;/port&gt;
  &lt;/service&gt;
&lt;/definitions&gt;</pre></div></div><br class="example-break" /><p>The first three WSDL sections (<code class="literal">types</code>, <code class="literal">message</code>, and <code class="literal">portType</code>) present the service
abstractly in that no implementation details are present. The <code class="literal">binding</code> and
<code class="literal">service</code> sections provide the concrete detail by specifying, for example, the type
of transport used in the service as well as the service endpoint.</p><p>The <code class="literal">portType</code> is of particular interest because it characterizes the service in terms
of <span class="emphasis"><em>operations</em></span>, not simply messages:
operations consist of one or more messages exchanged in a specified pattern. The two areas of
immediate interest in the WSDL for a programmer writing a client against a service would be
the <code class="literal">portType</code> and the <code class="literal">service</code>: the <code class="literal">portType</code> section informs the programmer about what calls can be
made against the service; and the <code class="literal">service</code> section gives the service endpoint, the URL through
which the service can be reached.</p><p>XML is not fun to read but the <span class="emphasis"><em>basic profile</em></span> WSDL for the <code class="literal">RandService</code> is
not unduly forbidding. Perhaps the best way to read the document is from
top to bottom.</p><div class="section" title="1.5.1. The types Section"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_types_literal_section"></a>1.5.1. The <code class="literal">types</code> Section</h4></div></div></div><p>This section contains or links to an XML Schema or
equivalent. (In the case of Java, the schema is a separate document shown in
Example 3; in the case of DotNet, the schema is included in the WSDL.) To understand
how the schema relates to its WSDL, consider this segment of the XMl Schema from Example 3:</p><pre class="screen">&lt;xs:element name="nextNResponse" type="tns:nextNResponse"&gt;             <a id="CO1-20"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
&lt;/xs:element&gt;
...
&lt;xs:complexType name="nextNResponse"&gt;                                  <a id="CO1-21"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
  &lt;xs:sequence&gt;
    &lt;xs:element name="return"                                          <a id="CO1-22"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                type="xs:int" minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;/xs:element&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</pre><p>The <code class="literal">xs:element</code> in line 1 has a specified <code class="literal">type</code>, in this case <code class="literal">tns:nextNResponse</code>.
The type is the <code class="literal">complexType</code> in line 2. XML Schema has built-in simple types such as
<code class="literal">xsd:int</code> and <code class="literal">xsd:string</code>; but XML Schema is also <span class="emphasis"><em>extensible</em></span> in that new
complex types can be added as needed. The <code class="literal">complexType</code> in this case is for a
message, the <code class="literal">nextNResponse</code> message that the service returns to the client. Here
is that message from the WSDL in <a class="xref" href="#Ex10" title="Example 11. The dynamically generated WSDL for the RandService.">Example 11, “The dynamically generated WSDL for the <code class="literal">RandService</code>.”</a>:</p><pre class="screen">&lt;message name="nextNResponse"&gt;
  &lt;part name="parameters" element="tns:nextNResponse"&gt;&lt;/part&gt;  <a id="CO1-23"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
&lt;/message&gt;</pre><p>The <code class="literal">message</code> has an <code class="literal">element</code> attribute (line 1) with <code class="literal">tns:nextNResponse</code> as the value;
and <code class="literal">tns:nextNResponse</code> is the name of the <code class="literal">element</code>
in line 1 of the XML Schema. The WSDL, in defining a message, points back to the
XML Schema section that provides the data type for the message.</p><p>The <code class="literal">complexType</code> section of the WSDL indicates
that a <code class="literal">nextNResponse</code> message returns zero or more integers (XML type <code class="literal">xs:int</code>).
The zero leaves open the possibility that the service, in this case written in Java,
might return <code class="literal">null</code> instead of an actual array or equivalent (<span class="emphasis"><em>e.g.</em></span>,
<code class="literal">List&lt;Integer&gt;</code>). At this point a human editor might intervene by changing
the <code class="literal">minOccurs</code> in line 3 from <code class="literal">0</code> to <code class="literal">1</code>. (If the <code class="literal">minOccurs</code> attribute were
dropped altogether, the value would default to 1.) The dynamically generated
WSDL may not capture the intended design of a service; hence, the WSDL may need to
be edited by hand.</p></div><div class="section" title="1.5.2. The message Section"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_message_literal_section"></a>1.5.2. The <code class="literal">message</code> Section</h4></div></div></div><p>Each <code class="literal">message</code> element in the WSDL points to an
element and, more important, to a <code class="literal">complexType</code> in the WSDL’s XML Schema. The result
is that all of the messages are typed. The <code class="literal">RandService</code> exposes two operations
and each follows the request/response pattern; hence, the WSDL has four
<code class="literal">message</code> elements: two for the <code class="literal">next1</code> and <code class="literal">nextN</code> requests and two for the
corresponding responses named <code class="literal">next1Response</code> and <code class="literal">nextNResponse</code>,
respectively.</p></div><div class="section" title="1.5.3. The portType Section"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_porttype_literal_section"></a>1.5.3. The <code class="literal">portType</code> Section</h4></div></div></div><p>This section contains one or more <code class="literal">operation</code>
elements, each of which defines an operation in terms of messages defined in
the immediately preceding section. For example, here is the definition
for the <code class="literal">nextN</code> operation:</p><pre class="screen">&lt;operation name="nextN"&gt;
  &lt;input message="tns:nextN"&gt;&lt;/input&gt;
  &lt;output message="tns:nextNResponse"&gt;&lt;/output&gt;
&lt;/operation&gt;</pre><p>The <code class="literal">input</code> message precedes the <code class="literal">output</code> message, which signals that the pattern
is request/response. Were the order reversed, the pattern would be
solicit/response. The term <span class="emphasis"><em>input</em></span> is to be understood from the service’s
perspective: an <code class="literal">input</code> message goes into the service and an <code class="literal">output</code> message
comes out from the service. Each <code class="literal">input</code> and <code class="literal">output</code> element names the
message defined in a <code class="literal">message</code> section, which in turn refers to an XML Schema
<code class="literal">complexType</code>. Accordingly, each <code class="literal">operation</code> can be linked to the typed messages
that make up the <code class="literal">operation</code>.</p></div><div class="section" title="1.5.4. The binding Section"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_binding_literal_section"></a>1.5.4. The <code class="literal">binding</code> Section</h4></div></div></div><p>This section and the next, <code class="literal">service</code>, provide
implementation details about the service. In theory, but rarely in practice, there are
several options or <span class="emphasis"><em>degrees of freedom</em></span> with respect to the service that the WSDL
defines; and a <code class="literal">binding</code> section selects among these options. One option is for a
SOAP-based service such as
the <code class="literal">RandService</code> is the SOAP version: 1.1 or 1.2. SOAP 1.1 is the default in Java; hence,
the one and only <code class="literal">binding</code> section is for SOAP 1.1. In DotNet, a dynamically generated
WSDL usually has two <code class="literal">binding</code> sections: one for SOAP 1.1 and the other for SOAP 1.2. However,
the very same DotNet WSDL typically has only one service endpoint, that is, URL; and this means
the same deployed service is for SOAP 1.1 and SOAP 1.2, thereby signaling that no
difference between the two SOAP versions comes into play for the service.</p><p>There are three other options to be considered: transport (line 1) and style (line 2) are
two of the three. Here is the first sub-element in the <code class="literal">binding</code> section, a
sub-element that makes choices on these two options:</p><pre class="screen">&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http"  <a id="CO1-24"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
              style="document"&gt;&lt;/soap:binding&gt;                  <a id="CO1-25"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" /></pre><p>The <code class="literal">transport</code> value is a URI that ends with <code class="literal">soap/http</code>, which can be summed up as
<span class="emphasis"><em>SOAP over HTTP</em></span>. Another option would be SMTP (Simple Mail Transport Protocol) or even
TCP (Transmission Control Protocol, which underlies HTTP) but, in
practice, HTTP is the dominant transport. HTTP in this context includes HTTPS. The
other option (line 2) concerns the service <code class="literal">style</code>, in this case set to <code class="literal">document</code>.
A web service in <code class="literal">document</code> style always has an XML Schema or equivalent that types the
service’s constituent messages. The other choice for <code class="literal">style</code> is misleadingly named
<code class="literal">rpc</code>, which is short for <span class="emphasis"><em>remote procedure call</em></span>. The name is misleading
because a <code class="literal">document</code>-style service such as the <code class="literal">RandService</code> can and typically does
follow the request/response pattern, which is the RPC pattern. In the context of a
WSDL, <code class="literal">rpc</code> style really means that messages themselves are not typed, only their
arguments and return values. The WSDL for an <code class="literal">rpc</code> style service may have no <code class="literal">types</code>
section at all or only an abbreviated one. In modern SOAP-based services,
<code class="literal">document</code> style dominates and represents best practice. Indeed, both Java and DotNet
toyed for a time with the idea of dropping support altogether for <code class="literal">rpc</code> style. The
issue of <code class="literal">rpc</code> style will come up again later but only briefly.</p><p>The <code class="literal">document</code> style deserves to be the default. This style can support services with
rich, explicitly defined Java data types such as <code class="literal">Employee</code> or <code class="literal">ChessTournament</code> because the
service’s WSDL can define, for the XML side, the required types in an XML Schema. Any
service pattern, including request/response, is possible under the document style.</p><p>The last option concerns <code class="literal">use</code>, more accurately called <span class="emphasis"><em>encoding</em></span>, because
the choice determines how the service’s data types are to be encoded and decoded.
The WSDL has to specify how the data types used
in an implementation language such as Java are to be serialized into and
deserialized out of WSDL-compliant types—the types laid out in the WSDL’s XML Schema
or equivalent (see <a class="xref" href="#encode" title="Example 12. Encoding and decoding XML.">Example 12, “Encoding and decoding XML.”</a>). For example, Java and Ruby have similar but subtly different
data types. In a conversation based on SOAP messages, a conversation in which the
SOAP remains transparent, the two languages would need the ability to serialize from instances of
native types to XML and to deserialize from XML to instances of native types.</p><div class="example"><a id="encode"></a><p class="title"><b>Example 12. Encoding and decoding XML.</b></p><div class="example-contents"><pre class="screen">           encode                   decode
Java types--------&gt;XML Schema types--------&gt;Ruby types

Java types&lt;--------XML Schema types&lt;--------Ruby types
           decode                   encode</pre></div></div><br class="example-break" /><p>The attribute</p><pre class="screen">use = 'literal'</pre><p>means the service’s type definitions in the WSDL <span class="emphasis"><em>literally</em></span> follow the
WSDL’s schema. The alternative to <code class="literal">literal</code> is named <code class="literal">encoded</code>, which means that
the service’s type definitions come from implicit encoding rules, typically
the rules in the SOAP 1.1 specification. However, the use of <code class="literal">encoded</code>
does not comply with WS-I (Web Services-Interoperability) standards (<span class="emphasis"><em>www/ws-i.org</em></span>).</p></div><div class="section" title="1.5.5. The service Section"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_service_literal_section"></a>1.5.5. The <code class="literal">service</code> Section</h4></div></div></div><p>This section brings the pieces together. Recall that a WSDL has but one
<code class="literal">portType</code> section but may have multiple <code class="literal">binding</code> sections. The <code class="literal">service</code>
element has <code class="literal">port</code> sub-elements, where a <code class="literal">port</code> is a <code class="literal">portType</code> linked to a
<code class="literal">binding</code>; hence, the number of <code class="literal">port</code> sub-elements equals the number of
<code class="literal">binding</code> sections in the WSDL. In this example, there is one <code class="literal">binding</code>
and, therefore, one <code class="literal">port</code> sub-element:</p><pre class="screen">&lt;port name="RandServicePort" binding="tns:RandServicePortBinding"&gt;
   &lt;soap:address location="http://localhost:8888/rs"&gt;&lt;/soap:address&gt; <a id="CO1-26"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
&lt;/port&gt;</pre><p>The <code class="literal">address</code> sub-element specifies a <code class="literal">location</code> (line 1), whose value is commonly
called the <span class="emphasis"><em>service endpoint</em></span>. A web service with two significantly different
bindings (for instance, one for HTTP and another for SMTP) would have
different <code class="literal">location</code> values to reflect the different bindings.</p></div><div class="section" title="1.5.6. Java and XML Schema Data Type Bindings"><div class="titlepage"><div><div><h4 class="title"><a id="_java_and_xml_schema_data_type_bindings"></a>1.5.6. Java and XML Schema Data Type Bindings</h4></div></div></div><p>The foregoing examination of the WSDL, and in particular of its XML Schema, prompts an obvious question:
Which Java data types bind to which XML Schema data types? Table 1 summarizes the bindings.</p><div class="table"><a id="idp6031744"></a><p class="title"><b>Table 1. Java and XML Schema Data Type Bindings</b></p><div class="table-contents"><table summary="Java and XML Schema Data Type Bindings" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col /><col /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Java data type</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">XML Schema data type</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>boolean</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:boolean</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>byte</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:byte</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>short</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:short</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>short</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:unsignedByte</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>int</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:int</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>int</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:unsignedShort</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>long</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:long</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>long</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:unsignedInt</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>float</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:float</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>double</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:double</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>byte[ ]</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:hexBinary</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>byte[ ]</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:base64Binary</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>java.math.BigInteger</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:integer</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>java.math.BigDecimal</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:decimal</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>java.lang.String</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:string</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>java.lang.String</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:anySimpleType</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.datatype.XMLGregorianCalendar</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:dateTime</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.datatype.XMLGregorianCalendar</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:time</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.datatype.XMLGregorianCalendar</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:date</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.datatype.XMLGregorianCalendar</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:g</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.datatype.Duration</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:duration</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.namespace.QName</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:QName</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>javax.xml.namespace.QName</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>xsd:NOTATION</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>java.lang.Object</p></td><td style="" align="left" valign="top"><p>xsd:anySimpleType</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The bindings in Table 1 are automatic in the sense that, in a JAX-WS service, the SOAP infrastructure
does the conversions without application intervention. Conversions also are automatic for arrays of
any type in Table 1. For example, an array of <code class="literal">BigInteger</code> instances converts automatically to
an array of <code class="literal">xsd:integer</code> instances; and vice-versa. Programmer-defined classes whose properties reduce to any type
in Table 1 or to arrays of these likewise convert automatically. For example, an <code class="literal">Employee</code> class
that have properties such as <code class="literal">firstName</code> (<code class="literal">String</code>), <code class="literal">lastName</code> (<code class="literal">String</code>), <code class="literal">id</code> (<code class="literal">int</code>),
<code class="literal">salary</code> (<code class="literal">float</code>), <code class="literal">age</code> (<code class="literal">short</code>), <code class="literal">hobbies</code> (<code class="literal">String[ ]</code>), and the like would convert
automatically to XML Schema types. The upshot is that the vast majority of the data types used in
everyday Java programming convert automatically to and from XML Schema types. The glaring exception is the
<code class="literal">Map</code>, that is, a collection of key/value pairs. However, a <code class="literal">Map</code> is readily implemented as a pair of
coordinated arrays: one for the keys, the other for the values.</p><div class="sidebar" title="Code First or Contract First?"><p class="title"><b>Code First or Contract First?</b></p><p>Should the web service code be used to generate the WSDL or should the WSDL,
designed beforehand, be used to guide the coding of the web service? This is
question sums up the <span class="emphasis"><em>code first versus contract first</em></span> controversy. The
examples so far take the code-first approach: the service publisher (for
example, <code class="literal">Endpoint</code> or Tomcat) automatically generates the WSDL for the
service. The code-first approach has the obvious appeal of being easy. Yet
the code-first approach has drawbacks, including:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
If the service changes under a code-first approach, the WSDL thereby changes—and client
code generated from the WSDL (using, for instance, <span class="emphasis"><em>wsimport</em></span>) needs to be re-generated.
In this sense, the code-first approach is not client friendly.
The code-first approach compromises a basic principle of software development: a
service contract, once published, should be treated as immutable so that client-side
code written against a published service never has to be rewritten.
</li><li class="listitem">
The code-first approach goes against the <span class="emphasis"><em>language neutrality</em></span> at the core of web
services. If a service contract is done first, the implementation language remains open.
</li><li class="listitem"><p class="simpara">
The code-first approach does not address tricky but common problems such as
<code class="literal">null</code> arguments or return values.  Consider, for example, a very simple service
that includes an operation to return the current time as a string:
</p><pre class="screen">@WebMethod
public String getTime() { return new java.util.Date().toString(); }</pre><p class="simpara">Here is the relevant entry in the XML Schema from the automatically
generated WSDL:</p><pre class="screen">&lt;xs:element name="return" type="xs:string" minOccurs="0"&gt;&lt;/xs:element&gt;</pre><p class="simpara">The <code class="literal">minOccurs</code> value of <code class="literal">0</code> allows the <code class="literal">getTime</code> operation to return <code class="literal">null</code>.
Suppose, however, the service needs to ensure that returned string has no
fewer than, say, 28 characters, which rules out <code class="literal">null</code> as a return value. (In Java a stringified
<code class="literal">Date</code> has 28 characters.)
The relevant schema section might look like this:</p><pre class="screen">&lt;xs:element minOccurs = "1"
            maxOccurs = "1"
            nillable  = "false"
            name      = "currentTime"&gt;
    &lt;simpleType&gt;
      &lt;restriction base  = "string"&gt;
        &lt;minLength value = "28"/&gt;
      &lt;/restriction&gt;
    &lt;/simpleType&gt;
&lt;/xs:element&gt;</pre><p class="simpara">By the way, the <code class="literal">minOccurs</code> and <code class="literal">maxOccurs</code> elements, each with a value of <code class="literal">1</code>,
could be dropped altogether because <code class="literal">1</code> is the default value for these attributes. The point here
is that a schema entry such as this must be hand-crafted. Even a clever use of
Java annotations is not sufficient to produce this entry automatically.</p></li></ul></div><p>Given the ease of the code-first approach—not to mention the economic pressures and hectic pace of software development—there
seems to be little chance that a contract-first approach to web services will eclipse the
dominant code-first approach. Nonetheless, a code-first generated WSDL and its accompanying schema
can be refined as needed to ensure that this contract document reflects service requirements.</p></div></div><div class="section" title="1.5.7. Wrapped and Unwrapped Document Style"><div class="titlepage"><div><div><h4 class="title"><a id="_wrapped_and_unwrapped_document_style"></a>1.5.7. Wrapped and Unwrapped Document Style</h4></div></div></div><p>The source for the <code class="literal">RandService</code> class begins as follows:</p><pre class="screen">@WebService
public class RandService {
...</pre><p>The default style, <code class="literal">document</code>, could be overridden with an additional annotation:</p><pre class="screen">@WebService
@SOAPBinding(style = Style.RPC) // versus Style.DOCUMENT, the default
public class RandService {
...</pre><p>The <code class="literal">RandService</code> is simple enough that the difference would be transparent to
clients against the service. Of interest here is how the different styles
impact the underlying SOAP messages.</p><p>Consider a very simple SOAP-based service with an operations named <code class="literal">add</code>, <code class="literal">subtract</code>,
<code class="literal">multiply</code>, and <code class="literal">divide</code>. Each operation expects two arguments, the numbers on which
to operate. Under the original SOAP 1.1
specification, a request message for <code class="literal">document</code> style—what is now called
<span class="emphasis"><em>unwrapped</em></span> or <span class="emphasis"><em>bare</em></span> document style—would look like this:</p><div class="example"><a id="ex_ch04_unwrapped"></a><p class="title"><b>Example 13. Unwrapped document style.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" ?&gt;
&lt;!-- Unwrapped document style --&gt;
&lt;soapenv:Envelope
    xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;soapenv:Body&gt;
     &lt;num1 xmlns:ans="http://arith/"&gt;27&lt;/num1&gt;
     &lt;num2 xmlns:ans="http://arith/"&gt;94&lt;/num2&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;</pre></div></div><br class="example-break" /><p>The <code class="literal">Body</code> of the SOAP message contains two elements at the same level, the elements
tagged <code class="literal">num1</code> and <code class="literal">num2</code>; each element is a child of the <code class="literal">soapenv:Body</code> element.
The glaring omission is the name of the operation, for instance, <code class="literal">add</code>. This name
might occur instead, for example, in the request URL:</p><pre class="screen">http://some.server.org/add</pre><p>It is peculiar that the SOAP envelope should contain the named arguments but not
the named operation. Under <code class="literal">rpc</code> style, however, the operation would be the
one and only child of the <code class="literal">Body</code> element; and the operation then would have, as its own
child elements, the arguments. Here is the contrasting SOAP message in <span class="emphasis"><em>rpc</em></span> style or,
what now comes to the same thing, <span class="emphasis"><em>wrapped document style</em></span>:</p><div class="example"><a id="ex_ch02_wrapped"></a><p class="title"><b>Example 14. Wrapped document style, the same as rpc style.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" ?&gt;
&lt;!-- Wrapped document or rpc style --&gt;
&lt;soapenv:Envelope
    xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;soapenv:Body&gt;
     &lt;add xmlns:ans="http://arith/"&gt;  <a id="CO1-27"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
       &lt;num1&gt;27&lt;/num1&gt;
       &lt;num2&gt;94&lt;/num2&gt;
     &lt;/addNums&gt;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;</pre></div></div><br class="example-break" /><p>The <code class="literal">add</code> element (line 1) now acts as a <span class="emphasis"><em>wrapper</em></span> for the argument elements, in this case <code class="literal">num1</code> and <code class="literal">num2</code>.
The wrapped convention, unofficial but dominant in SOAP frameworks, gives a <code class="literal">document</code>-style service the look-and-feel
of an <code class="literal">rpc</code>-style service—at the message level. The document style still has the advantage of a
full XML Schema that types the messages.
In Java as in DotNet, the default style for any SOAP-based service is <span class="emphasis"><em>wrapped document</em></span>; hence, a service such
as <code class="literal">RandService</code>, with only the <code class="literal">@WebService</code> annotation, is wrapped document in style. By the way, this
style is often shortened to <span class="emphasis"><em>wrapped doc/lit</em></span>: wrapped document style with literal encoding.</p><div class="sidebar" title="Another practical use for the WSDL and Its XML Schema."><p class="title"><b>Another practical use for the WSDL and Its XML Schema.</b></p><p>A utility such as <span class="emphasis"><em>wsimport</em></span> consumes a WSDL and produces Java classes that ease the task of writing a
client against the service defined in the WSDL. However, the <span class="emphasis"><em>wsimport</em></span> utility also be used to generate
service-side code (see the next section on <span class="strong"><strong><span class="emphasis"><em>wsimport</em></span> Artifacts for the Service Side</strong></span>).
There are other practical uses for the WSDL. Consider
a scenario (see <a class="xref" href="#wsdl_schema" title="Example 15. Using the WSDL’s XML Schema for message validation.">Example 15, “Using the WSDL’s XML Schema for message validation.”</a>) in which incoming SOAP requests target operations encapsulated in a document-style SOAP-based
service.</p><div class="example"><a id="wsdl_schema"></a><p class="title"><b>Example 15. Using the WSDL’s XML Schema for message validation.</b></p><div class="example-contents"><pre class="screen">                        +-------------------------------------------+
                        |     +---------+             +-----------+ |
 Incoming SOAP requests |     | SOAP    | validated   | Requested | |
-----------------------&gt;|----&gt;| message |------------&gt;| service   | |
                        | +--&gt;| parser  |             | operation | |
                        | |   +---------+             +-----------+ |
                        | |                                         |
                        | XML Schema                                |
                        +-------------------------------------------+
                                   Service container</pre></div></div><br class="example-break" /><p>If the service is doc/lit, there is a WSDL with an attendant XML Schema; and this schema can be used
in a validating parse of the incoming SOAP messages. In XML, a <span class="emphasis"><em>validating parse</em></span> checks whether the
a document, in this case a SOAP document, is syntactically correct but also
whether the document conforms to a grammar, the XML Schema. If the parser does not validate the incoming message,
there is no point in wasting CPU cycles on the execution of the service operation.
Every document-style service has an XML Schema or equivalent as part of service’s WSDL. Accordingly, this schema can be used
to check whether SOAP messages satisfy the grammar that the schema represents.</p></div></div><div class="section" title="1.5.8. wsimport Artifacts for the Service Side"><div class="titlepage"><div><div><h4 class="title"><a id="_emphasis_wsimport_emphasis_artifacts_for_the_service_side"></a>1.5.8. <span class="emphasis"><em>wsimport</em></span> Artifacts for the Service Side</h4></div></div></div><p>The <span class="emphasis"><em>wsimport</em></span> utility produces, from a WSDL document, code that directly supports client calls against a web service.
This same code can be used, with a few adjustments, to program a service. This section illustrates with
a simple example.</p><p>Here are two operations for a temperature-conversion service written in C#:</p><pre class="screen">[WebMethod]
public double c2f(double t) { return 32.0 + (t * 9.0 / 5.0); }
[WebMethod]
public double f2c(double t) { return (5.0 / 9.0) * (t - 32.0); }</pre><p>The <code class="literal">c2f</code> operation converts from centigrade to fahrenheit and the <code class="literal">f2c</code> method converts from fahrenheit to
centigrade.</p><p>DotNet, by default, generates a WSDL with SOAP 1.1 and SOAP 1.2 bindings. This temperature-conversion
service is simple enough that the two bindings have the same implementation. In general, however, the
<span class="emphasis"><em>wsimport</em></span> utility can handle multiple bindings with the <span class="emphasis"><em>-extension</em></span> flag. Assuming that the WSDL for the
service is in the file <span class="emphasis"><em>tc.wsdl</em></span>, the command</p><pre class="screen">% wsimport -p tempConvert -keep -extension tc.wsdl</pre><p>generates the usual artifacts: Java <span class="emphasis"><em>.class</em></span> files that represent the <code class="literal">c2f</code> and <code class="literal">f2c</code> request messages and their
corresponding responses together with various support files. Of interest here is the <code class="literal">interface</code>, that is,
the Java file that represents the <code class="literal">portType</code> section of the WSDL. Here is the file, cleaned up for
readability:</p><pre class="screen">package tempConvert;

import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.ws.RequestWrapper;
import javax.xml.ws.ResponseWrapper;

@WebService(name = "ServiceSoap",
            targetNamespace = "http://tempConvertURI.org/")
@XmlSeeAlso({
    ObjectFactory.class
})
public interface ServiceSoap {
    @WebMethod(operationName = "c2f",
               action = "http://tempConvertURI.org/c2f")
    @WebResult(name = "c2fResult",
               targetNamespace = "http://tempConvertURI.org/")
    @RequestWrapper(localName = "c2f",
                    targetNamespace = "http://tempConvertURI.org/",
                    className = "tempConvert.C2F")
    @ResponseWrapper(localName = "c2fResponse",
                     targetNamespace = "http://tempConvertURI.org/",
                     className = "tempConvert.C2FResponse")
    public double c2F(
        @WebParam(name = "t",
                  targetNamespace = "http://tempConvertURI.org/")
        double t);
    @WebMethod(operationName = "f2c",
               action = "http://tempConvertURI.org/f2c")
    @WebResult(name = "f2cResult",
               targetNamespace = "http://tempConvertURI.org/")
    @RequestWrapper(localName = "f2c",
                    targetNamespace = "http://tempConvertURI.org/",
                    className = "tempConvert.F2C")
    @ResponseWrapper(localName = "f2cResponse",
                     targetNamespace = "http://tempConvertURI.org/",
                     className = "tempConvert.F2CResponse")
    public double f2C(
        @WebParam(name = "t",
                  targetNamespace = "http://tempConvertURI.org/")
        double t);
}</pre><p>The <code class="literal">ServiceSoap</code> interface, like any interface, <span class="emphasis"><em>declares</em></span> but does not <span class="emphasis"><em>define</em></span> methods, which
in this case represent service operations. If the semantics of these two operations
<code class="literal">c2f</code> and <code class="literal">f2c</code> are understood, then converting this <span class="emphasis"><em>wsimport</em></span> artifact to a web service
is straightforward:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Change the <code class="literal">interface</code> to a POJO <code class="literal">class</code>:
</p><pre class="screen">...
public class ServiceSoap {
...</pre></li><li class="listitem"><p class="simpara">
Implement the <code class="literal">c2f</code> and <code class="literal">f2c</code> operations by defining the methods. Java and C# are sufficiently
close that the two implementations would be indistinguishable. For example, here is the body of <code class="literal">c2f</code> in
either language:
</p><pre class="screen">public double c2f(double t) { return 32.0 + (t * 9.0 / 5.0); }</pre><p class="simpara">Not every language is as close to Java as is C#, of course. Whatever the original implementation of a service,
the challenge is the same: to understand what a service operation is supposed to do so that
the operation can be re-implemented in Java.</p></li><li class="listitem">
Publish the service with, for example, <code class="literal">Endpoint</code> or a web server such as Tomcat or Jetty.
</li></ul></div><p>Although the <span class="emphasis"><em>wsimport</em></span> utility could be used to help write a SOAP-based service in Java, the main use of this
utility is still in support of clients against a SOAP-based service. The point to underscore is that the
WSDL is sufficiently rich in detail to support useful code on either the service or the client side. The next
section returns to the Amazon E-Commerce service to illustrate this very point.</p></div></div><div class="section" title="1.6. SOAP-based Clients against Amazon’s E-Commerce Service"><div class="titlepage"><div><div><h3 class="title"><a id="_soap_based_clients_against_amazon_8217_s_e_commerce_service"></a>1.6. SOAP-based Clients against Amazon’s E-Commerce Service</h3></div></div></div><p>Chapter 2 has two Java clients against the RESTful Amazon E-Commerce service. The first client (Section 2.3) parses the
XML document from Amazon in order to extract the desired information, in this case the author of a specified Harry Potter
book, J. K. Rowling. The second client (Section 2.5) uses JAX-B to deserialize the returned XML document into a Java object, whose
<span class="emphasis"><em>get</em></span>-methods are then used to extract the same information. This section introduces two more clients against
the E-Commerce service; but in this case the service is SOAP-based and, therefore, the clients are as well. The SOAP-based
clients use a <span class="emphasis"><em>handler</em></span>, Java code that has access to every outgoing and incoming SOAP message. In the case of Amazon,
the handler’s job is to
inject into the SOAP request the authentication information that Amazon requires, in particular a digest based on the
<span class="emphasis"><em>secretKey</em></span> used in both of the RESTful clients of Chapter 2. A message digest generated with the <span class="emphasis"><em>secretKey</em></span>, rather than the <span class="emphasis"><em>secretKey</em></span>
itself, is sent from the client to the Amazon service; hence, the <span class="emphasis"><em>secretKey</em></span> itself does not travel over the wire.
SOAP handlers are the focus of the next chapter; for now,
a handler is used but not analyzed.</p><p>The SOAP-based clients against Amazon’s E-Commerce service, like the other SOAP-based Java clients in this chapter, rely upon
<span class="emphasis"><em>wsimport</em></span>-generated classes as building blocks. There are some key points about the SOAP-based service and its clients:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
The WSDL and <span class="emphasis"><em>wsimport</em></span>:
</p><p class="simpara">The WSDL for the SOAP-based version of Amazon’s E-Commerce service is available at:</p><pre class="screen">http://webservices.amazon.com/AWSECommerceService/AWSECommerceService.wsdl</pre><p class="simpara">This WSDL is more than 1,500 lines in size, with most of these lines
in the XML Schema. The <span class="emphasis"><em>wsimport</em></span> utility can be applied to this WSDL in the usual way:</p><pre class="screen">% wsimport -p amazon -keep \
  http://webservices.amazon.com/AWSECommerceService/AWSECommerceService.wsdl \
  -b custom.xml</pre><p class="simpara">The result is a directory/package named <span class="emphasis"><em>amazon</em></span> filled with client-support classes generated from the WSDL. The
part at the end, with <span class="emphasis"><em>custom.xml</em></span>, is explained shortly.</p></li><li class="listitem"><p class="simpara">
Client-side API styles:
</p><p class="simpara">The Amazon SOAP-based service follows best design practices and is, therefore, <span class="emphasis"><em>wrapped doc/lit</em></span>. However, <span class="emphasis"><em>wsimport</em></span>
can generate different <span class="emphasis"><em>client</em></span> APIs from one and the same Amazon WSDL. This point deserves elaboration. Consider a
very simple operation in a SOAP-based service, which takes two arguments, text and a pattern, and returns the number of times
that the pattern occurs in the text. For example, the text might be the novel <span class="emphasis"><em>War and Peace</em></span> and the pattern might be
the name of one of heroines, <span class="emphasis"><em>Natasha</em></span>. The operation is named <span class="emphasis"><em>getCount</em></span>. There are different ways in which this
operation might be implemented in Java. Perhaps the obvious implementation would have the declaration</p><pre class="screen">public int getCount(String text, String pattern);</pre><p class="simpara">This version takes two arguments, the text and the pattern, and returns the count as an <code class="literal">int</code>.
Yet the client of a SOAP-based web service, following in the footsteps of DCE/RPC, can distinguish between <span class="emphasis"><em>in</em></span> and <span class="emphasis"><em>out</em></span> parameters, that is,
arguments passed <span class="emphasis"><em>into</em></span> the service and ones passed <span class="emphasis"><em>out of</em></span> this same service and back to the client. This possibility opens the way to a quite
different version of <span class="emphasis"><em>getCount</em></span>:</p><pre class="screen">public void getCount(String text, String pattern, Holder result);</pre><p class="simpara">The return type for <code class="literal">getCount</code> is now <code class="literal">void</code>, which means that the <span class="emphasis"><em>count</em></span> must returned in some other way.
The third parameter, of the special type <code class="literal">Holder</code>, embeds the desired count of <code class="literal">pattern</code> occurrences in the
<code class="literal">text</code>. This programming style is uncommon in Java and, accordingly, might be judged inferior to the two-argument version of
<code class="literal">getCount</code> that returns the <span class="emphasis"><em>count</em></span> directly as an <code class="literal">int</code>. The point of interest is that <span class="emphasis"><em>wsimport</em></span> can generate
client-side artifacts in either style; and, perhaps surprisingly, the second style is the default for
<span class="emphasis"><em>wsimport</em></span>. In Java the first style is</p><pre class="screen">SOAPBinding.ParameterStyle.BARE</pre><p class="simpara">and the second style is</p><pre class="screen">SOAPBinding.ParameterStyle.WRAPPED</pre><p class="simpara">The critical point is that these <span class="emphasis"><em>parameter styles</em></span> refer to the
<span class="emphasis"><em>wsimport</em></span> artifacts generated from a service WSDL—the parameter styles do not refer to the structure of the service itself,
which remains <span class="emphasis"><em>wrapped doc/lit</em></span>. Java’s <span class="emphasis"><em>wsimport</em></span> utility can present this service style, on the client side, in different ways,
ways known as <span class="emphasis"><em>parameter styles</em></span> in Java.</p></li><li class="listitem"><p class="simpara">
Authentication credentials in a SOAP-based client:
</p><p class="simpara">A SOAP-based client against E-Commerce must send the same authentication credentials as a RESTful client: a
registered user’s <span class="emphasis"><em>accessId</em></span> and a hash value generated with the <span class="emphasis"><em>secretKey</em></span>. In a REST-style client, these credentials are sent in the
query string of a GET request. A SOAP-based client is different in that its requests are all POSTs, even
if the intended web service operation is a <span class="emphasis"><em>read</em></span>. In a SOAP-based exchange over HTTP, the request is a
SOAP envelope that is the body of a POST request. Accordingly, a SOAP-based client must process the
required credentials in a different way. In this section, the credential processing is partly the job of a SOAP <span class="emphasis"><em>handler</em></span>,
which is examined carefully in the next chapter.</p></li></ul></div><p>In Chapter 3, the clients against the RESTful E-Commerce service did <span class="emphasis"><em>lookup</em></span> operations. For contrast, the SOAP-based
client does a <span class="emphasis"><em>search</em></span> against the Amazon E-Commerce service. The <code class="literal">AmazonClientBareStyle</code> (see <a class="xref" href="#Ex11" title="Example 16. A SOAP-based Amazaon client in bare parameter style.">Example 16, “A SOAP-based Amazaon client in <span class="emphasis"><em>bare parameter style</em></span>.”</a>) is the
first and friendliest SOAP-based client.</p><div class="example"><a id="Ex11"></a><p class="title"><b>Example 16. A SOAP-based Amazaon client in <span class="emphasis"><em>bare parameter style</em></span>.</b></p><div class="example-contents"><pre class="screen">package amazon;

import amazon.AWSECommerceService;
import amazon.AWSECommerceServicePortType;
import amazon.ItemSearchRequest;
import amazon.ItemSearchResponse;
import amazon.ItemSearch;
import amazon.Items;
import amazon.Item;
import amazon.AwsHandlerResolver;
import java.util.List;

class AmazonClientBareStyle {
    public static void main(String[ ] args) {
        if (args.length &lt; 2) {
            System.err.println("AmazonClientBareStyle &lt;accessId&gt; &lt;secretKey&gt;");
            return;
        }
        final String accessId = args[0];
        final String secretKey = args[1];

        AWSECommerceService service = new AWSECommerceService();                  <a id="CO1-28"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        service.setHandlerResolver(new AwsHandlerResolver(secretKey));            <a id="CO1-29"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        AWSECommerceServicePortType port = service.getAWSECommerceServicePort();  <a id="CO1-30"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        ItemSearchRequest request = new ItemSearchRequest();                      <a id="CO1-31"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        request.setSearchIndex("Books");
        request.setKeywords("Austen");
        ItemSearch itemSearch= new ItemSearch();                                  <a id="CO1-32"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        itemSearch.setAWSAccessKeyId(accessId);
        itemSearch.setAssociateTag("kalin");
        itemSearch.getRequest().add(request);
        ItemSearchResponse response = port.itemSearch(itemSearch);                <a id="CO1-33"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        List&lt;Items&gt; itemsList = response.getItems();                              <a id="CO1-34"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
        int i = 1;
        for (Items next : itemsList)
           for (Item item : next.getItem())
               System.out.println(String.format("%2d: ", i++) +
                                  item.getItemAttributes().getTitle());
    }
}</pre></div></div><br class="example-break" /><p>The ZIP file with the sample code includes an executable JAR with the code from
Example 11 and its dependencies. The JAR can be executed as follows:</p><pre class="screen">% java -jar AmazonClientBare.jar &lt;accessId&gt; &lt;secretKey&gt;</pre><p>The <code class="literal">AmazonClientBareStyle</code> highlights what SOAP-based services have to offer to their
clients. The <span class="emphasis"><em>wsimport</em></span>-generated classes include the
<code class="literal">AWSECommerceService</code> with a no-argument constructor. This class represents, to the
client, the E-Commerce service. The usual two-step occurs: in line 1 an <code class="literal">AWSECommerceService</code>
instance is constructed and in line 3 the <code class="literal">getAWSECommerceServicePort</code> method
then is invoked. The object reference <code class="literal">port</code> now can be used, in line 6, to launch a search against
the E-Commerce service, which results in an <code class="literal">ItemSearchResponse</code>. Line 2 in the set-up hands over
the user’s <span class="emphasis"><em>secretKey</em></span> to the client-side handler, which uses the <span class="emphasis"><em>secretKey</em></span> to generate
a hash value as a <span class="emphasis"><em>message authentication code</em></span>, which Amazon then can verify on the service side.</p><p>The remaining code, from line 7 on, resembles the code in the second RESTful client against
the E-Commerce service. Here is a quick review of the SOAP-based code:</p><pre class="screen">List&lt;Items&gt; itemsList = response.getItems();                              <a id="CO1-35"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
int i = 1;
for (Items next : itemsList)
   for (Item item : next.getItem())                                       <a id="CO1-36"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
      System.out.println(String.format("%2d: ", i++) +
                         item.getItemAttributes().getTitle());            <a id="CO1-37"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" /></pre><p>The <code class="literal">ItemSearchResponse</code> from Amazon encapsulates a list of <code class="literal">Items</code> (line 1),
each of whose members is itself a list. The nested <code class="literal">for</code> loop iterates (line 2) over the
individual <code class="literal">Item</code> instances, printing the title of each book found (line 3). By the way,
the search returns the default number of items found, 10; it is possible to
ask for all of the items found. On a sample run, the output was:</p><pre class="screen"> 1: Persuasion (Dover Thrift Editions)
 2: Pride and Prejudice (The Cambridge Edition of the Works of Jane Austen)
 3: Emma (Dover Thrift Editions)
 4: Northanger Abbey (Dover Thrift Editions)
 5: Mansfield Park
 6: Love and Friendship
 7: Jane Austen: The Complete Collection (With Active Table of Contents)
 8: Lady Susan
 9: Jane Austen Collection: 18 Works, Pride and Prejudice, Love and Friendship,
         Emma, Persuasion, Northanger Abbey, Mansfield Park, Lady Susan &amp; more!
10: The Jane Austen Collection: 28 Classic Works</pre><p>Now is the time to clarify the <span class="emphasis"><em>custom.xml</em></span> file used in the <span class="emphasis"><em>wsimport</em></span> command against the
Amazon WSDL. The
file name <span class="emphasis"><em>custom.xml</em></span> is arbitrary and, for review, here is the <span class="emphasis"><em>wsimport</em></span> command:</p><pre class="screen">% wsimport -p amazon -keep \
  http://webservices.amazon.com/AWSECommerceService/AWSECommerceService.wsdl \
  -b custom.xml</pre><p>The file <span class="emphasis"><em>custom.xml</em></span> is:</p><pre class="screen">&lt;jaxws:bindings
    wsdlLocation =
     "http://ecs.amazonaws.com/AWSECommerceService/AWSECommerceService.wsdl"
    xmlns:jaxws="http://java.sun.com/xml/ns/jaxws"&gt;
  &lt;jaxws:enableWrapperStyle&gt;false&lt;/jaxws:enableWrapperStyle&gt;  <a id="CO1-38"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
&lt;/jaxws:bindings&gt;</pre><p>The key element in the file sets the <code class="literal">enableWrapperStyle</code> for the parameters to <code class="literal">false</code> (line 1). The
result is the <span class="emphasis"><em>bare</em></span> parameter style evident in the <code class="literal">AmazonClientBareStyle</code> code.
The alternative to this style is the default one, the client-side <span class="emphasis"><em>wrapped style</em></span>.
The <code class="literal">AmazonClientWrappedStyle</code> (see <a class="xref" href="#Ex15" title="Example 17. A SOAP-based Amazon client in wrapped parameter style.">Example 17, “A SOAP-based Amazon client in <span class="emphasis"><em>wrapped parameter style</em></span>.”</a>) is a SOAP-based Amazon client in the default style.</p><div class="example"><a id="Ex15"></a><p class="title"><b>Example 17. A SOAP-based Amazon client in <span class="emphasis"><em>wrapped parameter style</em></span>.</b></p><div class="example-contents"><pre class="screen">package amazon2;

import amazon2.AWSECommerceService;
import amazon2.AWSECommerceServicePortType;
import amazon2.ItemSearchRequest;
import amazon2.ItemSearch;
import amazon2.Items;
import amazon2.Item;
import amazon2.OperationRequest;
import amazon2.SearchResultsMap;
import amazon2.AwsHandlerResolver;

import javax.xml.ws.Holder;
import java.util.List;
import java.util.ArrayList;

class AmazonClientWrappedStyle {
    public static void main(String[ ] args) {
      if (args.length &lt; 2) {
        System.err.println("java AmazonClientWrappedStyle &lt;accessId&gt; &lt;secretKey&gt;");
        return;
      }
      final String accessId = args[0];
      final String secretKey = args[1];

      AWSECommerceService service = new AWSECommerceService();
      service.setHandlerResolver(new AwsHandlerResolver(secretKey));
      AWSECommerceServicePortType port = service.getAWSECommerceServicePort();
      ItemSearchRequest request = new ItemSearchRequest();
      request.setSearchIndex("Books");
      request.setKeywords("Austen");
      ItemSearch search = new ItemSearch();
      search.getRequest().add(request);
      search.setAWSAccessKeyId(accessId);
      search.setAssociateTag("kalin");
      Holder&lt;OperationRequest&gt; operationRequest = null;      <a id="CO1-39"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
      Holder&lt;List&lt;Items&gt;&gt; items = new Holder&lt;List&lt;Items&gt;&gt;(); <a id="CO1-40"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
      port.itemSearch(search.getMarketplaceDomain(),         <a id="CO1-41"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                      search.getAWSAccessKeyId(),
                      search.getAssociateTag(),
                      search.getXMLEscaping(),
                      search.getValidate(),
                      search.getShared(),
                      search.getRequest(),
                      operationRequest,                      <a id="CO1-42"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
                      items);                                <a id="CO1-43"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
      Items retval = items.value.get(0);                     <a id="CO1-44"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
      int i = 1;
      List&lt;Item&gt; item_list = retval.getItem();               <a id="CO1-45"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
      for (Item item : item_list)
          System.out.println(String.format("%2d: ", i++) +
                             item.getItemAttributes().getTitle());
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">AmazonClientWrappedStyle</code> code uses <span class="emphasis"><em>wsimport</em></span>-generated classes created with the command:</p><pre class="screen">% wsimport -p amazon2 -keep \
  http://webservices.amazon.com/AWSECommerceService/AWSECommerceService.wsdl</pre><p>The WSDL is the same as in previous example but the style of the <span class="emphasis"><em>wsimport</em></span>-classes changes from
<span class="emphasis"><em>bare</em></span> to <span class="emphasis"><em>wrapped</em></span>, a change reflected in the <code class="literal">AmazonClientWrappedStyle</code> code. The change is evident
at lines 1 and 2, which declares two object references of type <code class="literal">Holder</code>. As the name suggests,
a <code class="literal">Holder</code> parameter is meant to hold some value returned from the E-Commerce service: the
<code class="literal">operationRequest</code> holds meta-data about the request, whereas <code class="literal">items</code> holds the book list
that results from a successful search. This idiom is common in C or C++ but rare—and, therefore,
clumsy—in Java. The <code class="literal">Holder</code> parameters are the last two (lines 4 and 5) of the nine parameters in the revised
<code class="literal">itemSearch</code> (line 3). On a successful search, <code class="literal">items</code> refers to a <code class="literal">value</code> (line 6) from which a list of
<code class="literal">Items</code> is extracted. This code, too, is awkward in Java. This list of <code class="literal">Items</code> has a <code class="literal">getItem</code> method (line 7),
which yields a <code class="literal">List&lt;Item&gt;</code> from which the individual <code class="literal">Item</code> instances, each representing a Jane Austen book,
can be extracted.</p><p>The <code class="literal">AmazonClientWrappedStyle</code> client is clearly the clumsier of the two clients against one and the same
SOAP-based E-Commerce service, a service that has a single WSDL and whose response payloads to the two clients are
identical in structure. The two clients differ markedly in their APIs, however. The <span class="emphasis"><em>bare</em></span> style API would be
familiar to most Java programmers but the <span class="emphasis"><em>wrapped</em></span> style, with its two <code class="literal">Holder</code> types, would seem a bit alien
even to an experienced Java programmer. Nonetheless, the <span class="emphasis"><em>wrapped</em></span> style remains the default in Java and in
DotNet.</p><div class="section" title="1.6.1. Asynchronous Clients against SOAP-based Services"><div class="titlepage"><div><div><h4 class="title"><a id="_asynchronous_clients_against_soap_based_services"></a>1.6.1. Asynchronous Clients against SOAP-based Services</h4></div></div></div><p>All of the SOAP-based clients examined so far make <span class="emphasis"><em>synchronous</em></span> or <span class="emphasis"><em>blocking</em></span> calls against a web service.
For example, consider these two lines from the <span class="emphasis"><em>bare</em></span> style client against the E-Commerce service:</p><pre class="screen">ItemSearchResponse response = port.itemSearch(itemSearch); <a id="CO1-46"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
List&lt;Items&gt; itemsList = response.getItems();               <a id="CO1-47"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" /></pre><p>The call in line 1 to <code class="literal">itemSearch</code> <span class="emphasis"><em>blocks</em></span> in the sense that line 2 does not execute until <code class="literal">itemSearch</code> returns
a value, perhaps <code class="literal">null</code>. There are situations in which a client might need the invocation of <code class="literal">itemSearch</code>
to return immediately so that other application logic could be performed in the meantime. In this case, a
<span class="emphasis"><em>non-blocking</em></span> or <span class="emphasis"><em>asynchronous</em></span> call to <code class="literal">itemSearch</code> would be appropriate.</p><div class="example"><a id="client_async"></a><p class="title"><b>Example 18. An client that makes asynchronous requests against the <code class="literal">RandService</code>.</b></p><div class="example-contents"><pre class="screen">import javax.xml.ws.AsyncHandler;
import javax.xml.ws.Response;
import java.util.List;
import clientAsync.RandServiceService;
import clientAsync.RandService;
import clientAsync.NextNResponse;

public class RandClientAsync {
    public static void main(String[ ] args) {
        RandServiceService service = new RandServiceService();
        RandService port = service.getRandServicePort();
        port.nextNAsync(4, new MyHandler());                            <a id="CO1-48"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        try {
            Thread.sleep(5000); // in production, do something useful!
        }
        catch(Exception e) { }
        System.out.println("\nmain is exiting...");
    }
    static class MyHandler implements AsyncHandler&lt;NextNResponse&gt; {     <a id="CO1-49"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        public void handleResponse(Response&lt;NextNResponse&gt; future) {    <a id="CO1-50"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            try {
                NextNResponse response = future.get();                  <a id="CO1-51"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
                List&lt;Integer&gt; nums = response.getReturn();              <a id="CO1-52"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
                for (Integer num : nums) System.out.println(num);       <a id="CO1-53"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            }
            catch(Exception e) { System.err.println(e); }
        }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">RandClientAsync</code> (see <a class="xref" href="#client_async" title="Example 18. An client that makes asynchronous requests against the RandService.">Example 18, “An client that makes asynchronous requests against the <code class="literal">RandService</code>.”</a>) is an asynchronous client against the <code class="literal">RandService</code> (see <a class="xref" href="#Ex1" title="Example 1. A SOAP-based service with two operations.">Example 1, “A SOAP-based service with two operations.”</a>). Although an asynchronous
client also could be coded against the E-Commerce service, the far simpler <code class="literal">RandService</code> makes the client
itself relatively straightforward; it is then easier to focus on the asynchronous part of the API. No changes are
required in the <code class="literal">RandService</code> or its publication, under either <code class="literal">Endpoint</code> or a web server such as
Tomcat. The <span class="emphasis"><em>wsimport</em></span> command again takes a customization file, in this example <span class="emphasis"><em>customAsync.xml</em></span>;
the file name is arbitrary. The <span class="emphasis"><em>wsimport</em></span> command is:</p><pre class="screen">wsimport -p clientAsync -keep http://localhost:8888/rs?wsdl -b customAsync.xml</pre><p>The customized binding file is:</p><pre class="screen">&lt;jaxws:bindings
    wsdlLocation="http://localhost:8888/rs?wsdl"
    xmlns:jaxws="http://java.sun.com/xml/ns/jaxws"&gt;
  &lt;jaxws:enableAsyncMapping&gt;true&lt;/jaxws:enableAsyncMapping&gt; <a id="CO1-54"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
&lt;/jaxws:bindings&gt;</pre><p>The customized binding sets the <code class="literal">enableAsyncMapping</code> to <code class="literal">true</code> (line 1). The <span class="emphasis"><em>wsimport</em></span>
utility generates the same classes as in the earlier examples: <code class="literal">Next1</code>, <code class="literal">Next1Response</code>, and
so on. The request/response classes such as <code class="literal">Next1</code> and <code class="literal">Next1Response</code> have additional
methods, however, to handle the asynchronous calls; and these classes still have the
methods that make synchronous calls.</p><p>The set-up in the asynchronous client is the familiar two-step: first create a
service instance and then invoke the <code class="literal">getRandService</code> method on this instance. The dramatic
change is line 1, the asynchronous call, which now takes two arguments:</p><pre class="screen">port.nextNAsync(4, new MyHandler());</pre><p>Although the <code class="literal">nextNAsync</code> method does return a value, my code does not bother to assign this value to a variable.
The reason is that the Java run-time passes the <code class="literal">NextNResonse</code> message from the <code class="literal">RandService</code> to the client’s event handler,
an instance of <code class="literal">MyHandler</code>, which then
extracts and prints the randomly generated integers from the service.</p><p>The call to <code class="literal">nextNAsync</code>, a method declared together with <code class="literal">nextN</code> in the <span class="emphasis"><em>wsimport</em></span>-generated <code class="literal">RandService</code> interface,
takes two arguments: the number of requested random numbers and an event handler, in this
case a <code class="literal">MyHandler</code> instance. The handler class <code class="literal">MyHandler</code> must implement the <code class="literal">AsyncHandler</code>
interface (line 2) by defining the <code class="literal">handleResponse</code> method (line 3). The <code class="literal">handleResonse</code> method
follows the standard Java pattern for event handlers: the method has <code class="literal">void</code> as its return type
and it expects one argument, an event triggered by a <code class="literal">Response&lt;NextNResponse&gt;</code> that
arrives at the client.</p><p>When the client runs, the <code class="literal">main</code> thread executes the asynchronous call to <code class="literal">nextNAsync</code>, which
returns immediately. To prevent the <code class="literal">main</code> thread from exiting <code class="literal">main</code> and thereby ending the
application, the client invokes <code class="literal">Thread.sleep</code>. This is contrived, of course; in a production
environment, the <code class="literal">main</code> thread presumably would go on to do meaningful work. In this example,
the point is to illustrate the execution pattern. When the <code class="literal">RandService</code> returns the requested
integers, the Java run-time starts a (daemon) thread to execute the <code class="literal">handleResponse</code> callback,
which prints the requested integers. In the meantime, the <code class="literal">main</code> thread eventually wakes up
and exits <code class="literal">main</code>, thereby terminating the client’s execution. On a sample run, the output was:</p><pre class="screen">1616290443
-984786015
1002134912
311238217
main is exiting...</pre><p>The daemon thread executing <code class="literal">handleResponse</code> prints the four integers and the <code class="literal">main</code> thread prints the
good-bye message.</p><p>Java and DotNet take different approaches towards generating, from a WSDL, support for asynchronous
calls against a service. DotNet automatically generates methods for synchronous and asynchronous
calls against the service; Java takes the more conservative approach of generating the
asynchronous artifacts only if asked to do so with a customized binding such as the one used in
this example.
The key point is that Java API, like its DotNet counterpart, fully supports synchronous and asynchronous calls
against SOAP-based services such as the <code class="literal">RandService</code>.</p><div class="sidebar" title="How are WSDL and UDDI related?"><p class="title"><b>How are WSDL and UDDI related?</b></p><p>WSDL documents, as service contracts, should be publishable and discoverable as are the services
that they describe.
A UDDI (Universal Description Discovery and Integration) registry is one way to publish a WSDL so that
potential clients can discover the document and ultimately consume the web service that the WSDL describes.
UDDI has a type system that accommodates WSDL documents as well as other kinds of formal
service contracts. From a UDDI perspective, a WSDL appears as
a two-part document. One part, which comprises the <code class="literal">types</code> through the <code class="literal">binding</code> sections,
is the UDDI <span class="emphasis"><em>service interface</em></span>. The other part, which comprises any <code class="literal">import</code> directives and
the <code class="literal">service</code> section, is the UDDI <span class="emphasis"><em>service implementation</em></span>. In WSDL, the service interface
(<code class="literal">portType</code> section) and service implementation (<code class="literal">binding</code> sections) are two parts of the
same document. In UDDI, the <span class="emphasis"><em>service interface</em></span> and <span class="emphasis"><em>service implementation</em></span> are two separate
documents; and these UDDI terms do not match up exactly with their WSDL counterparts.</p><p>A WSDL does not explain service semantics or, in plainer terms, what the service is about. The
WSDL does explain, in a clear and precise way, the service’s invocation syntax: the names of
the service operations (<span class="emphasis"><em>e.g.</em></span>, an operation such as <code class="literal">getTime</code>); the operation
pattern (<span class="emphasis"><em>e.g.</em></span>, request/response rather than solicit/response); the number, order, and type
of arguments that each operation expects; faults, if any, associated with a
service operation; and the number, order, and types of response values from an operation.
The W3C is pursuing initiatives in web semantics under the rubric of WSDL-S (Semantics).
For more on this topic, see <span class="emphasis"><em>www.w3.org/Submission/WSDL-S</em></span>. As of now, however, a WSDL is useful only
if the programmer already understands what the service is about. The WSDL can guide the
programmer through technical aspects of a web service; but this document presupposes rather than
provides an insight into service semantics.</p></div></div></div><div class="section" title="1.7. What’s Next?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_8217_s_next"></a>1.7. What’s Next?</h3></div></div></div><p>JAX-WS has two distinct but related APIs for SOAP-based web services. One API, with annotations such
as <code class="literal">@WebService</code> and <code class="literal">@WebMethod</code>, focuses on what might be called the <span class="emphasis"><em>application</em></span> level. On the
service side, annotations are used to create web services and to specify their operations. Additional
annotations such as <code class="literal">@WebParam</code> are available for fine-tuning and documenting
different aspects of a service and its operations. On the client side, the application API enables
clients to draw upon <span class="emphasis"><em>wsimport</em></span>-generated classes to access a SOAP-based service and to invoke its
operations. A central feature of the application level is the WSDL contract, which captures in XML the
service and its operations, including essential details such as the invocation syntax for the service
operations, the encoding/decoding scheme for data types, the transport used for messages, and the service endpoint.
Frameworks such as JAX-WS and DotNet come with utilities that put the WSDL to practical use.</p><p>A major appeal of the application level in JAX-WS is that the SOAP itself—the XML—remains
hidden on the service and the client sides. The underlying SOAP libraries serialize from Java into XML
and deserialize from XML into Java, thereby allowing both service and service client to work in Java data structures
and in familiar Java programming idioms. JAX-B and related utilities allow REST-style services in Java to work around
the XML or JSON payloads typical of REST-style services; but JAX-WS, which uses JAX-B under the hood, takes the
further step of automating the serialization/deserialization. JAX-WS is programmer friendly, on both the service and
client side.</p><p>The examples in this chapter have remained, for the most part, at the JAX-WS application level but have touched
on another level, the <span class="emphasis"><em>handler</em></span> level. A second JAX-WS API. with the <code class="literal">Handler</code> interface and its
two sub-interfaces <code class="literal">LogicalHandler</code> and <code class="literal">SOAPHandler</code>, provides access to the underlying SOAP. A <code class="literal">SOAPHandler</code>
gives the programmer access to the entire SOAP message, whereas the convenient <code class="literal">LogicalHandler</code> gives the
programmer access to the payload of the SOAP body. A <code class="literal">SOAPHandler</code> often is called a <span class="emphasis"><em>message handler</em></span> and a
<code class="literal">LogicalHandler</code> is called simply a <span class="emphasis"><em>logical handler</em></span>.</p><p>The handler API allows the programmer to inspect and, if needed, to manipulate the SOAP that the underlying
libraries generate. The distinction between the JAX-WS application and handler APIs in web services corresponds roughly to the
distinction between the distinction between the <span class="emphasis"><em>servlet</em></span> and <span class="emphasis"><em>filter</em></span> API in Java-based web sites. (One important difference
is that JAX-WS handlers are available on both the client and the service side.) This chapter introduced but did not explore
the handler API in the clients against Amazon’s E-Commerce service. In the REST-style clients of Chapter 2 against the E-Commerce
service, the clients made GET requests and critical pieces of information (<span class="emphasis"><em>e.g.</em></span>, the user’s <span class="emphasis"><em>accessId</em></span> and an HMAC hash
generated from the user’s <span class="emphasis"><em>secretKey</em></span>) had to be sent in the query string. The very same pieces of information are required in
a SOAP-based client but such a client, even when invoking a <span class="emphasis"><em>read</em></span> operation on the E-Commerce service, sends a POST request
whose body is a SOAP envelope. The JAX-WS libraries generate the SOAP envelope but a client-side handler, an instance of
the mentioned but not listed <code class="literal">AwsServiceHandler</code> class, inserts the user’s <span class="emphasis"><em>accessId</em></span>, the HMAC hash, and a strictly
formatted timestamp into the SOAP envelope, in particular into the SOAP body. The next chapter takes a close look at the
<code class="literal">AwsServiceHandler</code> class.</p><p>The next chapter goes down to the JAX-WS handler level by explaining, first, how the class <code class="literal">AwsServiceHandler</code> works in the
E-Commerce service clients. This chapter then does a full example with a client-side and a service-side handler, an example
that deliberately mimics the way that Amazon’s more complicated E-Commerce service works. JAX-WS also exposes to
the programmer the <span class="emphasis"><em>transport level</em></span>, which is almost always HTTP(S). On either the client-side or the service-side,
JAW-WS code can inspect and, if appropriate, modify the HTTP messages that carry SOAP messages as their payloads. JAX-WS
thus covers three distinct levels of SOAP-based web services: the application level, the handler level, and the transport
level. Chapter 5 also looks at some miscellaneous but related topics: SOAP faults in the application and handler levels, binary payloads in
SOAP services, and the Axis2 implementation of JAX-WS, which is an alternative to the Metro implementation.</p></div></div></div></body></html>

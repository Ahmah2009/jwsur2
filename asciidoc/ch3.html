<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#jwsur_3_chapter_3">1. RESTful Web Services: The Client Side</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_challenges_on_the_client_side">1.1. The Challenges on the Client Side</a></span></dt><dt><span class="section"><a href="#_a_perl_client_against_a_java_restful_web_service">1.2. A Perl Client against a Java RESTful Web Service</a></span></dt><dt><span class="section"><a href="#_a_client_against_the_amazon_e_commerce_service">1.3. A Client against the Amazon E-Commerce Service</a></span></dt><dt><span class="section"><a href="#_a_standalone_jax_b_example">1.4. A Standalone JAX-B Example</a></span></dt><dt><span class="section"><a href="#_another_client_against_the_amazon_e_commerce_service">1.5. Another Client against the Amazon E-Commerce Service</a></span></dt><dt><span class="section"><a href="#_the_cta_bus_tracker_services">1.6. The CTA Bus Tracker Services</a></span></dt><dt><span class="section"><a href="#_restful_clients_and_wadl_documents">1.7. RESTful Clients and WADL Documents</a></span></dt><dt><span class="section"><a href="#_the_jax_rs_client_api">1.8. The JAX-RS Client API</a></span></dt><dt><span class="section"><a href="#_json_for_javascript_clients">1.9. JSON for JavaScript Clients</a></span></dt><dt><span class="section"><a href="#_what_8217_s_next">1.10. What’s Next?</a></span></dt></dl></dd></dl></div><div class="section" title="1. RESTful Web Services: The Client Side"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="jwsur_3_chapter_3"></a>1. RESTful Web Services: The Client Side</h2></div></div></div><div class="section" title="1.1. The Challenges on the Client Side"><div class="titlepage"><div><div><h3 class="title"><a id="_the_challenges_on_the_client_side"></a>1.1. The Challenges on the Client Side</h3></div></div></div><p>Consider a familiar scenario in which a client accesses a RESTful web service:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The client issues a GET request against a RESTful service. In general, a request to a RESTful service
targets a  named resource, with a URI as the name.
</li><li class="listitem">
If successful, this GET request results in a response document, a representation of the resource targeted in
the request. The document is usually in XML or JSON, although other formats might be available. In any case, the
response should be MIME-typed.
</li><li class="listitem">
The client extracts from the document whatever information is required for the client’s application logic.
</li></ul></div><p>For example, the client might be a jQuery script embedded in an HTML document. This client requests data, such
as a product list, from a web service.
If the request succeeds, the client extracts relevant information; for instance, the client might extract the
name, category, price, and in-stock quantity of each product in the list. The client then processes the
information is some appropriate way; for instance, the JavaScript client might build and display an HTML table that represents
the product list, with one row per product.</p><p>Each step in this sample scenario poses a challenge. The GET request must be formatted properly and the
status code of the response should be inspected to determine whether the request succeeded and, if not, why not.
The toughest challenge for the client, however, may be extracting required information from the document: the client may have to
parse the returned document to get the information in a usable format. To build an HTML table from an XML document, for
example, a JavaScript client would need to extract information items as text <span class="emphasis"><em>without</em></span> the XML markup; and an XML parse
would be the standard way to extract such information. It would be easier on the JavaScript client received a JSON payload
so that the
XML parse could be avoided altogether. The <code class="literal">@WebServiceProvider</code> service in Chapter
2 illustrates the problem of parsing XML because successful POST and PUT operations against this service must send, as an
XML document, the data required to construct or edit an <code class="literal">Adage</code>; and the service code parses the document to extract the
<code class="literal">words</code> that make up the <code class="literal">Adage</code>. A dominant theme in this chapter is how to avoid the explicit parsing of documents, XML or
JSON,  returned from RESTful services.</p><p>All of the CRUD verbs used in RESTful services pose challenges, although these differ in degree, for both the service and the client.
This chapter focuses on the the client side and pays particular attention to the challenge of extracting
usable information from an HTTP response whose payload is an XML or JSON document. Some examples parse documents to
extract such information and other examples show how explicit parsing can be avoided. Java has various libraries,
standard and contributed, for dealing with XML and JSON documents; and the examples illustrate such libraries.</p><p>Web services in general purport to be language neutral. Accordingly, the proof of
the pudding is whether a client written in one language can consume, without undue fuss, a service written in a different
language. My first example illustrates how this can be done with a Perl client against a Java RESTful service. Most of
the other examples focus on Java clients against various services, including two Java clients against Amazon’s RESTful
E-Commerce service. The E-Commerce examples highlight the complexities encountered in targeting real-world
services.</p></div><div class="section" title="1.2. A Perl Client against a Java RESTful Web Service"><div class="titlepage"><div><div><h3 class="title"><a id="_a_perl_client_against_a_java_restful_web_service"></a>1.2. A Perl Client against a Java RESTful Web Service</h3></div></div></div><p>The Perl client (see <a class="xref" href="#Ex1" title="Example 1. A Perl client making CRUD calls against the RESTful predictions2 service.">Example 1, “A Perl client making CRUD calls against the RESTful <span class="emphasis"><em>predictions2</em></span> service.”</a>) against the Java <span class="emphasis"><em>predictions2</em></span> RESTful service, implemented as an <code class="literal">HttpServlet</code>, makes
various calls that cover the CRUD operations. (The <span class="emphasis"><em>predictions2</em></span> service is from Chapter 2.)
Perl comes with most Unixy systems and is available on Windows (see, for
example, <span class="emphasis"><em>www.activestate.com</em></span>). Although Perl has a quirky syntax—it has been called <span class="emphasis"><em>line-noise interpreted</em></span> and even worse—its
excellent libraries, standard and
contributed, more than compensate. In any case, the point of the example is to provide a first look
at how a client interacts with a RESTful service. The <span class="emphasis"><em>curl</em></span> clients from the two previous chapters illustrated all of the
CRUD operations against several services; and all of the CRUD requests received at least a minimal document in return. Yet the
<span class="emphasis"><em>curl</em></span> utility is meant for making HTTP requests, not processing HTTP responses.
The Perl client takes the second step; that is, this client performs all of the CRUD operations and then highlights the challenge of
processing response documents. In the case of response documents in XML, the Perl client parses the XML to extract usable
information, in this case the <code class="literal">id</code>, <code class="literal">who</code>, and <code class="literal">what</code> of a specified <code class="literal">Prediction</code> or of the entire <code class="literal">PredictionsList</code> returned from
the service.</p><div class="example"><a id="Ex1"></a><p class="title"><b>Example 1. A Perl client making CRUD calls against the RESTful <span class="emphasis"><em>predictions2</em></span> service.</b></p><div class="example-contents"><pre class="screen">#!/usr/bin/perl -w

# packages
use strict;
use LWP;
use XML::XPath;
use List::MoreUtils qw(each_array);

my $baseUrl = 'http://localhost:8080/predictions2/';
my $ua = LWP::UserAgent-&gt;new;
runTests();

## Run CRUD tests against the service.
sub runTests {
    getTest($baseUrl);               ## GET all (xml)
    getTest($baseUrl . '?id=4');     ## GET one (xml)
    getTestJson($baseUrl);           ## GET all (json)
    getTestJson($baseUrl . '?id=4'); ## GET one (json)
    postTest($baseUrl);              ## POST
    getTest($baseUrl);               ## GET all (xml)
    putTest($baseUrl);               ## PUT
    getTest($baseUrl . '?id=4');     ## GET one (xml)
    deleteTest($baseUrl . '?id=31'); ## DELETE
    getTest($baseUrl);               ## GET one (xml)
}
sub getTest {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(GET =&gt; $url);
    my $response = $ua-&gt;request($request);
    handleResponse($response, \&amp;parseXml); # pointer to a function
}
sub getTestJson {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(GET =&gt; $url,
                                     HTTP::Headers-&gt;new('Accept' =&gt; 'application/json'));
    my $response = $ua-&gt;request($request);
    handleResponse($response, \&amp;parseJson);
}
sub postTest {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(POST =&gt; $url);
    $request-&gt;content_type('application/x-www-form-urlencoded');
    $request-&gt;content('who=TS Eliot&amp;what=This is the way the world ends.');
    my $response = $ua-&gt;request($request);
    handleResponse($response, undef);
}
sub putTest {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(PUT =&gt; $url);
    $request-&gt;content_type('application/x-www-form-urlencoded');
    $request-&gt;content('id=4#who=FOOBAR');
    my $response = $ua-&gt;request($request);
    handleResponse($response, undef);
}
sub deleteTest {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(DELETE =&gt; $url);
    my $response = $ua-&gt;request($request);
    handleResponse($response, undef);
}
sub parseXml {
    my ($rawXml) = @_;
    # print "Raw XML resonse:\n" . $rawXml . "\n";
    # Set up the XPath search.
    my $xp = XML::XPath-&gt;new(xml =&gt; trim($rawXml));
    # Extract a list apiece of ids, whos, and whats.
    my @ids = $xp-&gt;find('//object/void[@property="id"]/int')-&gt;get_nodelist;
    my @whos = $xp-&gt;find('//object/void[@property="who"]/string')-&gt;get_nodelist;
    my @whats = $xp-&gt;find('//object/void[@property="what"]/string')-&gt;get_nodelist;
    # Iterate over the lists to print the data.
    my $it = each_array(@ids, @whos, @whats);
    while (my ($id, $who, $what) = $it-&gt;()) {
        print sprintf("%2d: ", $id-&gt;string_value) .
            $who-&gt;string_value . " -&gt; '" .
            $what-&gt;string_value . "'\n";
    }
}
sub parseJson {
    my ($json) = @_;
    print "JSON document:\n$json\n";
    # ...
}
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
sub handleResponse {
    my ($response, $callback) = @_;
    if ($response-&gt;is_success) {
        if (defined $callback) {
            $callback-&gt;($response-&gt;content);
        }
        else {
            print $response-&gt;content . "\n";
        }
    }
    else {
        print STDERR $response-&gt;status_line . "\n";
    }
}</pre></div></div><br class="example-break" /><p>The Perl client can make a GET request for all predictions or just a specified one; and the client can
express a preference for XML or JSON in either case. Here is the function <code class="literal">getTest</code>, which requests
all predictions in XML:</p><pre class="screen">sub getTest {
    my ($url) = @_;                                <a id="CO1-1"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    print "\nGET request against $url\n\n";
    my $request = HTTP::Request-&gt;new(GET =&gt; $url); <a id="CO1-2"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    my $response = $ua-&gt;request($request);         <a id="CO1-3"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
    handleResponse($response, \&amp;parseXml);         <a id="CO1-4"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
}</pre><p>In line 1 the <code class="literal">$url</code> variable (in Perl, a scalar variable starts with a <code class="literal">$</code>) has, as its value, a string URL that
targets the <span class="emphasis"><em>predictions2</em></span> service, whose
GET operation is the <code class="literal">doGet</code> method in the <code class="literal">HttpServlet</code>. The Perl client generates, in line 2, a request object (the reference
is <code class="literal">$request</code>) and then issues this request through a <code class="literal">LWP::UserAgent</code> instance, with <code class="literal">$ua</code> as the
reference (line 3). The client then invokes, in line 4, the function named <code class="literal">handleResponse</code> with two arguments: the <code class="literal">$response</code>
reference, which gives access to the entire HTTP response, including the status code, the headers, and the
body; and a reference to a response-processing function, in this case <code class="literal">parseXml</code>, which parses the returned XML if
the request succeeds.</p><p>The function <code class="literal">parseXml</code> illustrates the challenge of extracting usable information from the XML payload.
Perl, like most general-purpose languages, has various ways to parse XML. In this example, the Perl <code class="literal">XPath</code> library is
used. Here is the parsing function without the comments:</p><pre class="screen">sub parseXml {
  my ($rawXml) = @_;
  print "Raw XML resonse:\n" . $rawXml . "\n"; # raw xml                         <a id="CO1-5"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
  my $xp = XML::XPath-&gt;new(xml =&gt; trim($rawXml));                                <a id="CO1-6"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
  my @ids = $xp-&gt;find('//object/void[@property="id"]/int')-&gt;get_nodelist;        <a id="CO1-7"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
  my @whos = $xp-&gt;find('//object/void[@property="who"]/string')-&gt;get_nodelist;   <a id="CO1-8"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
  my @whats = $xp-&gt;find('//object/void[@property="what"]/string')-&gt;get_nodelist; <a id="CO1-9"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
  my $it = each_array(@ids, @whos, @whats);
  while (my ($id, $who, $what) = $it-&gt;()) {
    print sprintf("%2d: ", $id-&gt;string_value) . $who-&gt;string_value . " -&gt; '" .
              $what-&gt;string_value . "'\n";
  }
}</pre><p>The function prints the raw XML from the <span class="emphasis"><em>predictions2</em></span> service (line 1) and then uses <code class="literal">XPath</code> (line 2) to
get three lists: <code class="literal">@ids</code>, <code class="literal">@whos</code>, and <code class="literal">@whats</code> (lines 3, 4, and 5). (Perl lists begin with <code class="literal">@</code>.) The
<code class="literal">while</code> loop then prints the text representation of each <code class="literal">Prediction</code>, giving the values of its
<code class="literal">id</code>, <code class="literal">who</code>, and <code class="literal">what</code> properties. Here is a slice of the output:</p><pre class="screen"> 1: Cornelius Tillman -&gt;
    'Managed holistic contingency will grow killer action-items.'
 2: Conner Kulas -&gt;
    'Vision-oriented zero administration time-frame will generate back-end interfaces.'
...
23: Lottie Marks -&gt;
    'Open-source multi-tasking time-frame will monetize rich partnerships.'</pre><p>In a production example, the application logic might be considerably more complicated than simply
printing the extracted information. The extracted <code class="literal">Prediction</code> instances might be inserted into
a database, mined for relevant patterns, integrated with other information, sent out as email
greetings, and so on. Nonetheless,
the XML parsing would be the first step in support of any such additional processing.</p><p>The other requests from the Perl client are very similar to the <span class="emphasis"><em>curl</em></span> commands used in Chapter 1 and
Chapter 2. For example, the <span class="emphasis"><em>predictions2</em></span> service returns JSON rather than XML on a GET request if
the appropriate header element is in the HTTP message. The Perl client inserts the <code class="literal">Accept</code> key/value
pair, issues the request, and then parses the returned JSON (line 1):</p><pre class="screen">my $request = HTTP::Request-&gt;new(GET =&gt; $url,
                         HTTP::Headers-&gt;new('Accept' =&gt; 'application/json')); <a id="CO1-10"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
my $response = $ua-&gt;request($request);
handleResponse($response, \&amp;parseJson);</pre><p>A POST or a PUT request requires that relevant data about a <code class="literal">Prediction</code> be inserted into the
body of the HTTP request. Here is the POST test:</p><pre class="screen">sub postTest {
    my ($url) = @_;
    my $request = HTTP::Request-&gt;new(POST =&gt; $url);
    $request-&gt;content_type('application/x-www-form-urlencoded');            <a id="CO1-11"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    $request-&gt;content('who=TS Eliot&amp;what=This is the way the world ends.'); <a id="CO1-12"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    my $response = $ua-&gt;request($request);                                  <a id="CO1-13"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
    handleResponse($response, undef); # undef means no callback function    <a id="CO1-14"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
}</pre><p>Line 1 sets the content type of the HTTP request for <code class="literal">x-www-form-urlencoded</code>, the standard type
for the body of a POST request; this type is commonly abbreviated as the <span class="emphasis"><em>HTTP form</em></span>. The form holds
two key/value pairs, one for the <code class="literal">who</code> and the other
for the <code class="literal">what</code> property of a <code class="literal">Prediction</code> (line 2). Line 3 sends the request and awaits the response. In line 4,
the call to <code class="literal">handleResponse</code>, the Perl value <code class="literal">undef</code> (short for <span class="emphasis"><em>undefined</em></span>) serves roughly the same purpose
as <code class="literal">null</code> in Java. In the call to <code class="literal">handleResponse</code>, a second argument with <code class="literal">undef</code> as its value signals that the
HTTP response should be
printed rather than processed further; for example, on a successful POST the printed response would be similar to:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.7.0" class="java.beans.XMLDecoder"&gt;
  &lt;string&gt;Prediction 36 created.&lt;/string&gt;
&lt;/java&gt;</pre><p>The Perl example illustrates language neutrality in RESTful web services because the <span class="emphasis"><em>predictions2</em></span> service is
written in Java. At the same time, this example
focuses on a central question in this chapter: How can a RESTful client minimize or even
avoid XML/JSON parsing? Even the relatively short Perl client makes clear that the tricky code involves XML
parsing, although the Perl <code class="literal">XPath</code> library has an API that eases the task.
The next section addresses the issue of response-document parsing with two examples, each a Java client against the Amazon E-Commerce service.
The first client contends with the XML that the Amazon service returns, whereas the second client uses JAX-B to transform the XML into
native Java objects, which are then manipulated with the familiar <span class="emphasis"><em>get/set</em></span> methods.</p></div><div class="section" title="1.3. A Client against the Amazon E-Commerce Service"><div class="titlepage"><div><div><h3 class="title"><a id="_a_client_against_the_amazon_e_commerce_service"></a>1.3. A Client against the Amazon E-Commerce Service</h3></div></div></div><p>Amazon Web Services (AWS at <span class="emphasis"><em>aws.amazon.com</em></span>) is an umbrella for Amazon’s pioneering contributions, in infrastructure
and applications, to web services. From early on, Amazon has pushed hard to make its web sites for shopping, storage (S3, Simple Storage Service),
utility-priced cloud computing (EC2), and so on available as web services, too. Among the prominent hosts of web services, Amazon is
unusual in offering both SOAP-based and REST-style versions of such services. This chapter and later ones have code examples that
involve Amazon’s E-Commerce or shopping service (see <a class="xref" href="#register_amazon" title="Registering with Amazon">Registering with Amazon</a>), which requires an <span class="emphasis"><em>accessId</em></span> and a <span class="emphasis"><em>secretKey</em></span> for access.
The <span class="emphasis"><em>accessId</em></span> is inserted, as is, into any request against the E-Commerce service; and the <span class="emphasis"><em>secretKey</em></span> is
used to create what Amazon calls a <span class="emphasis"><em>signature</em></span>, which is likewise inserted into every request and then verified on the
Amazon side. The <span class="emphasis"><em>secretKey</em></span> itself is not inserted into a request.</p><div class="sidebar" title="Registering with Amazon"><a id="register_amazon"></a><p class="title"><b>Registering with Amazon</b></p><p>Amazon’s E-Commerce web service is free of charge but requires registration (<span class="emphasis"><em>affiliate-program.amazon.com</em></span>).
In particular, a web service client requires both
an <span class="emphasis"><em>access key id</em></span> (<span class="emphasis"><em>accessId</em></span> for short) and a <span class="emphasis"><em>secret access key</em></span> (<span class="emphasis"><em>secretKey</em></span> for short), each of which comes from Amazon
after registration. The sample clients against the E-Commerce service, in this and later chapters, require the
<span class="emphasis"><em>accessId</em></span> and the <span class="emphasis"><em>secretKey</em></span> as command-line arguments.</p></div><p>The <code class="literal">RestfulAmazon</code> client (see <a class="xref" href="#Ex2" title="Example 2. The RestfulAmazon client against the Amazon E-Commerce web service.">Example 2, “The <code class="literal">RestfulAmazon</code> client against the Amazon E-Commerce web service.”</a>) is relatively clean code but only because the messy details are isolated in the
utility class <code class="literal">RequestHelper</code>. Amazon requires, in a RESTful request for item lookups against the E-Commerce service, that
the verb be GET and that the required data be in a strictly formatted query string. Here are some details:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The keys in the query string must be in lexicographical order with respect to the first byte in the key’s name.
</li><li class="listitem">
The query string must include a ISO-8601 timestamp.
</li><li class="listitem">
The query string must be URL-encoded under RFC 3986.
</li><li class="listitem">
The query string must include a <span class="emphasis"><em>hash-based message authentication code</em></span> using the SHA-256 hash algorithm. This hash value
is what Amazon calls the <span class="emphasis"><em>signature</em></span>.
</li><li class="listitem">
The authentication code must be base64 encoded.
</li></ul></div><p>Amazon’s RESTful service is fussy about the format of requests against it. The utility class <code class="literal">RequestHelper</code> ensures that
a GET request against the E-Commerce service has the required query-string format.</p><div class="example"><a id="Ex2"></a><p class="title"><b>Example 2. The <code class="literal">RestfulAmazon</code> client against the Amazon E-Commerce web service.</b></p><div class="example-contents"><pre class="screen">package restful;

import java.net.URL;
import java.net.URLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.ByteArrayInputStream;
import java.util.HashMap;
import java.util.Map;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class RestfulAmazon {
    private static final String endpoint = "ecs.amazonaws.com";
    private static final String itemId = "0545010225"; // Harry Potter        <a id="CO1-15"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />

    public static void main(String[ ] args) {
        if (args.length &lt; 2) {
            System.err.println("RestfulAmazon &lt;accessKeyId&gt; &lt;secretKey&gt;");
            return;
        }
        new RestfulAmazon().lookupStuff(args[0].trim(), args[1].trim());
    }
    private void lookupStuff(String accessKeyId, String secretKey) {
        RequestHelper helper = new RequestHelper(endpoint, accessKeyId, secretKey);
        String requestUrl = null;
        String title = null;
        // Store query string params in a hash.
        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
        params.put("Service", "AWSECommerceService");
        params.put("Version", "2009-03-31");
        params.put("Operation", "ItemLookup");                                <a id="CO1-16"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        params.put("ItemId", itemId);
        params.put("ResponseGroup", "Small");
        params.put("AssociateTag", "kalin");  // any string should do
        requestUrl = helper.sign(params);
        String response = requestAmazon(requestUrl);
        // The string "null" is returned before the XML document.
        String noNullResponse = response.replaceFirst("null", "");
        System.out.println("Raw xml:\n" + noNullResponse);
        System.out.println("Author: " + getAuthor(noNullResponse));
    }
    private String requestAmazon(String stringUrl) {
        String response = null;
        try {
            URL url = new URL(stringUrl);
            URLConnection conn = url.openConnection();
            conn.setDoInput(true);
            BufferedReader in =
                new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String chunk = null;
            while ((chunk = in.readLine()) != null) response += chunk;
            in.close();
        }
        catch(Exception e) { throw new RuntimeException("Arrrg! " + e); }
        return response;
    }
    private String getAuthor(String xml) {
        String author = null;
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());
            DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
            fact.setNamespaceAware(true);
            DocumentBuilder builder = fact.newDocumentBuilder();
            Document doc = builder.parse(bais);
            NodeList results = doc.getElementsByTagName("Author");
            for (int i = 0; i &lt; results.getLength(); i++) {
                Element e = (Element) results.item(i);
                NodeList nodes = e.getChildNodes();
                for (int j = 0; j &lt; nodes.getLength(); j++) {
                    Node child = nodes.item(j);
                    if (child.getNodeType() == Node.TEXT_NODE)
                        author = child.getNodeValue();
                }
            }
        }
        catch(Exception e) { throw new RuntimeException("Xml bad!", e); }
        return author;
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">RestfulAmazon</code> application expects two command-line arguments, an Amazon <span class="emphasis"><em>accessId</em></span> and
<span class="emphasis"><em>secretKey</em></span> in that order. The client application then sets various properties such as the
requested Amazon operation (in this example, <code class="literal">ItemLookup</code> of line 2), the item’s identifier (in this
example, <code class="literal">0545010225</code> in line 1, which is a Harry Potter novel), the Amazon associate’s name, and so on.
After the <code class="literal">RequestHelper</code> utility formats the request according to Amazon’s requirements, the
<code class="literal">RestfulAmazon</code> client then opens a <code class="literal">URLConnection</code> to the Amazon service, sends the GET request,
and then reads the response,
chunk by chunk. The relevant code segment is:</p><pre class="screen">URL url = new URL(stringUrl);
URLConnection conn = url.openConnection();                            <a id="CO1-17"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
conn.setDoInput(true);
BufferedReader in =                                                   <a id="CO1-18"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
  new BufferedReader(new InputStreamReader(conn.getInputStream()));
String chunk = null;
while ((chunk = in.readLine()) != null) response += chunk;            <a id="CO1-19"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" /></pre><p>The code first creates a <code class="literal">URLConnection</code> (line 1) and then wraps a
<code class="literal">BufferedReader</code> around the connection’s <code class="literal">InputStream</code> (line 2). A <code class="literal">while</code> loop
is used to read the Amazon response chunk by chunk (line 3).
On a successful GET request, the payload in HTTP response body is an XML document. Here is
a slice from a sample run:</p><pre class="screen">&lt;?xml version="1.0" ?&gt;
&lt;ItemLookupResponse
   xmlns="http://webservices.amazon.com/AWSECommerceService/2011-08-01"&gt;
  &lt;OperationRequest&gt;
    &lt;HTTPHeaders&gt;
      &lt;Header Name="UserAgent" Value="Java/1.7"&gt;&lt;/Header&gt;
    &lt;/HTTPHeaders&gt;
    &lt;RequestId&gt;591ac8db-0435-4c53-9b01-e3756ea9c55d&lt;/RequestId&gt;
    &lt;Arguments&gt;
      &lt;Argument Name="Operation" Value="ItemLookup"&gt;&lt;/Argument&gt;
      &lt;Argument Name="Service" Value="AWSECommerceService"&gt;&lt;/Argument&gt;
      ...
      &lt;Argument Name="ResponseGroup" Value="Small"&gt;&lt;/Argument&gt;
    &lt;/Arguments&gt;
    &lt;RequestProcessingTime&gt;0.0083090000000000&lt;/RequestProcessingTime&gt;
  &lt;/OperationRequest&gt;
  &lt;Item&gt;
    &lt;Request&gt;
      &lt;IsValid&gt;True&lt;/IsValid&gt;
      &lt;ItemLookupRequest&gt;
        &lt;IdType&gt;ASIN&lt;/IdType&gt;
        &lt;ItemId&gt;0545010225&lt;/ItemId&gt;
        ...
      &lt;/ItemLookupRequest&gt;
    &lt;/Request&gt;
    &lt;Item&gt;
      &lt;ASIN&gt;0545010225&lt;/ASIN&gt;
      &lt;DetailPageURL&gt;
        http://www.amazon.com/Harry-Potter-Deathly-Hallows-Book...
      &lt;/DetailPageURL&gt;
      &lt;ItemLinks&gt;
        &lt;ItemLink&gt;
          &lt;Description&gt;Technical Details&lt;/Description&gt;
          &lt;URL&gt;http://www.amazon.com/Harry-Potter-Deathly-Hallows-Book...&lt;/URL&gt;
        &lt;/ItemLink&gt;
        ...
        &lt;ItemLink&gt;
          &lt;Description&gt;Add To Wedding Registry&lt;/Description&gt;                    <a id="CO1-20"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
          &lt;URL&gt;http://www.amazon.com/gp/registry/wedding/add-item.html...&lt;/URL&gt;
        &lt;/ItemLink&gt;
        ...
      &lt;/ItemLinks&gt;
      &lt;ItemAttributes&gt;
        &lt;Author&gt;J. K. Rowling&lt;/Author&gt;
        &lt;Creator Role="Illustrator"&gt;Mary GrandPré&lt;/Creator&gt;
        &lt;Manufacturer&gt;Arthur A. Levine Books&lt;/Manufacturer&gt;
        &lt;ProductGroup&gt;Book&lt;/ProductGroup&gt;
        &lt;Title&gt;Harry Potter and the Deathly Hallows (Book 7)&lt;/Title&gt;
      &lt;/ItemAttributes&gt;
    &lt;/Item&gt;
  &lt;/Items&gt;
&lt;/ItemLookupResponse&gt;</pre><p>Even a cursory look at the XMl makes clear, to anyone who has searched on the Amazon web site, that
the web service response contains essentially the same information as the corresponding HTML page viewed
in a browser visit. For example, there is an XML element labeled</p><pre class="screen">Add To Wedding Registry (line 1)</pre><p>Amazon’s goal is to make the web site and the web service deliver
the same information and the same functionality but in different format: the web site delivers
HTML documents, whereas the web service delivers XML documents.</p><p>With the response XML in hand, the <code class="literal">RestfulAmazon</code> client then parses the document to extract, as
proof of concept, the author’s name, J. K. Rowling. The code uses the relatively old-fashioned
DOM (Document Object Model) parser, implemented as the standard Java <code class="literal">DocumentBuilder</code> class.
Here is the relevant code segment:</p><pre class="screen">Document doc = builder.parse(bais);                        <a id="CO1-21"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
NodeList results = doc.getElementsByTagName("Author");     <a id="CO1-22"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
for (int i = 0; i &lt; results.getLength(); i++) {
   Element e = (Element) results.item(i);
   NodeList nodes = e.getChildNodes();
      for (int j = 0; j &lt; nodes.getLength(); j++) {
         Node child = nodes.item(j);
         if (child.getNodeType() == Node.TEXT_NODE)        <a id="CO1-23"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
           author = child.getNodeValue();
      }
}</pre><p>The code first builds the DOM tree structure from the Amazon response bytes (line 1) and
then gets a list, in this case a list of one element, from DOM elements tagged as <code class="literal">Author</code>.
The author’s name, J. K. Rowling, occurs as the contents of a <code class="literal">TEXT_NODE</code> (line 3). The
parse deals with the usual complexities of the tree structure that a DOM represents.
Similar DOM searches could extract from Amazon’s XML response document any other information of interest,
for example, the book’s ISBN number.</p><div class="example"><a id="Ex3"></a><p class="title"><b>Example 3. The utility class <code class="literal">RequestHelper</code>, which supports the <code class="literal">RestfulAmazon</code> class.</b></p><div class="example-contents"><pre class="screen">package restful;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.TimeZone;
import java.util.TreeMap;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class RequestHelper {
    private static final String utf8 = "UTF-8";
    private static final String hmacAlg = "HmacSHA256";
    private static final String requestUri = "/onca/xml";
    private static final String requestMethod = "GET";
    private String endpoint = null;
    private String accessKeyId = null;
    private String secretKey = null;
    private SecretKeySpec secretKeySpec = null;
    private Mac mac = null;

    public RequestHelper(String endpoint,
                         String accessKeyId,
                         String secretKey) {
        if (endpoint == null || endpoint.length() == 0)
            throw new RuntimeException("The endpoint is null or empty.");
        if (null == accessKeyId || accessKeyId.length() == 0)
            throw new RuntimeException("The accessKeyId is null or empty.");
        if (null == secretKey || secretKey.length() == 0)
            throw new RuntimeException("The secretKey is null or empty.");
        this.endpoint = endpoint.toLowerCase();
        this.accessKeyId = accessKeyId;
        this.secretKey = secretKey;
        try {                                                                    <a id="CO1-24"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            byte[ ] secretKeyBytes = this.secretKey.getBytes(utf8);
            this.secretKeySpec = new SecretKeySpec(secretKeyBytes, hmacAlg);
            this.mac = Mac.getInstance(hmacAlg);
            this.mac.init(this.secretKeySpec);
        }
        catch(Exception e) { throw new RuntimeException(e); }
    }
    public String sign(Map&lt;String, String&gt; params) {
        params.put("AWSAccessKeyId", this.accessKeyId);                          <a id="CO1-25"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        params.put("Timestamp", this.timestamp());                               <a id="CO1-26"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        // The parameters need to be processed in lexicographical order, with
        // sorting on the first byte: a TreeMap is perfect for this.
        SortedMap&lt;String, String&gt; sortedParamMap =                               <a id="CO1-27"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
           new TreeMap&lt;String, String&gt;(params);
        // Ensure canonical form of the query string, as Amazon REST is fussy.
        String canonicalQS = this.canonicalize(sortedParamMap);                  <a id="CO1-28"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        // Prepare the signature with grist for the mill.
        String toSign =
            requestMethod + "\n"
            + this.endpoint + "\n"
            + requestUri + "\n"
            + canonicalQS;
        String hmac = this.hmac(toSign);
        String sig = null;
        try {
            sig = URLEncoder.encode(hmac, utf8);
        }
        catch(UnsupportedEncodingException e) { System.err.println(e); }
        String url =                                                             <a id="CO1-29"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            "http://" + this.endpoint + requestUri + "?" + canonicalQS +
            "&amp;Signature=" + sig;
        return url;
    }
    public String sign(String queryString) {
        Map&lt;String, String&gt; params = this.createParameterMap(queryString);
        return this.sign(params);
    }
    private String hmac(String stringToSign) {
        String signature = null;
        byte[ ] data;
        byte[ ] rawHmac;
        try {
            data = stringToSign.getBytes(utf8);
            rawHmac = mac.doFinal(data);
            Base64 encoder = new Base64();                                               <a id="CO1-30"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
            signature = new String(encoder.encode(rawHmac));
        }
        catch (UnsupportedEncodingException e) {
            throw new RuntimeException(utf8 + " is unsupported!", e);
        }
        return signature;
    }
    // Amazon requires an ISO-8601 timestamp.
    private String timestamp() {
        String timestamp = null;
        Calendar cal = Calendar.getInstance();
        DateFormat dfm = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
        dfm.setTimeZone(TimeZone.getTimeZone("GMT"));
        timestamp = dfm.format(cal.getTime());
        return timestamp;
    }
    private String canonicalize(SortedMap&lt;String, String&gt; sortedParamMap) {
        if (sortedParamMap.isEmpty()) return "";
        StringBuffer buffer = new StringBuffer();
        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = sortedParamMap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry&lt;String, String&gt; kvpair = iter.next();
            buffer.append(encodeRfc3986(kvpair.getKey()));
            buffer.append("=");
            buffer.append(encodeRfc3986(kvpair.getValue()));
            if (iter.hasNext()) buffer.append("&amp;");
        }
        return buffer.toString();
    }
    // Amazon requires RFC 3986 encoding, which the URLEncoder may not get right.
    private String encodeRfc3986(String s) {
        String out;
        try {
            out = URLEncoder.encode(s, utf8)
                .replace("+", "%20")
                .replace("*", "%2A")
                .replace("%7E", "~");
        }
        catch (UnsupportedEncodingException e) { out = s; }
        return out;
    }
    private Map&lt;String, String&gt; createParameterMap(String queryString) {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        String[ ] pairs = queryString.split("&amp;");
        for (String pair : pairs) {
            if (pair.length() &lt; 1) continue;
            String[ ] tokens = pair.split("=", 2);
            for(int j = 0; j &lt; tokens.length; j++) {
                try {
                    tokens[j] = URLDecoder.decode(tokens[j], utf8);
                }
                catch (UnsupportedEncodingException e) { }
            }
            switch (tokens.length) {
                case 1: {
                    if (pair.charAt(0) == '=') map.put("", tokens[0]);
                    else map.put(tokens[0], "");
                    break;
                }
                case 2: {
                    map.put(tokens[0], tokens[1]);
                    break;
                }
            }
        }
        return map;
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">RequestHelper</code> class (see <a class="xref" href="#Ex3" title="Example 3. The utility class RequestHelper, which supports the RestfulAmazon class.">Example 3, “The utility class <code class="literal">RequestHelper</code>, which supports the <code class="literal">RestfulAmazon</code> class.”</a>) has one job: to format the HTTP GET request in accordance with Amazon’s
strict requirements. This class acts as a utility that hides many low-level details but a quick
overview should provide some insight in what the E-Commerce service requires in a well-formed request.
Recall a request against the E-Commerce service requires both an <span class="emphasis"><em>accessId</em></span> and a <span class="emphasis"><em>secretKey</em></span> but
the two play quite different roles in the request. The <span class="emphasis"><em>accessId</em></span> occurs as a value in a key/value pair, with
<code class="literal">AWSAccessKeyId</code> as the key (line 2). There is also a key/value pair for the timestamp that the E-Commerce
service requires (line 3); hence, the <span class="emphasis"><em>accessId</em></span> and the timestamp are peers. Amazon uses the timestamp to
ensure that the requests are timely, that is, recently constructed.</p><p>The <span class="emphasis"><em>secretKey</em></span> plays a different role than does the <span class="emphasis"><em>accessId</em></span>. The <span class="emphasis"><em>secretKey</em></span> is used to initialize a
<span class="emphasis"><em>message authentication code</em></span> (MAC), which the Java <code class="literal">javax.crypto.Mac</code> class represents. (The initialization occurs in the <code class="literal">try</code>
block that begins on line 1.)
Amazon requires a particular type of MAC, an HMAC (hash-based message authentication code) that uses the
SHA-256 algorithm (Secure Hash Algorithm that generates a 256-bit hash). The important security point is
that the <span class="emphasis"><em>secretKey</em></span> itself does not go over the wire from the client to Amazon. Instead the <span class="emphasis"><em>secretKey</em></span>
is used to initialize the process that generates a message digest (hash value). Finally, this hash value is
encoded in base64 (line 7). Amazon calls the result a <span class="emphasis"><em>signature</em></span>, which occurs as the value in a key/value pair
whose key is <code class="literal">Signature</code> (line 6).</p><p>There is a final preparatory step. The E-Commerce service expects, in a GET request, that the query-string
key/value pairs be in sorted order. The <code class="literal">RequestHelper</code> uses a <code class="literal">TreeMap</code>, as this data structure is ideally
suited for the task (line 4). The properly formatted query string results from a call to <code class="literal">canonicalize</code>; and
this query string is then appended to the base URL for the Amazon E-Commerce service.</p><p>Not every commercial site is as fussy as Amazon when it comes to request formatting. This first
Amazon example shows that generating a correctly formatted RESTful request may be non-trivial.
This client also explicitly parses the returned XML. The next client
addresses the issue of how to avoid such parsing. Before looking at the code for the second client,
however, it will be useful to focus on the JAX-B utilities used in the second client.</p></div><div class="section" title="1.4. A Standalone JAX-B Example"><div class="titlepage"><div><div><h3 class="title"><a id="_a_standalone_jax_b_example"></a>1.4. A Standalone JAX-B Example</h3></div></div></div><p>Recall that the <span class="emphasis"><em>B</em></span> in <span class="emphasis"><em>JAX-B</em></span> stands for data <span class="emphasis"><em>binding</em></span>, the associating of a Java data type such as <code class="literal">String</code> to
an XML Schema (or equivalent) type, in this case <code class="literal">xsd:string</code>. There are built-in bindings for the Java
primitive types such as <code class="literal">int</code> and <code class="literal">double</code> together with <code class="literal">String</code> and <code class="literal">Calendar</code>; arrays (including <code class="literal">Collections</code>) of any such
types; and programmer-defined types that reduce, via properties, to any of the preceding. The surprising omission is the
<code class="literal">Map</code>, a collection of key/value pairs; but a <code class="literal">Map</code> is readily handled as two coordinated collections: a collection of
<span class="emphasis"><em>keys</em></span> and a corresponding collection of <span class="emphasis"><em>values</em></span>. An example of JAX-B in action may help to drive these points
home.</p><p>The <code class="literal">Skier</code> class (see <a class="xref" href="#Ex4" title="Example 4. The annotated Skier POJO class.">Example 4, “The annotated <code class="literal">Skier</code> POJO class.”</a>) is annotated with <code class="literal">@XmlRootElement</code> to inform the JAX-B utilities that
a <code class="literal">Skier</code> instance should be
transformed into an XML document that has <code class="literal">skier</code> as its root or <span class="emphasis"><em>document</em></span>
(that is, outermost) element. In the default Java naming convention, the
root element is the lowercase version of the class name; hence, <code class="literal">Skier</code>
becomes <code class="literal">skier</code>. The annotation could be amended</p><pre class="screen">@XmlRootElement(name = "NordicSkier")</pre><p>so that the root element has a specified name, in this example <code class="literal">NordicSkier</code>.</p><div class="example"><a id="Ex4"></a><p class="title"><b>Example 4. The annotated <code class="literal">Skier</code> POJO class.</b></p><div class="example-contents"><pre class="screen">import javax.xml.bind.annotation.XmlRootElement;
import java.util.Collection;

@XmlRootElement
public class Skier  {
    private Person person;
    private String nationalTeam;
    private Collection majorAchievements;
    public Skier() { } // required for unmarshaling
    public Skier (Person person,
                  String nationalTeam,
                  Collection&lt;String&gt; majorAchievements) {
        setPerson(person);
        setNationalTeam(nationalTeam);
        setMajorAchievements(majorAchievements);
    }
    // properties
    public Person getPerson() { return this.person; }
    public void setPerson (Person person) { this.person = person; }

    public String getNationalTeam() { return this.nationalTeam; }
    public void setNationalTeam(String nationalTeam) {
        this.nationalTeam = nationalTeam;
    }
    public Collection getMajorAchievements() { return this.majorAchievements; }
    public void setMajorAchievements(Collection majorAchievements) {
        this.majorAchievements = majorAchievements;
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">Skier</code> class has a property of programmer-defined type <code class="literal">Person</code> (see <a class="xref" href="#Ex5" title="Example 5. The annotated Person POJO class with three properties.">Example 5, “The annotated <code class="literal">Person</code> POJO class with three properties.”</a>), which
in turn is a POJO class with three properties: <code class="literal">name</code>, <code class="literal">age</code>, and <code class="literal">gender</code>.
Two of <code class="literal">Person</code> properties are of Java type <code class="literal">String</code>, which binds to
XML type <code class="literal">xsd:string</code>. The third <code class="literal">Person</code> property is of Java type
<code class="literal">int</code>, which binds to the XML type <code class="literal">xsd:int</code>.</p><div class="example"><a id="Ex5"></a><p class="title"><b>Example 5. The annotated <code class="literal">Person</code> POJO class with three properties.</b></p><div class="example-contents"><pre class="screen">import javax.xml.bind.annotation.XmlType;

@XmlType
public class Person  {
    private String name;
    private int    age;
    private String gender;

    public Person() { }
    public Person(String name, int age, String gender){
        setName(name);
        setAge(age);
        setGender(gender);
    }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age;  }
    public void setAge(int age) { this.age = age; }
    public String getGender() { return gender; }
    public void setGender(String gender) { this.gender = gender; }
}</pre></div></div><br class="example-break" /><p>The annotation <code class="literal">XmlType</code> declares that a <code class="literal">Person</code> instance can be transformed into
an XML type, a type that an XML Schema specifies in detail. The upshot of the
annotated <code class="literal">Skier</code> and <code class="literal">Person</code> classes is this: an in-memory <code class="literal">Skier</code> object, which
encapsulates a <code class="literal">Person</code>, can be transformed into a single XML document, whose
root element is tagged <code class="literal">skier</code>; and the <code class="literal">skier</code> document encapsulates a <code class="literal">person</code> element.</p><p>The application class <code class="literal">Marshal</code> (see <a class="xref" href="#Ex6" title="Example 6. The Marshal application that marshals and unmarshals a Skier.">Example 6, “The <code class="literal">Marshal</code> application that marshals and unmarshals a <code class="literal">Skier</code>.”</a>) does the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Creates a <code class="literal">Skier</code> instance.
</li><li class="listitem">
Marshals this instance into an XML document, which is
saved to a file and also printed to the standard output.
</li><li class="listitem">
Unmarshals the XML document in the file into a separate <code class="literal">Skier</code> instance, an
instance that effectively clones the original <code class="literal">Skier</code> instance.
</li></ul></div><p>Recall that, in this context, <span class="emphasis"><em>marshaling</em></span> is the process of serializing an in-memory object into an XML document;
and <span class="emphasis"><em>unmarshaling</em></span> is the inverse process of creating an in-memory object from an XML document.</p><div class="example"><a id="Ex6"></a><p class="title"><b>Example 6. The <code class="literal">Marshal</code> application that marshals and unmarshals a <code class="literal">Skier</code>.</b></p><div class="example-contents"><pre class="screen">import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.JAXBException;
import java.util.List;
import java.util.ArrayList;

class Marshal {
    private static final String fileName = "bd.mar";

    public static void main(String[ ] args) {
        new Marshal().runExample();
    }
    private void runExample() {
        try {
            JAXBContext ctx = JAXBContext.newInstance(Skier.class);   <a id="CO1-31"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            Marshaller m = ctx.createMarshaller();                    <a id="CO1-32"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            // Marshal a Skier object: 1st to stdout, 2nd to file
            Skier skier = createSkier();
            m.marshal(skier, System.out);
            FileOutputStream out = new FileOutputStream(fileName);
            m.marshal(skier, out);                                    <a id="CO1-33"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            out.close();
            // Unmarshal as proof of concept
            Unmarshaller u = ctx.createUnmarshaller();                <a id="CO1-34"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            Skier bdClone = (Skier) u.unmarshal(new File(fileName));
            System.out.println();
            m.marshal(bdClone, System.out);
        }
        catch(JAXBException e) { System.err.println(e); }
        catch(IOException e) { System.err.println(e); }
    }
    private Skier createSkier() {
        Person bd = new Person("Bjoern Daehlie", 49, "Male");
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add("12 Olympic Medals");
        list.add("9 World Championships");
        list.add("Winningest Winter Olympian");
        list.add("Greatest Nordic Skier");
        return new Skier(bd, "Norway", list);
    }
}</pre></div></div><br class="example-break" /><p>In the <code class="literal">Marshal</code> class, the critical step is the creation of a <code class="literal">JAXBContext</code> (line 1), in this
case a structure built from Java reflection on the type <code class="literal">Skier</code>. (The one-argument method <code class="literal">newInstance</code>
can take, as its argument, a single class or a package identifier.) The utility class <code class="literal">JAXBContext</code> then
guides the marshaling and unmarshaling: the <code class="literal">Marshaller</code> and the <code class="literal">Unmarshaller</code> are created
with <code class="literal">JAXBContext</code> methods (lines 2 and 4). By the way, there is no agreement about whether
<span class="emphasis"><em>marshaling</em></span> and <span class="emphasis"><em>unmarshaling</em></span> should be spelled with one <span class="emphasis"><em>l</em></span> or two.</p><p>The marshaling (line 3) produces an XML document (see <a class="xref" href="#Ex7" title="Example 7. The XML document generated from marshaling a sample Skier.">Example 7, “The XML document generated from marshaling a sample <code class="literal">Skier</code>.”</a>) that serves as the source of the
unmarshaling (line 4). The only complexity is in the elements tagged <code class="literal">majorAchievement</code>, which include
three attributes apiece. The reason is that a <code class="literal">majorAchievement</code> is, in Java, a
<code class="literal">Collection</code> type—in particular an <code class="literal">ArrayList&lt;String&gt;</code>. The corresponding XML type is
an array of <code class="literal">xs:string</code> objects; and the <code class="literal">majorAchievement</code> elements cite the
XML Schema grammar (lines 1 and 2), which includes rules about arrays. By default, the Java
marshaling produces an XML document in which the properties of the source Java object
are in alphabetical order.</p><div class="example"><a id="Ex7"></a><p class="title"><b>Example 7. The XML document generated from marshaling a sample <code class="literal">Skier</code>.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;skier&gt;
    &lt;majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  <a id="CO1-35"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
                       xmlns:xs="http://www.w3.org/2001/XMLSchema"            <a id="CO1-36"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                       xsi:type="xs:string"&gt;12 Olympic Medals
    &lt;/majorAchievements&gt;
    &lt;majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:xs="http://www.w3.org/2001/XMLSchema"
                       xsi:type="xs:string"&gt;9 World Championships
    &lt;/majorAchievements&gt;
    &lt;majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:xs="http://www.w3.org/2001/XMLSchema"
                       xsi:type="xs:string"&gt;Winningest Winter Olympian
    &lt;/majorAchievements&gt;
    &lt;majorAchievements xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xmlns:xs="http://www.w3.org/2001/XMLSchema"
                       xsi:type="xs:string"&gt;Greatest Nordic Skier
    &lt;/majorAchievements&gt;
    &lt;nationalTeam&gt;Norway&lt;/nationalTeam&gt;
    &lt;person&gt;
        &lt;age&gt;49&lt;/age&gt;
        &lt;gender&gt;Male&lt;/gender&gt;
        &lt;name&gt;Bjoern Daehlie&lt;/name&gt;
    &lt;/person&gt;
&lt;/skier&gt;</pre></div></div><br class="example-break" /><p>This JAX-B example implies, of course, that the conversion between Java and XML could be
automated. Accordingly, a Java client against a RESTful service could:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Issue a request whose response is an XML document.
</li><li class="listitem">
Use JAX-B to unmarshal the XMl document into a Java object.
</li><li class="listitem">
Manipulate the Java object in the usual ways (for instance, with <span class="emphasis"><em>get/set</em></span> methods) to serve the
application logic.
</li></ul></div><p>In this scenario, the XML is transparent. The second Amazon example goes into the details of how this
can be done. First, however, an alternative to the standard Java XML utilities deserves a look.</p><div class="section" title="1.4.1. The XStream Option"><div class="titlepage"><div><div><h4 class="title"><a id="_the_xstream_option"></a>1.4.1. The XStream Option</h4></div></div></div><p>Java comes with standard packages for Java-to-XML conversions and XML-to-JSON conversions. There are also
various  contributed libraries, among them XStream (<span class="emphasis"><em>xstream.codehaus.org</em></span>). This section examines the
XStream option for serializing Java objects to XML/JSON documents and deserializing Java objects from
such documents. XStream includes a persistence API and has extensions in support of the Hibernate ORM (Object
Relation Mapper). Among the more interesting features of XStream is that its API does not center on the
<span class="emphasis"><em>get/set</em></span> methods that define Java properties. XStream can serialize into XML an instance of a Java class that
has nothing but <code class="literal">private</code> fields. XStream emphasizes its ease of use, which the following examples try to capture.</p><div class="example"><a id="Ex7a"></a><p class="title"><b>Example 8. An <code class="literal">XStream</code> example with a class that has no properties.</b></p><div class="example-contents"><pre class="screen">import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

public class PersonNoProps  {
    private String name;
    private int    age;
    private String gender;

    public PersonNoProps(String name, int age, String gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
}
class Main {
    public static void main(String[ ] args) {
        PersonNoProps bd = new PersonNoProps("Bjoern Daehlie", 49, "Male");
        // setup
        XStream xstream = new XStream(new DomDriver());                  <a id="CO1-37"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        xstream.alias("skier", PersonNoProps.class); // for readability  <a id="CO1-38"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        // serialize
        String xml = xstream.toXML(bd);                                  <a id="CO1-39"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        System.out.println(xml);
        // deserialize and confirm
        PersonNoProps bdClone = (PersonNoProps) xstream.fromXML(xml);    <a id="CO1-40"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        System.out.println(xstream.toXML(bdClone));
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PersonNoProps</code> class (see <a class="xref" href="#Ex7a" title="Example 8. An XStream example with a class that has no properties.">Example 8, “An <code class="literal">XStream</code> example with a class that has no properties.”</a>) illustrates the ease of <code class="literal">XStream</code> use. The class has three
<code class="literal">private</code> fields and only a three-argument constructor; of interest is that the class has
no properties, that is, no <code class="literal">public</code> <span class="emphasis"><em>get/set</em></span> methods. Nonetheless, an instance of the <code class="literal">PersonNoProps</code>
class can be serialized or deserialized straightforwardly. Line 1 in the code listing constructs an
<code class="literal">XStream</code> instance with a DOM driver. Line 2 provides an alias for the document element’s
tag, in this case <code class="literal">skier</code>. If an alias were not provided, then the document element would have a tag
named after the class; hence, line 2 is optional. The serialization in line 3 and the
deserialization in line 4 are quick and easy. The output for both <code class="literal">println</code> calls is</p><pre class="screen">&lt;skier&gt;
  &lt;name&gt;Bjoern Daehlie&lt;/name&gt;
  &lt;age&gt;49&lt;/age&gt;
  &lt;gender&gt;Male&lt;/gender&gt;
&lt;/skier&gt;</pre><p>The generated XML is minimalist. Compiling and running this code requires the core <code class="literal">XStream</code> packages,
which come in a single JAR file: <span class="emphasis"><em>xstream.jar</em></span>.</p><p>The first <code class="literal">XStream</code> example begins with the serialization of an entire <code class="literal">PersonNoProps</code> instance and
ends with the deserialization of a clone. <code class="literal">XStream</code> also supports selective or fine-grained
serialization and deserialization. The next example (see <a class="xref" href="#Ex9a" title="Example 9. The PersonPropsConverter class for customized marshaling.">Example 9, “The <code class="literal">PersonPropsConverter</code> class for customized marshaling.”</a>) illustrates.</p><div class="example"><a id="Ex9a"></a><p class="title"><b>Example 9. The <code class="literal">PersonPropsConverter</code> class for customized marshaling.</b></p><div class="example-contents"><pre class="screen">import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class PersonPropsConverter implements Converter {
    public boolean canConvert(Class c) {
        return c.equals(PersonProps.class);                    <a id="CO1-41"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    }
    // As proof of concept, marshal/unmarshal only the name.
    public void marshal(Object object,
                        HierarchicalStreamWriter writer,
                        MarshallingContext context) {
        PersonProps person = (PersonProps) object;
        writer.startNode("Person");
        writer.setValue(person.getName());                     <a id="CO1-42"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        writer.endNode();
    }
    public Object unmarshal(HierarchicalStreamReader reader,
                            UnmarshallingContext context) {
        PersonProps person = new PersonProps();
        reader.moveDown();
        person.setName(reader.getValue());                     <a id="CO1-43"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        reader.moveUp();
        return person;
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PersonPropsConverter</code> class (see <a class="xref" href="#Ex9a" title="Example 9. The PersonPropsConverter class for customized marshaling.">Example 9, “The <code class="literal">PersonPropsConverter</code> class for customized marshaling.”</a>) serializes and deserializes, as proof of concept, only one
property in a <code class="literal">PersonProps</code> instance: the <code class="literal">name</code> property. An implementation of the <code class="literal">Converter</code> interface
must define three methods:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">canConvert</code>: This method (line 1) returns a <code class="literal">boolean</code> to indicate which types are eligible for the customized
serialization and deserialization defined in the methods <code class="literal">marshal</code> and <code class="literal">unmarshal</code> (lines 2 and 3,
respectively). In this example, an object must be of type <code class="literal">PersonProps</code> (see <a class="xref" href="#Ex10a" title="Example 10. The code to illustrate customized XStream marshaling/unmarshaling.">Example 10, “The code to illustrate customized <code class="literal">XStream</code> marshaling/unmarshaling.”</a>), which includes any descendants of this
class, in order to be convertible.
</li><li class="listitem">
<code class="literal">marshal</code>: This method (line 2) supports customized serialization (marshaling) of a <code class="literal">PersonProps</code> object. In
the current example, only the person’s <code class="literal">name</code> property is serialized but any subset of the properties, including
all of them, could be serialized.
</li><li class="listitem">
<code class="literal">unmarshal</code>: This method (line 3), the inverse of <code class="literal">marshal</code>, supports customized deserialization (unmarshaling).
</li></ul></div><div class="example"><a id="Ex10a"></a><p class="title"><b>Example 10. The code to illustrate customized <code class="literal">XStream</code> marshaling/unmarshaling.</b></p><div class="example-contents"><pre class="screen">import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

public class PersonProps {
    private String name;
    private int    age;
    private String gender;

    // constructor
    public PersonProps() { }
    // properties
    public void setName(String name) { this.name = name; }         <a id="CO1-44"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public String getName() { return this.name; }
    public void setAge(int age) { this.age = age; }                <a id="CO1-45"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    public int getAge() { return this.age; }
    public void setGender(String gender) { this.gender = gender; } <a id="CO1-46"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
    public String getGender() { return this.gender; }
}

class Main {
    public static void main(String[ ] args) {
        // Create a person and set only the name.
        PersonProps person = new PersonProps();
        person.setName("Bruno");
        XStream xstream = new XStream(new DomDriver());
        xstream.registerConverter(new PersonPropsConverter());     <a id="CO1-47"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        xstream.alias("name", PersonProps.class);
        String xml = xstream.toXML(person);                        <a id="CO1-48"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        System.out.println(xml);
        PersonProps clone = (PersonProps) xstream.fromXML(xml);    <a id="CO1-49"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        System.out.println(clone.getName()); // Bruno
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">PersonProps</code> class (see <a class="xref" href="#Ex10a" title="Example 10. The code to illustrate customized XStream marshaling/unmarshaling.">Example 10, “The code to illustrate customized <code class="literal">XStream</code> marshaling/unmarshaling.”</a>) revises the <code class="literal">PersonNoProps</code> class by adding properties.
The  revised class has
three conventional Java properties, each defined as a pair of <span class="emphasis"><em>get/set</em></span> methods. The
properties are <code class="literal">name</code> (type <code class="literal">String</code>) in line 1, <code class="literal">age</code> (type <code class="literal">int</code>) in line 2, and <code class="literal">gender</code> (type <code class="literal">String</code>)
in line 3. The
revised class has a no-argument constructor.</p><p>The tester class <code class="literal">Main</code> creates an <code class="literal">XStream</code> instance as before but now registers a
customized <code class="literal">Converter</code> (line 4), a <code class="literal">PersonPropsConverter</code> (see <a class="xref" href="#Ex9a" title="Example 9. The PersonPropsConverter class for customized marshaling.">Example 9, “The <code class="literal">PersonPropsConverter</code> class for customized marshaling.”</a>). In the
call to <code class="literal">toXML</code> (line 5), the customized converter takes over and serializes only the
<code class="literal">name</code> property. The output is:</p><pre class="screen">&lt;person&gt;
  &lt;name&gt;Bruno&lt;/name&gt;
&lt;/person&gt;</pre><p>The deserialization (line 6) creates a new <code class="literal">PersonProps</code> instance and sets the <code class="literal">name</code> property
to <code class="literal">Bruno</code>. The other properties, <code class="literal">age</code> and <code class="literal">gender</code>, have the default values for fields, in
this case <code class="literal">0</code> and <code class="literal">null</code>, respectively.</p><p>The core <code class="literal">XStream</code> library also supports the conversion of Java objects to and from JSON. There
are various JSON drivers available in this library, the simplest of which is the
<code class="literal">JsonHierarchicalStreamDriver</code>. This driver supports the serialization of Java objects to JSON
but not the inverse operation. If deserialization from JSON to Java is needed, then a driver such
as Jettison (<span class="emphasis"><em>jettison.codehaus.org</em></span>) is a good choice because it interoperates cleanly with
<code class="literal">XStream</code>.</p><div class="example"><a id="Ex11a"></a><p class="title"><b>Example 11. An example of <code class="literal">XStream</code> serialization to JSON.</b></p><div class="example-contents"><pre class="screen">import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;
import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;

public class JsonTest {
    public static void main(String[ ] args) {
        PersonNoProps bd = new PersonNoProps("Bjoern Daehlie", 49, "Male");
        XStream xstream = new XStream(new JsonHierarchicalStreamDriver());  <a id="CO1-50"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        String json = xstream.toXML(bd); // it's really toJson now          <a id="CO1-51"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        System.out.println(json);
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">JsonTest</code> code (see <a class="xref" href="#Ex11a" title="Example 11. An example of XStream serialization to JSON.">Example 11, “An example of <code class="literal">XStream</code> serialization to JSON.”</a>) illustrates basic JSON serialization in <code class="literal">XStream</code>. An <code class="literal">XStream</code>
instance now is constructed with a JSON driver (line 1), in this case an instance of
a <code class="literal">JsonHierarchicalStreamDriver</code>, which comes with the core <code class="literal">XStream</code> JAR file.
The serializing method is still named <code class="literal">toXML</code> (line 2) but the output is JSON rather
than XML because of the JSON driver. Here is the output:</p><pre class="screen">{"PersonNoProps": {
  "name": "Bjoern Daehlie",
  "age": 49,
  "gender": "Male"
}}</pre><p><code class="literal">XStream</code> supports customized JSON serialization. For example, a programmer might not want
the root element <code class="literal">PersonNoProps</code> included in the JSON; and the JSON serializer can be
programmed to exclude this element.</p><p>The <code class="literal">XStream</code> API is remarkably low-fuss but likewise powerful. This API has gained steadily in
popularity among Java developers who are looking for quick and easy ways to convert between Java objects, on the
one side, and either XML or JSON documents, on the other side.</p><p>The JAX-B and <code class="literal">XStream</code> examples illustrate serialization from Java to XML or JSON and deserialization from
XML or JSON to Java. In the context of clients against RESTful web services, the deserialization side of
the coin is of primary interest because these clients need to process the response payloads, in XML or JSON,
that come from the RESTful service. Accordingly, the next section returns to Amazon’s E-Commerce service but
this time with the goal of hiding the XML that this service returns in response to a successful HTTP request.</p></div></div><div class="section" title="1.5. Another Client against the Amazon E-Commerce Service"><div class="titlepage"><div><div><h3 class="title"><a id="_another_client_against_the_amazon_e_commerce_service"></a>1.5. Another Client against the Amazon E-Commerce Service</h3></div></div></div><p>The second client against the Amazon E-Commerce service does not deal explicitly with any XML but otherwise has
the same functionality as the first client.
The steps for setting up the second client are listed below but
the ZIP file with the sample code includes an JAR <span class="emphasis"><em>Amazon2.jar</em></span> that can be executed directly:</p><pre class="screen">% java -jar Amazon2.jar &lt;accessId&gt; &lt;secretKey&gt;</pre><p>Here are the steps for setting up the second Amazon client, steps that would be copied for a Java client against
any RESTful service that provides an XML Schema—and most services do provide a schema. For a depiction of the
process and the role of Java’s <span class="emphasis"><em>xjc</em></span> utility, see <a class="xref" href="#xjc" title="Example 12. Using the xjc utility to transform an XML Schema into Java classes.">Example 12, “Using the <span class="emphasis"><em>xjc</em></span> utility to transform an XML Schema into Java classes.”</a>.</p><div class="example"><a id="xjc"></a><p class="title"><b>Example 12. Using the <span class="emphasis"><em>xjc</em></span> utility to transform an XML Schema into Java classes.</b></p><div class="example-contents"><pre class="screen">+------------+
| E-Commerce |     +-------------+      +------------------------+
| XML Schema +----&gt;| xjc utility |----&gt; | generated Java classes |
|            |     +-------------+      +------------------------+
+------------+</pre></div></div><br class="example-break" /><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
Download the XMl Schema for the E-Commerce service. The URL is:
</p><pre class="screen">webservices.amazon.com/AWSECommerceService/AWSECommerceService.xsd</pre><p class="simpara">The downloaded schema is about 55K in size. (This is the same schema used in the SOAP-based versions of the Amazon services.)
Put the downloaded document in a
local file such as <span class="emphasis"><em>amazon2/amazon.xsd</em></span>. The local file name is arbitrary.</p></li><li class="listitem"><p class="simpara">
The <span class="emphasis"><em>amazon.xsd</em></span> needs some tweaking so that the Java JAX-B utilities can use this file without
complaining. The downloaded XML Schema begins as follows:
</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema
  xmlns:xs="http://www.w3.org/2001/XMLSchema"                              <a id="CO1-52"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
  xmlns:tns="http://webservices.amazon.com/AWSECommerceService/2011-08-01"
  targetNamespace=
    "http://webservices.amazon.com/AWSECommerceService/2011-08-01"
  elementFormDefault="qualified"&gt;
  &lt;xs:element name="Bin"&gt;                                                  <a id="CO1-53"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    &lt;xs:complexType&gt;                                                       <a id="CO1-54"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
      &lt;xs:sequence&gt;                                                        <a id="CO1-55"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
      ...</pre><p class="simpara">The problem lies with the namespace identifier <code class="literal">xs</code>, which occurs once to the right of the colon (line 1) in</p><pre class="screen">xmlns:xs="http://www.w3.org/2001/XMLSchema"</pre><p class="simpara">on the second line and everywhere else to the left of the colon (lines 2, 3, and 4). The identifier <code class="literal">xs</code> should be
changed globally to <code class="literal">xsd</code>; any reasonable text editor can make this change. The result should be:</p><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:tns="http://webservices.amazon.com/AWSECommerceService/2011-08-01"
  targetNamespace=
    "http://webservices.amazon.com/AWSECommerceService/2011-08-01"
  elementFormDefault="qualified"&gt;
  &lt;xsd:element name="Bin"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
      ...</pre><p class="simpara">The <span class="emphasis"><em>xjc</em></span> utility should not be this brittle, of course; Java itself generates schemas that use the
namespace abbreviation <code class="literal">xs</code>.</p></li><li class="listitem"><p class="simpara">
Execute the <span class="emphasis"><em>xjc</em></span> utility, which ships with the core Java JDK, against the schema.
In this example, the command is:
</p><pre class="screen">% xjc -p restful2 amazon.xsd</pre><p class="simpara">The <span class="emphasis"><em>-p</em></span> flag stands for <span class="emphasis"><em>package</em></span>. The <span class="emphasis"><em>xjc</em></span> utility creates the package/subdirectory named
<span class="emphasis"><em>restful2</em></span> and fills the subdirectory with, at present, 84 Java source files. The files have
names such as <span class="emphasis"><em>CartAddRequest.java</em></span>, <span class="emphasis"><em>ItemLookup.java</em></span>, <span class="emphasis"><em>ItemSearch.java</em></span>, <span class="emphasis"><em>LoyaltyPoints.java</em></span>, and so on.
These files, in compiled form, are the Java types that correspond to the XML Schema types in <span class="emphasis"><em>amazon.xsd</em></span>.</p></li><li class="listitem">
This step is optional but recommended for convenience. Copy the source files <span class="emphasis"><em>RestfulAmazon.java</em></span> and
<span class="emphasis"><em>RequestHelper.java</em></span> from the first Amazon
example into the <span class="emphasis"><em>restful2</em></span> subdirectory. The package name in both files needs to change
from <code class="literal">restful</code> to <code class="literal">restful2</code>. The <span class="emphasis"><em>xjc</em></span>-generated files could be kept in a
separate package, of course.
</li><li class="listitem">
Compile the <span class="emphasis"><em>.java</em></span> files in <span class="emphasis"><em>restful2</em></span>.
</li></ul></div><p>The nearly 85 Amazon files in <span class="emphasis"><em>restful2</em></span> have JAX-B annotations such as <code class="literal">@XmlType</code>. These
<span class="emphasis"><em>xjc</em></span>-generated files automate the translation between an XML data type such as
<code class="literal">tns:ItemSearch</code> and the corresponding Java type, in this case <code class="literal">restful2.ItemSearch</code>.
The XML types are defined in the Amazon schema and the corresponding Java types are the
classes generated with the <span class="emphasis"><em>xjc</em></span> utility.
The process (see <a class="xref" href="#xjc" title="Example 12. Using the xjc utility to transform an XML Schema into Java classes.">Example 12, “Using the <span class="emphasis"><em>xjc</em></span> utility to transform an XML Schema into Java classes.”</a>) of generating Java artifacts is relatively uncomplicated.</p><p>Programming involves trade-offs and the revised Amazon client illustrates one such
trade-off. On the plus side, the revised <code class="literal">RestfulAmazon</code> client no longer needs
<span class="emphasis"><em>explicitly</em></span> to parse XML; hence,
the various <code class="literal">import</code> directives that support DOM parsing can be removed because the <code class="literal">getAuthor</code>
method no longer uses the imported types such as <code class="literal">DocumentBuilder</code> and <code class="literal">NodeList</code>. On the minus
side, the <span class="emphasis"><em>xjc</em></span>-generated classes bring a new API into play; and this API involves
some Russian-doll nesting, as a look at the new code will show.</p><p>The revised client requires no changes to the <code class="literal">RequestHelper</code> except for the change in the package
name. The revised <code class="literal">RestfulAmazon</code> client (see <a class="xref" href="#Ex8" title="Example 13. The revised RestfulAmazon that uses JAX-B to avoid XML parsing.">Example 13, “The revised <code class="literal">RestfulAmazon</code> that uses JAX-B to avoid XML parsing.”</a>) is largely the same as the original; hence,
unchanged code is marked with an ellipsis.</p><div class="example"><a id="Ex8"></a><p class="title"><b>Example 13. The revised <code class="literal">RestfulAmazon</code> that uses JAX-B to avoid XML parsing.</b></p><div class="example-contents"><pre class="screen">package restful2;

...
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Schema;
import javax.xml.XMLConstants;
import javax.xml.validation.Validator;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.JAXBException;

public class RestfulAmazon {
    ...
    public static void main(String[ ] args) {
       ...
    }
    private void lookupStuff(String accessKeyId, String secretKey) {
       ...
    }
    private String requestAmazon(String string_url) {
        ...
    }
    private String getAuthor(String xml) {
      String author = null;
      try {
        // Create an XML Schema object
        final String fileName = "amazon.xsd"; // downloaded XML Schema
        final String schemaUri = XMLConstants.W3C_XML_SCHEMA_NS_URI;
        SchemaFactory factory = SchemaFactory.newInstance(schemaUri);
        Schema schema = factory.newSchema(new StreamSource(fileName));          <a id="CO1-56"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
        // Create a JAX-B context for unmarshaling
        JAXBContext ctx = JAXBContext.newInstance(ItemLookupResponse.class);    <a id="CO1-57"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        Unmarshaller um = ctx.createUnmarshaller();                             <a id="CO1-58"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        um.setSchema(schema);                                                   <a id="CO1-59"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        // Generate a Java ItemSearchResponse instance.
        ItemLookupResponse ilr = (ItemLookupResponse)
             um.unmarshal(new ByteArrayInputStream(xml.getBytes()));            <a id="CO1-60"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        // Use the standard POJO idiom to extract the author.
        List&lt;Items&gt; itemsList = ilr.getItems(); // list of lists                <a id="CO1-61"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
        for (Items items : itemsList) {         // outer list                   <a id="CO1-62"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
          List&lt;Item&gt; list = items.getItem();  // inner list                     <a id="CO1-63"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
          for (Item item : list) {            // items in inner list
            ItemAttributes attributes = item.getItemAttributes();
            List&lt;String&gt; authors = attributes.getAuthor(); // could be several
            author = authors.get(0); // in this case, only one                  <a id="CO1-64"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
          }
        }
      }
      catch(JAXBException e ) { throw new RuntimeException(e); }
      catch(Exception e) { throw new RuntimeException(e); }
      return author;
    }
}</pre></div></div><br class="example-break" /><p>In the revised <code class="literal">RestfulAmazon</code> client, the <code class="literal">getAuthor</code> method is invoked with an XML
document as the argument but the XML is not parsed. Instead, the method does the
following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A <code class="literal">JAXBContext</code> is used to get information about the class of interest, in this
case the <span class="emphasis"><em>xjc</em></span>-generated class, <code class="literal">ItemLookupResponse</code> (line 2). This class represents
the E-Commerce response from a lookup operation against the service.
</li><li class="listitem">
The <code class="literal">JAXBContext</code> instance is used to create an unmarshaler (line 3), which then
is initialized with the E-Commerce schema (lines 1 and 4).
</li><li class="listitem">
The unmarshaler transforms the bytes from the E-Commerce response document, which
is XML, into an instance of the <code class="literal">ItemLookupResponse</code> class. At this point, there is
no need to parse any XML because the <code class="literal">ItemLookupResponse</code> object can be used instead
to find desired information, in this case the author’s name.
</li><li class="listitem"><p class="simpara">
In the current example, the <code class="literal">RestfulAmazon</code> client looks up only one item, a book. In
general, however, a look-up request against the E-Commerce service might yield
many hits instead of just one. At the data structure level, the result is lists nested
inside lists; hence, code lines 6 through 8 work from the outermost to the innermost list.
Here, for a closer look, is the looping in isolation:
</p><pre class="screen">List&lt;Items&gt; itemsList = ilr.getItems(); // list of lists        <a id="CO1-65"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
for (Items items : itemsList) {         // outer list
   List&lt;Item&gt; list = items.getItem();   // inner list
      for (Item item : list) {          // items in inner list  <a id="CO1-66"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
         ItemAttributes attributes = item.getItemAttributes();  <a id="CO1-67"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            List&lt;String&gt; authors = attributes.getAuthor();
            author = authors.get(0); // in this case, only one  <a id="CO1-68"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
      }
}</pre><p class="simpara">The <code class="literal">getItems</code> method encapsulated in the <code class="literal">ItemLookupResponse</code> object returns a <code class="literal">List&lt;Items&gt;</code> (line 1)
but each
element in this list is itself a list. In the second <code class="literal">for</code> loop (line 2), individual
items are finally available; indeed, in this response there is exactly one
such <code class="literal">Item</code>, whose <code class="literal">ItemAttributes</code> (line 3) include the name of the author, J. K. Rowling. Her name
occurs as the first and only name in a list of authors (line 4) because, of course, even a single
book might have multiple authors.</p></li></ul></div><p>The two clients against the Amazon RESTful service highlight a typical choice confronted
in programming RESTful clients. The choice can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Should the client deal directly with the returned XML (or JSON), using parsing and
similar tools to extract the required information?
</li><li class="listitem">
Should the client invest in utilities such as JAX-B that can hide the XML but thereby
require the client to work in yet another API?
</li></ul></div><p>Is there a compelling answer to either question? For one-off client
applications, working directly with the XML may be the way to go. Tools such as
<code class="literal">XPath</code> make it relatively easy to extract information from XML documents, at least XML
documents that are of a reasonable size. It is very hard to define <span class="emphasis"><em>reasonable size</em></span> in
this context, of course. The problem is that tools such as <code class="literal">XPath</code> require a DOM—a tree structure—in
order to work. Building a tree from, say, an XML stream of gigabyte size may be
prohibitively slow; and searching the built tree may be the same.
For client applications that regularly target a particular service such as
Amazon E-Commerce, working with JAX-B artifacts means working in familiar Java idioms
such as <span class="emphasis"><em>get/set</em></span> methods. The benefit of using JAX-B is that
the XML effectively disappears into the JAX-B infrastructure.</p></div><div class="section" title="1.6. The CTA Bus Tracker Services"><div class="titlepage"><div><div><h3 class="title"><a id="_the_cta_bus_tracker_services"></a>1.6. The CTA Bus Tracker Services</h3></div></div></div><p>The Amazon web sites for shopping, storage, and cloud computing are rich in content and
functionality—and the corresponding web services inherit these very attributes.
Amazon, moreover, is a pioneer and a major player in web services, SOAP-based and REST-style.
Social networking sites such as Facebook, Twitter, and Tumblr
support RESTful services against their sites. Indeed, the trend among any serious web sites,
large or small, is to provide RESTful access and an API in support of such access. For contrast,
this section considers a relatively recent and, in comparison with Amazon, a small-scale effort
at RESTful web services: bus-tracking at the CTA (Chicago Transit Authority).</p><p>The Amazon E-Commerce service has a standard design in that a single service encapsulates
many operations, for instance, operations to search, look up, order, clear a shopping cart,
and so on.
The CTA takes a different approach in that each service consists of a
single operation; and there is a separate XML Schema per service. The services are thus
quite simple and the schemas range in size from about 12 to 36 lines in size. The
simplest service returns the current local time; more complicated services report on buses
en route and their routes, expected bus-arrival times at particular locations, vehicles in
operation, and the like.</p><div class="example"><a id="bus_tracker"></a><p class="title"><b>Example 14. A sample client against the CTA’s RESTful bus-tracking services.</b></p><div class="example-contents"><pre class="screen">package ctaBT;

import java.net.URL;
import java.net.URLConnection;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BusTracker {
    private static final String baseUrl =
        "http://www.ctabustracker.com/bustime/api/v1/";

    public static void main(String[ ] args) {
        if (args.length &lt; 1) {
            System.err.println("BusTracker &lt;CTA key&gt;");
            return;
        }
        new BusTracker().demo("?key=" + args[0]);
    }
    private void demo(String key) {
        // Current official CTA time.
        String url = baseUrl + "gettime" + key;
        makeRequest(url);
        url = baseUrl + "getvehicles" + key;
        makeRequest(url);
        String sampleRoute = "&amp;rt=20&amp;pid=954";
        url = baseUrl + "getpatterns" + key + sampleRoute;
        makeRequest(url);
    }
    private void makeRequest(String stringUrl) {
        String response = null;
        try {
            URL url = new URL(stringUrl);
            URLConnection conn = url.openConnection();
            conn.setDoInput(true);
            BufferedReader in =
                new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String chunk = null;
            while ((chunk = in.readLine()) != null) response += chunk;
            in.close();
        }
        catch(Exception e) { throw new RuntimeException("Arrrg! " + e); }
        report(stringUrl, response);
    }
    private void report(String url, String xml) {
        String msg = url + "\n" + xml;
        System.out.println(msg);
    }
}</pre></div></div><br class="example-break" /><div class="sidebar" title="Registering with the CTA"><a id="cta_key"></a><p class="title"><b>Registering with the CTA</b></p><p>The CTA bus-tracker web services are free of charge but do require registration (<span class="emphasis"><em>www.ctabustracker.com</em></span>). A client
call against any service requires a <span class="emphasis"><em>key</em></span>, which the CTA provides upon registration.</p></div><p>Use of the bus-tracking service, through the web site or a web service, requires a <span class="emphasis"><em>key</em></span> (see <a class="xref" href="#cta_key" title="Registering with the CTA">Registering with the CTA</a>) from
the CTA. The key occurs as a query string attribute in a GET request, the only
type of HTTP request supported. The sample <code class="literal">BusTracker</code> client (see <a class="xref" href="#bus_tracker" title="Example 14. A sample client against the CTA’s RESTful bus-tracking services.">Example 14, “A sample client against the CTA’s RESTful bus-tracking services.”</a>) first targets the <span class="emphasis"><em>gettime</em></span> service
whose XML Schema is <a class="xref" href="#bus_schema" title="Example 15. The XML Schema for the CTA time service.">Example 15, “The XML Schema for the CTA time service.”</a>.</p><div class="example"><a id="bus_schema"></a><p class="title"><b>Example 15. The XML Schema for the CTA time service.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="bustime-response" type=" bustime-response" /&gt;
  &lt;xs:complexType name="bustime-response"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="error" type="error"
                  minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element name="tm" type="xs:string"
                  minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="error"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="msg" type="xs:string"
                  minOccurs="1" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></div></div><br class="example-break" /><p>On a successful GET request, the response is similar to</p><pre class="screen">&lt;?xml version="1.0"?&gt;
&lt;bustime-response&gt;
  &lt;tm&gt;20130302 16:38:49&lt;/tm&gt;
&lt;/bustime-response&gt;</pre><p>The invocation syntax for other services is only slightly more complicated. For example, the
GET request with this URL</p><pre class="screen">http://www.ctabustracker.com/bustime/api/v1/getpatterns?key=...&amp;rt=20&amp;pid=954:</pre><p>is asking for the traffic patterns of buses en route. A sample response would look like this:</p><pre class="screen">&lt;bustime-response&gt;
  &lt;ptr&gt;
    &lt;pid&gt;954&lt;/pid&gt;
    &lt;ln&gt;40902.0&lt;/ln&gt;
    &lt;rtdir&gt;West Bound&lt;/rtdir&gt;
    &lt;pt&gt;
      &lt;seq&gt;1&lt;/seq&gt;
      &lt;lat&gt;41.882134908777&lt;/lat&gt;
      &lt;lon&gt;-87.624528408051&lt;/lon&gt;
    &lt;/pt&gt;
    ...
  &lt;/ptr&gt;
&lt;/bustime-response&gt;</pre><p>The bus-tracker services are deliberately small and simple, which encourages developers to experiment
with composing other services out of these. The CTA services illustrate a refreshing trend to make
data available on web sites equally accessible through web services. The CTA itself currently has
a beta release of train-tracking services modeled after the bus-tracking ones.</p></div><div class="section" title="1.7. RESTful Clients and WADL Documents"><div class="titlepage"><div><div><h3 class="title"><a id="_restful_clients_and_wadl_documents"></a>1.7. RESTful Clients and WADL Documents</h3></div></div></div><p>At the core of a SOAP-based service is the <span class="emphasis"><em>service contract</em></span>, a WSDL
(Web Service Description Language) document. WSDL is an XML dialect. In modern web services, the
WSDL plays the role that the IDL (Interface Definition Language) document plays in the DCE/RPC
services introduced in Chapter 1.
In any case, the WSDL document
has various sections, all of which are required except for the <span class="emphasis"><em>types</em></span> section that contains
an XML Schema or equivalent; and modern WSDLs almost always include a schema. The information
in the WSDL specifies the invocation syntax for every operation encapsulated in the service.
SOAP frameworks such as Java Metro and DotNet provide
tools that, given a WSDL, can generate client-side library code, which facilitates
the programming of a client against the service. The WSDL itself is language neutral and
the publisher of the service typically generates at least the first draft of this service
contract, which then can be refined as needed. In principle a WSDL document could describe
either a SOAP-based or a REST-style service; in practice, however, the WSDL is used predominantly
for SOAP-based services. Chapter 4, which introduces SOAP-based examples, looks closely at the WSDL document.
For now, the similarity between a WSDL document and a WADL document is of interest.</p><p>As noted, WSDL documents can describe either category of web service, SOAP-based or REST-style; but there seems
to be little interest in WSDLs and WSDL-based tools for RESTful services. JAX-RS implementations
such as Metro do provide a WSDL counterpart, the WADL (Web Application Description Language)
document that describes a JAX-RS service and can be used to generate client-side code. The
<span class="emphasis"><em>wadl2java</em></span> tool can be downloaded from <span class="emphasis"><em>wadl.java.net</em></span>. (The <span class="emphasis"><em>wadl2java</em></span> download includes
Unixy and Windows versions.) As the name indicates, this tool
generates Java code from a WADL document. The publisher of JAX-RS service generates the
WADL dynamically, although a WADL, like a WSDL, could be edited as needed—or even written from
scratch. The syntax for getting the WADL differs slightly among JAX-RS implementations. In the
Jersey implementation, the document is available as <span class="emphasis"><em>application.wadl</em></span>. As an example, recall the
<span class="emphasis"><em>predictions3</em></span> JAX-RS service from Chapter 2 whose base URL is:</p><pre class="screen">http://localhost:8080/predictions3/resourcesP/</pre><p>The WADL document for this service is available under Jersey with the URL:</p><pre class="screen">http://localhost:8080/predictions3/resourcesP/application.wadl</pre><p>If the implementation were Apache CXF instead of Jersey, the URL would be:</p><pre class="screen">http://localhost:8080/predictions3/resourcesP?wadl</pre><p>The WADL document for the <span class="emphasis"><em>predictions3</em></span> service (see <a class="xref" href="#wadl" title="Example 16. The WADL document for the predictions3 JAX-RS web service.">Example 16, “The WADL document for the <span class="emphasis"><em>predictions3</em></span> JAX-RS web service.”</a>) is a page or so in size.
The document links the HTTP verb
for a CRUD operation with the URI for the code that implements the operation; and the
document section also includes information about the parameters passed into the operation.
For example, here is a segment for creating a new <code class="literal">Prediction</code> in the <span class="emphasis"><em>predictions3</em></span> service:</p><pre class="screen">&lt;resource path="/create"&gt;                                                <a id="CO1-69"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   &lt;method name="POST" id="create"&gt;                                      <a id="CO1-70"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
      &lt;request&gt;
         &lt;representation mediaType="application/x-www-form-urlencoded"&gt;  <a id="CO1-71"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   type="xsd:string" style="query" name="who"/&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   type="xsd:string" style="query" name="what"/&gt;
         &lt;/representation&gt;
      &lt;/request&gt;
      &lt;response&gt;
         &lt;representation mediaType="text/plain"/&gt;                        <a id="CO1-72"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
      &lt;/response&gt;
   &lt;/method&gt;
&lt;/resource&gt;</pre><p>The <code class="literal">resource</code> element (line 1) specifies the <code class="literal">path</code> or URI, in this case <code class="literal">/create</code>, that identifies
the RESTful resource. Next comes the HTTP method (line 2), in this case POST, together with the
implementing Java method, in this case <code class="literal">create</code>.
The <span class="emphasis"><em>wadl2java</em></span> utility gets the names
of the resource path and the implementing Java method from the source code.
The WADL segment also gives the MIME types of the request (line 3) and the
response (line 4): the request type <code class="literal">application/x-www-form-urlencoded</code> specifies a URL-encoded
form (that is, collection of key/value pairs) in the body of the POST request; and the
response type <code class="literal">text/plain</code> is, if the request succeeds, a confirmation message.</p><div class="example"><a id="wadl"></a><p class="title"><b>Example 16. The WADL document for the <span class="emphasis"><em>predictions3</em></span> JAX-RS web service.</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/"
         jersey:generatedBy="Jersey: 1.10 11/02/2011 03:53 PM"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:8080/predictions3/resourcesP/"&gt;
      &lt;resource path="/"&gt;
        &lt;resource path="/delete/{id: \d+}"&gt;
          &lt;param xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                 type="xsd:int" style="template" name="id"/&gt;
          &lt;method name="DELETE" id="delete"&gt;
            &lt;response&gt;
              &lt;representation mediaType="application/json"/&gt;
            &lt;/response&gt;
          &lt;/method&gt;
        &lt;/resource&gt;
        &lt;resource path="/create"&gt;
          &lt;method name="POST" id="create"&gt;
            &lt;request&gt;
              &lt;representation mediaType="application/x-www-form-urlencoded"&gt;
                ...
              &lt;/representation&gt;
            &lt;/request&gt;
            &lt;response&gt;
               &lt;representation mediaType="text/plain"/&gt;
            &lt;/response&gt;
          &lt;/method&gt;
        &lt;/resource&gt;
        ...
        &lt;resource path="/xml/{id: \d+}"&gt;
          &lt;param xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                 type="xsd:int" style="template" name="id"/&gt;
                &lt;method name="GET" id="getXml"&gt;
                  &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                  &lt;/response&gt;
                &lt;/method&gt;
        &lt;/resource&gt;
        &lt;resource path="/json"&gt;
          &lt;method name="GET" id="getJson"&gt;
            &lt;response&gt;
              &lt;representation mediaType="application/json"/&gt;
            &lt;/response&gt;
          &lt;/method&gt;
        &lt;/resource&gt;
        &lt;resource path="/json/{id: \d+}"&gt;
          &lt;param xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                 type="xsd:int" style="template" name="id"/&gt;
          &lt;method name="GET" id="getJson"&gt;
            &lt;response&gt;
              &lt;representation mediaType="application/json"/&gt;
            &lt;/response&gt;
          &lt;/method&gt;
        &lt;/resource&gt;
        ...
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><br class="example-break" /><p>The WADL document is language neutral but its use is confined basically to the Java world. Other languages
and frameworks have their counterparts; for example, Rails has the <code class="literal">ActiveResource</code> construct that lets
a client program interact with a service but without dealing explicitly with documents in XML or JSON. The
<span class="emphasis"><em>wadl2java</em></span> utility serves the same general purpose for the Java programmer.</p><p>WADL-derived code (see <a class="xref" href="#Ex11" title="Example 17. A segment of the Java source file generated with the wadl2java utility.">Example 17, “A segment of the Java source file generated with the <span class="emphasis"><em>wadl2java</em></span> utility.”</a>) is not everyday Java code, as the class named <code class="literal">Localhost_Predictions3ResourcesP</code>
indicates.
This code, like most that comes from utilities,
is not pretty but does support a Java client against the JAX-RS <span class="emphasis"><em>predictions3</em></span> service. Perhaps the best way to
appreciate the usefulness of the <span class="emphasis"><em>wadl2java</em></span> tool is to program a <span class="emphasis"><em>predictions3</em></span> client that uses the
<span class="emphasis"><em>wadl2java</em></span>-generated artifacts.</p><div class="example"><a id="Ex11"></a><p class="title"><b>Example 17. A segment of the Java source file generated with the <span class="emphasis"><em>wadl2java</em></span> utility.</b></p><div class="example-contents"><pre class="screen">package predictions3;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Generated;
import javax.ws.rs.core.UriBuilder;
import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.GenericType;
import com.sun.jersey.api.client.WebResource;
...
public class Localhost_Predictions3ResourcesP {
    public final static URI BASE_URI;
    static {
        URI originalURI = URI.create("http://localhost:8080/predictions3/resourcesP/");
        java.io.InputStream is =
          Localhost_Predictions3ResourcesP.class.getResourceAsStream(
            "/META-INF/jax-rs-catalog.xml");
        if (is != null) {
          ...
        }
        BASE_URI = originalURI;
    }
    ...
    public static class Root {
        public Localhost_Predictions3ResourcesP.Root.DeleteIdD deleteIdD(String idD) {
            return new Localhost_Predictions3ResourcesP.Root.DeleteIdD(_client,
                _uriBuilder.buildFromMap(_templateAndMatrixParameterValues), idD);
        }
        public Localhost_Predictions3ResourcesP.Root.Create create() {
            return new Localhost_Predictions3ResourcesP.Root.Create(_client,
                 _uriBuilder.buildFromMap(_templateAndMatrixParameterValues));
        }
        public Localhost_Predictions3ResourcesP.Root.Update update() {
            return new Localhost_Predictions3ResourcesP.Root.Update(_client,
                 _uriBuilder.buildFromMap(_templateAndMatrixParameterValues));
        }
        ...
        public static class Create {
            private Client _client;
            private UriBuilder _uriBuilder;
            private Map&lt;String, Object&gt; _templateAndMatrixParameterValues;
            private URI _uri;

            public Create(Client client, URI uri) {
                _client = client;
                _uri = uri;
                _uriBuilder = UriBuilder.fromUri(uri);
                _uriBuilder = _uriBuilder.path("/create");
                _templateAndMatrixParameterValues = new HashMap&lt;String, Object&gt;();
            }
            ...
            public&lt;T &gt;T postXWwwFormUrlencodedAsTextPlain(Object input,
                                                          GenericType&lt;T&gt; returnType) {
                UriBuilder localUriBuilder = _uriBuilder.clone();
                WebResource resource =
                   _client.resource(localUriBuilder.buildFromMap(
                                    _templateAndMatrixParameterValues));
                com.sun.jersey.api.client.WebResource.Builder resourceBuilder =
                   resource.getRequestBuilder();
                resourceBuilder = resourceBuilder.accept("text/plain");
                ...
                return response.getEntity(returnType);
            }
            ...
        }
        ...
}</pre></div></div><br class="example-break" /><div class="sidebar" title="From the predictions3.wadl file to the wadl2java-generated classes"><p class="title"><b>From the <span class="emphasis"><em>predictions3.wadl</em></span> file to the <span class="emphasis"><em>wadl2java</em></span>-generated classes</b></p><p>The <span class="emphasis"><em>wadl2java</em></span> utility for Jersey downloads from <span class="emphasis"><em>wadl.java.net</em></span> as a ZIP file, which includes
sample Ant and Maven scripts that can be adapted as needed. (The sample Ant script builds client-support
code for the Yahoo News Service, a RESTful service that Yahoo no longer publishes.) Let <span class="emphasis"><em>WADL_HOME</em></span> be
the base directory for the contents of the unzipped file. <span class="emphasis"><em>WADL_HOME</em></span> has a <span class="emphasis"><em>bin</em></span> subdirectory, with <span class="emphasis"><em>wadl2java</em></span>
utilities for Unixy and Windows systems; and a <span class="emphasis"><em>lib</em></span> directory that contains almost all of the JAR files
required. The missing JAR file, as of version WADL 1.1.3, is <span class="emphasis"><em>jersey-bundle.jar</em></span>, which should be copied into the
<span class="emphasis"><em>WADL_HOME/lib</em></span> directory.</p><p>The Jersey-generated WADL document for the <span class="emphasis"><em>predictions3</em></span> service uses <code class="literal">xs</code> instead of <code class="literal">xsd</code> as a namespace
identifier. Here are the first two occurrence in <span class="emphasis"><em>predictions.wadl</em></span>, with one <code class="literal">xs</code> to the left of the colon
and the other to the right:</p><pre class="screen">&lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
       type="xs:int"
...</pre><p>The <code class="literal">xs</code> should be changed globally to <code class="literal">xsd</code>.</p><p>Compiling a <span class="emphasis"><em>wadl2java</em></span>-generated file such as <span class="emphasis"><em>Localhost_Predictions3ResourcesP.java</em></span> requires
two JAR files: <span class="emphasis"><em>jersey-bundle.jar</em></span> and <span class="emphasis"><em>jersey-core.jar</em></span>. The ZIP file that contains the sample code
includes the Ant script <span class="emphasis"><em>runWADL.xml</em></span>, which compiles and executes the WADL-based client against the
<span class="emphasis"><em>predictions3</em></span> service.</p></div><p>The <code class="literal">Predictions3Client</code> (see <a class="xref" href="#Ex12" title="Example 18. The Predictions3Client, which uses the wadl2java-generated classes.">Example 18, “The <code class="literal">Predictions3Client</code>, which uses the <span class="emphasis"><em>wadl2java</em></span>-generated classes.”</a>) is the source code for a sample client against the <span class="emphasis"><em>predictions3</em></span> JAX-RS service.
For convenience, the
client is in the same package, <code class="literal">predictions</code>, as the <span class="emphasis"><em>wadl2java</em></span>-generated code. The <code class="literal">Predictions3Client</code> underscores
again the trade-off in using a tool such as <span class="emphasis"><em>wadl2java</em></span> to avoid dealing explicitly with XML or similar
payloads:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The upside is avoiding an XML or comparable parse.
</li><li class="listitem">
The downside is learning yet another API.
</li></ul></div><div class="example"><a id="Ex12"></a><p class="title"><b>Example 18. The <code class="literal">Predictions3Client</code>, which uses the <span class="emphasis"><em>wadl2java</em></span>-generated classes.</b></p><div class="example-contents"><pre class="screen">package predictions3;

import java.net.URI;

public class Predictions3Client {
    public static void main(String[]  args) {
        new Predictions3Client().demo();
    }
    private void demo() {
        // Get a reference to the Localhost_Predictions3ResourcesP.Root defined
        // inside Localhost_Predictions3ResourcesP, as the "root" provides access
        // to other classes, which in turn support the CRUD functionalities.
        Localhost_Predictions3ResourcesP.Root root =                         <a id="CO1-73"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
           Localhost_Predictions3ResourcesP.root();
        // The xmlGetter can make GET requests against the service.
        Localhost_Predictions3ResourcesP.Root.Xml xmlGetter = root.xml();    <a id="CO1-74"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        String xml = xmlGetter.getAsXml(String.class); // String returned    <a id="CO1-75"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        System.out.println("The raw XML:\n" + xml);    // predictions in XML
    }
}</pre></div></div><br class="example-break" /><p>The set-up in the <code class="literal">Predictions3Client</code> seems clumsy because the <span class="emphasis"><em>wadl2java</em></span>-generated artifacts
are nested <code class="literal">static</code> classes, an idiom that is uncommon in quotidian Java. The good news
is that, once the clumsiness recedes, the method calls are refreshingly simple. For instance,
the calls to the <code class="literal">root</code> (line 1) and <code class="literal">xml</code> (line 2) methods take no arguments and the call to
<code class="literal">getAsXml</code> (line 3) takes but one argument, the Java type for the returned XML document.
The <span class="emphasis"><em>wadl2java</em></span>-generated code would be even easier to use if XML Schema documents were
produced with, for example, the <code class="literal">schemagen</code> utility and then referenced in the <code class="literal">grammars</code> section of
<span class="emphasis"><em>predictions3.wadl</em></span>, which is currently empty. With this refinement, the call to</p><pre class="screen">xmlGetter.getAsXml(String.class)</pre><p>could be changed to the friendlier</p><pre class="screen">xmlGetter.getAsXml(PredictionsList.class)</pre><p>Chapter 4 covers the WSDL document and WSDL-based utilities for generating helpful client-side code. At that point it will
be easier to assess the usefulness of WADL documents and the related utilities. For now, it is enough to name WADL-related
technologies as yet another part of the Java support for RESTful web services.</p></div><div class="section" title="1.8. The JAX-RS Client API"><div class="titlepage"><div><div><h3 class="title"><a id="_the_jax_rs_client_api"></a>1.8. The JAX-RS Client API</h3></div></div></div><p>JAX-RS, Restlet, and the JAX-WS <code class="literal">@WebServiceProvider</code> frameworks for RESTful services include a client-side API.
These APIs are meant to simplify the task of writing RESTful clients in general, not just clients against a
RESTful service implemented in a particular framework. To underscore the point, this section takes a look
at the JAX-RS client-side API; the client, however, goes against the servlet-based <span class="emphasis"><em>predictions2</em></span> RESTful service
from Chapter 2.</p><div class="example"><a id="jaxrs_client"></a><p class="title"><b>Example 19. A sample client using the JAX-RS client-side API.</b></p><div class="example-contents"><pre class="screen">package jerseyClient;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.WebResource;
import javax.ws.rs.core.MediaType;
import com.sun.jersey.api.representation.Form;

public class JerseyClient {
    private static final String baseUrl = "http://localhost:8080/predictions2";

    public static void main(String[ ] args) {
        new JerseyClient().demo();
    }
    private void demo() {
        Client client = Client.create();
        client.setFollowRedirects(true); // in case the service redirects
        WebResource resource = client.resource(baseUrl);
        getAllDemo(resource);
        postDemo(resource); // same resource but different verb
        String url = baseUrl + "?id=32";
        resource = client.resource(url);
        getOneDemo(resource);
        deleteDemo(resource); // delete id = 32
    }
    private void getAllDemo(WebResource resource) {
        // GET all XML
        String response =
            resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);
        report("GET all in XML:\n", response);
        // GET all JSON
        response =
            resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class);
        report("GET all in JSON:\n", response);
    }
    private void getOneDemo(WebResource resource) {
        String response =
            resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);
        report("GET one in XML:\n", response);
        response =
            resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class);
        report("GET one in JSON:\n", response);
    }
    private void postDemo(WebResource resource) {
        Form form = new Form(); // HTTP body, a simple hash
        form.add("who", "William Butler Yeats");
        form.add("what", "I know that I shall meet my fate");

        String response =
            resource.type(MediaType.APPLICATION_FORM_URLENCODED_TYPE)
            .accept(MediaType.TEXT_PLAIN_TYPE)
            .post(String.class, form);
        report("POST:\n", response);
    }
    private void deleteDemo(WebResource resource) {
        String response =
            resource.accept(MediaType.TEXT_PLAIN_TYPE).delete(String.class);
        report("DELETE:\n", response);
    }
    private void report(String msg, String response) {
        System.out.println("\n" + msg + response);
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">JerseyClient</code> (see <a class="xref" href="#jaxrs_client" title="Example 19. A sample client using the JAX-RS client-side API.">Example 19, “A sample client using the JAX-RS client-side API.”</a>) against the servlet-based <span class="emphasis"><em>predictions2</em></span> RESTful service, which
supports all of the CRUD operations. (An executable JAR with the client is included in the
ZIP with the sample code.) This client underscores that the JAX-RS client API is not restricted to
JAX-RS services.
In any case, the <code class="literal">JerseyClient</code> uses some nice features of the
JAX-RS client-side API. For example, the <span class="emphasis"><em>predictions2</em></span> service uses same the URI in a GET request
that returns XML as in one that returns JSON. What differentiates the two requests  is that
the one for JSON has the key/value pair</p><pre class="screen">accept: application/json</pre><p>or the equivalent in the HTTP headers of a GET request.
In the <code class="literal">getAllDemo</code> method of the <code class="literal">JerseyClient</code>, the two forms of the GET request are
expressed at a high level:</p><pre class="screen">resource.accept(MediaType.APPLICATION_XML_TYPE).get(String.class);  // XML
resource.accept(MediaType.APPLICATION_JSON_TYPE).get(String.class); // JSON</pre><p>There is no need for the programmer to inject, using a low-level API, the</p><pre class="screen">accept: application/json</pre><p>key/value pair into
the HTTP headers. By the way, the <code class="literal">get(String.class)</code> at the end of each statement signals that
the response to the GET request should be text, a Java <code class="literal">String</code>. The API accepts JAX-B types as well so that,
for example, a GET request could indicate that it expects a <code class="literal">Prediction</code> object rather than a <code class="literal">String</code> one.</p><p>The setup for making CRUD calls is uncomplicated. A <code class="literal">Client</code> instance is created, which then can be used to
create arbitrarily many <code class="literal">WebResource</code> instances, each of which wraps a URL. Here, for review, is a
slice of the <code class="literal">JerseyClient</code>:</p><pre class="screen">Client client = Client.create();
client.setFollowRedirects(true); // in case the service redirects
WebResource resource = client.resource(baseUrl); // service URL</pre><p>In version 2, the JAX-RS client API introduces some advanced features such as
filters and asynchronous requests. These features will be examined in the next chapter but in the
context of SOAP-based web services. Restlet has a client API comparable to the one in JAX-RS. The JAX-WS
client API for calls against the <code class="literal">@WebServiceProvider</code> is at a lower level than both JAX-RS and Restlet. This
is appropriate in that the <code class="literal">@WebServiceProvider</code> service-side API is deliberately low level. All of these
client-side APIs add a RESTful layer to the familiar Java classes such as <code class="literal">URLConnection</code>.</p></div><div class="section" title="1.9. JSON for JavaScript Clients"><div class="titlepage"><div><div><h3 class="title"><a id="_json_for_javascript_clients"></a>1.9. JSON for JavaScript Clients</h3></div></div></div><p>JavaScript clients, often written in a dialect such as jQuery, are now a major force in RESTful web services.
Gone are the bad old days during which a browser downloaded a page generated on the server and did no further client-side
processing. A modern web site typically integrates client-side and server-side processing to serve the
overall goal of high performance combined with professional look-and-feel; and JavaScript—in a sense broad
enough to encompass languages/frameworks such as Dojo, Enyo, Meteor, midori, jQuery, and SmartClient—is the
dominant language for client-side processing.</p><p>At one time, the data displayed on a HTML page typically came from a database through a server-side application down to
a browser. Web services are now a prevalent source of data, a source accessible directly from a client-side script embedded
in an HTML page. Data flows into an HTML page need not originate, at least not immediately, in a server-side application connected to a
database.  These changes further blur
the distinction between web sites and web services because the HTML pages that remain a key part of any web site embed
scripts that can act as web service clients. Pioneering JavaScript frameworks such as Meteor (<span class="emphasis"><em>meteor.com</em></span>) aim at
virtually collapsing the difference between client-side and server-side functionality by allowing client-side
scripts direct access to a server-side database. These changes and trends together open new possibilities for
web services and their clients; these changes likewise point to an even greater role for JavaScript processing and JSON
representations in web services.</p><div class="section" title="1.9.1. JSONP and Web Services"><div class="titlepage"><div><div><h4 class="title"><a id="_jsonp_and_web_services"></a>1.9.1. JSONP and Web Services</h4></div></div></div><p>Contemporary web services regularly support not only JSON payloads but also JSONP, where the <span class="strong"><strong>P</strong></span> stands for <span class="emphasis"><em>with padding</em></span>. JSONP originally
signified a way to work around
the traditional <span class="emphasis"><em>same domain policy</em></span> that prevents a page downloaded from a domain such as <span class="emphasis"><em>server.foo.org</em></span> from communicating
with a domain other than <span class="emphasis"><em>foo.org</em></span>; and JSONP still serves this purpose.
The JSONP workaround involves <code class="literal">script</code> elements in a page, as these elements allow code
to be downloaded from anywhere; and the downloaded code then can perform arbitrary processing, which
includes communicating with servers in arbitrary domains. JSONP works nicely with web services.</p><p>JSONP brings an event-driven API to client-side processing. Using JSONP, the programmer can do the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Provide a URL to a data source.
</li><li class="listitem">
Specify a callback function to be executed, in browser context, once the data from the
specified source arrives.
</li></ul></div><div class="example"><a id="twitter"></a><p class="title"><b>Example 20. A JSONP call against the RESTful Twitter search.</b></p><div class="example-contents"><pre class="screen">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Twittering&lt;/title&gt;
    &lt;script type = "text/javascript"
            src = "http://code.jquery.com/jquery-latest.min.js"&gt;
    &lt;/script&gt;
    &lt;script type = 'text/javascript'&gt;
       function cBack(data) { alert(JSON.stringify(data)); } <a id="CO1-76"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
       (function($) {
          var url = "http://search.twitter.com/search.json?q=skiing&amp;rpp=4";
          $.ajax({
             type: 'GET',
             url: url,
             async: false,
             jsonpCallback: 'cBack',                         <a id="CO1-77"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
             contentType: "application/json",
             dataType: 'jsonp',                              <a id="CO1-78"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
             success: function(json) { console.dir(json.sites); },
             error: function(e) { console.log(e.message); }
          });
       })(jQuery);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</pre></div></div><br class="example-break" /><p>The HTML document in <a class="xref" href="#twitter" title="Example 20. A JSONP call against the RESTful Twitter search.">Example 20, “A JSONP call against the RESTful Twitter search.”</a> embeds jQuery code, which illustrates a JSONP call against Twitter’s RESTful search service.
The three code lines
of interest are numbered. The GET request to Twitter has <code class="literal">jsonp</code> as its <code class="literal">dataType</code> (line 3) and the
<code class="literal">jsonpCallback</code> is a function named <code class="literal">cBack</code> (lines 1 and 2) that takes one argument, the data returned
from the Twitter search. The Twitter response can be depicted in text as follows:</p><pre class="screen">cBack({...})</pre><p>This is the invocation syntax for a JavaScript function that takes one argument, a JavaScript object. (It
should be noted that a JavaScript function is likewise a JavaScript <span class="emphasis"><em>object</em></span>, as JavaScript treats
functions as first-class objects.)
The curly braces <code class="literal">{</code> and <code class="literal">}</code> mark the start and the end of the JavaScript argument to the function. This
argument is a mix of meta-data
about the search and a list (that is, a JavaScript array) of information about skiing images.
Here is a small slice of the argument, with personal data obscured with ellipses:</p><pre class="screen">{"completed_in":0.009, "max_id":308446633115385860,
 ...
 "query":"skiing","refresh_url":"?
 ...
 [{"created_at": "Mon, 04 Mar 2013 05:19:42 +0000",
   "from_user": "...", "from_user_id": ...,
   "from_user_id_str": "...", "from_user_name" : "... ",
   "geo":null,
   ...
}</pre><p>The JavaScript callback function <code class="literal">cBack</code>, upon receipt of the Twitter data, pops up an alert window
that shows the text representation of the
downloaded JSON object.</p><p>The JSONP exchange between the client-side script and the Twitter search service
can be summarized as follows. The script, written in the jQuery dialect of JavaScript, makes
a JSONP call that specifies a callback function; and the Twitter service accommodates by returning, as
the HTTP response,
the name of the callback function together with the requested data as the argument to the function. The
browser executes the function call, which displays the returned JSON in a popup window. This small example
thus illustrates the event-driven character of a JSONP request.</p><p>With respect to RESTful web services, JSON is an ideal format for JavaScript clients because JSON is the text
representation of a native JavaScript object. With two additional examples, this section covers the basics and sketches some possibilities.
The first example involves a <span class="emphasis"><em>composed</em></span> web service, that is, a service that includes
another service as a component. This example also illustrates a common task in web services—reformatting
data, in this case reformatting XML as JSON. The second example focuses on <span class="emphasis"><em>ajax</em></span>
calls: jQuery embedded in an HTMl page regularly polls a server so that the partially updated page reflects the current
state of the resource.</p></div><div class="section" title="1.9.2. A Composed RESTful Service with jQuery"><div class="titlepage"><div><div><h4 class="title"><a id="_a_composed_restful_service_with_jquery"></a>1.9.2. A Composed RESTful Service with jQuery</h4></div></div></div><p>The first jQuery example, named <span class="emphasis"><em>cds</em></span>, is a composed RESTful service. Here is an overview:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The HTML page, downloaded from the <span class="emphasis"><em>cds</em></span> service to a browser, contains embedded jQuery that makes
a GET request against
<span class="emphasis"><em>getCDs.jsp</em></span>, a JSP script with support from a back-end JavaBean. This JSP script and the back-end bean
together implement the web service that delivers JSON back to a jQuery or comparable script.
</li><li class="listitem">
The back-end JavaBean, an instance of the <code class="literal">FetchXML</code> class, makes its own GET request, in this case against
a RESTful service that the W3C maintains. This service delivers a list of CD titles from the 1980s, in XML format, back to the
<code class="literal">FetchXML</code> instance, which then converts the XML to JSON.
</li><li class="listitem"><p class="simpara">
The JSP script <span class="emphasis"><em>getCDs.jsp</em></span>, with the JSON from the back-end bean, completes the service by sending the
JSON list of CDs back to the jQuery script embedded in the HTML page. Here is slice of the returned JSON:
</p><pre class="screen">[{"title":"empire burlesque",
  "price":10.9,
  "company":"columbia",
  "year":1985,
  "artist":"bob dylan",
  "country":"usa"},
 ...</pre></li><li class="listitem">
The jQuery script displays, as confirmation, the downloaded JSON in a pop-up window and then iterates over
the JSON array of CDs, displaying the <code class="literal">title</code> and the <code class="literal">artist</code> for each CD as an HTML element in an
unordered list. The entire scenario (see <a class="xref" href="#cds_picture" title="Example 21. The composed cds service.">Example 21, “The composed <span class="emphasis"><em>cds</em></span> service.”</a>) consists of two GET requests and
two response payloads, one in XML and the ultimate one in JSON.
</li></ul></div><div class="example"><a id="cds_picture"></a><p class="title"><b>Example 21. The composed <span class="emphasis"><em>cds</em></span> service.</b></p><div class="example-contents"><pre class="screen">   +---------+   GET    +---------+   GET    +-----------+
   | jQuery  |---------&gt;|   cds   |---------&gt;|    W3C    |
   | script  |&lt;---------| service |&lt;---------|  service  |
   +---------+   JSON   +---------+   XML    +-----------+
     browser              server               W3C server</pre></div></div><br class="example-break" /><p>Perhaps the best way to clarify the architecture is to start with the jQuery client, which expects
the data to come in JSON format. The catch is that the W3C service provides the data in XML format.
The intermediary <span class="emphasis"><em>cds</em></span> service takes on the job of format converter.</p><div class="example"><a id="jquery_cds"></a><p class="title"><b>Example 22. The jQuery RESTful client embedded in an HTML page.</b></p><div class="example-contents"><pre class="screen">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;JSON&lt;/title&gt;
    &lt;script type = "text/javascript"
            src = "http://code.jquery.com/jquery-latest.min.js"&gt;
    &lt;/script&gt;
    &lt;script type = "text/javascript"&gt;
      $.getJSON('http://localhost:8080/cds/getCDs.jsp', function(response) {
         var cds = response.catalog.cd;
         alert(JSON.stringify(cds));
         $.each(cds, function(ind, val) {                                      <a id="CO1-79"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
             $('#container').append('&lt;li&gt;' + cds[ind].title + ': ' +           <a id="CO1-80"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                                             cds[ind].artist + '&lt;/li&gt;'); } );  <a id="CO1-81"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul id = 'container'&gt;&lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><br class="example-break" /><p>The HTML page with the embedded jQuery (see <a class="xref" href="#jquery_cds" title="Example 22. The jQuery RESTful client embedded in an HTML page.">Example 22, “The jQuery RESTful client embedded in an HTML page.”</a>) is short and the embedded jQuery is likewise
terse compared to the
earlier Twitter sample (see <a class="xref" href="#twitter" title="Example 20. A JSONP call against the RESTful Twitter search.">Example 20, “A JSONP call against the RESTful Twitter search.”</a>). The current example shows a jQuery shortcut method, in this
example <code class="literal">getJSON</code>, that can used in place of the generic jQuery <code class="literal">ajax</code> method.
Of particular interest here, however, is that the jQuery code does not parse the
JSON document returned from the RESTful service but, rather, treats the JSON document as a native
JavaScript array. In the body of the <code class="literal">each</code> iteration (line 1), for example, the jQuery extracts
the title and the artist in CD using regular JavaScript syntax:</p><pre class="screen">cds[ind].title  /* line 2: ind is the index into the array */
cds[ind].artist /* line 3 */</pre><p>No parsing is required.</p><p>In the composed <span class="emphasis"><em>cds</em></span> service, the W3C service is the ultimate data source.
The other service, which consists of the very short JSP script <span class="emphasis"><em>getCDs.jsp</em></span> (see <a class="xref" href="#jsp_script" title="Example 23. The getCDs.jsp script in the cds service.">Example 23, “The <span class="emphasis"><em>getCDs.jsp</em></span> script in the <span class="emphasis"><em>cds</em></span> service.”</a>) and the back-end POJO class
<code class="literal">FetchXML</code> (see <a class="xref" href="#backend_pojo" title="Example 24. The back-end POJO class FetchXML and its getJson method.">Example 24, “The back-end POJO class <code class="literal">FetchXML</code> and its <code class="literal">getJson</code> method.”</a>), is the fetch-and-convert module: a jQuery client hits the JSP script, which
returns JSON from the <code class="literal">FetchXML</code> instance method <code class="literal">getJson</code>; and the JSON is the result of
transforming XML from the W3C service into JSON.</p><div class="example"><a id="jsp_script"></a><p class="title"><b>Example 23. The <span class="emphasis"><em>getCDs.jsp</em></span> script in the <span class="emphasis"><em>cds</em></span> service.</b></p><div class="example-contents"><pre class="screen">&lt;jsp:useBean id    = "fetcher"
             type  = "cds.FetchXML"
             class = "cds.FetchXML"&gt;
&lt;/jsp:useBean&gt;
&lt;jsp:getProperty name = "fetcher" property = "json" /&gt; <a id="CO1-82"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" /></pre></div></div><br class="example-break" /><p>When a client request hits the <span class="emphasis"><em>getCDs.jsp</em></span> script (technically, the servlet instance into which this
JSP script is ultimately transformed), the client gets in response the value returned from the
<code class="literal">FetchXML</code> method <code class="literal">getJson</code>, named in the JSP script as the property <code class="literal">json</code> (line 1).</p><div class="example"><a id="backend_pojo"></a><p class="title"><b>Example 24. The back-end POJO class <code class="literal">FetchXML</code> and its <code class="literal">getJson</code> method.</b></p><div class="example-contents"><pre class="screen">package cds;

import org.json.JSONObject;
import org.json.XML;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

public class FetchXML {
    public void setJson(String json) { }
    public String getJson() {
        JSONObject json = null;
        try {
            // Fetch the XML document from the W3C site.
            String xml = "";
            URL url = new URL("http://www.w3schools.com/xml/cd_catalog.xml");     <a id="CO1-83"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            URLConnection conn  = url.openConnection();                           <a id="CO1-84"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            BufferedReader in =
                new BufferedReader(new InputStreamReader(conn.getInputStream()));
            // Read the document records.
            String line = null;
            while ((line = in.readLine()) != null) xml += line;                   <a id="CO1-85"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            in.close();
            xml = xml.replace("'", ""); // Clean up the XML.                      <a id="CO1-86"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            // Transform the XML document into a JSON object.
            json = XML.toJSONObject(xml.toLowerCase());                           <a id="CO1-87"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
        }
        catch(Exception e) { throw new RuntimeException(e); }
        return json.toString(); // JSON document                                  <a id="CO1-88"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">FetchXML</code> method <code class="literal">getJson</code> uses a <code class="literal">URLConnection</code> (line 2) to communicate with the
W3C service at the designated URL (line 1). The W3C service returns the CD list as an XML document,
which the <code class="literal">FetchXML</code> instance reads line by line (line 3). For readability, the
XML document is converted to lower case and otherwise cleaned up (lines 4 and 5) before being
converted into a JSON document (line 6), which is returned to the jQuery script. A
JSON library deployed in the WAR file converts the XML to JSON; and the jQuery
script, which invokes the composed RESTful service to begin, benefits from
receiving JSON rather than XML. If the jQuery script dealt directly with the W3C service, then
this script would take on the task of either parsing the returned XML document or transforming
the XML into JSON.</p></div><div class="section" title="1.9.3. An Ajax Polling Example"><div class="titlepage"><div><div><h4 class="title"><a id="_an_ajax_polling_example"></a>1.9.3. An Ajax Polling Example</h4></div></div></div><p>The JAX-RS <span class="emphasis"><em>predictions3</em></span> web service in Chapter 2 supports all of the CRUD operations, which means that the resource
can change state over time. How should clients against this RESTful service keep abreast of the changes? Two general
ways are available:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The service itself might maintain a list of connected clients and automatically
<span class="emphasis"><em>push</em></span> to these clients any changes in the resource.
</li><li class="listitem">
The clients might periodically poll the service with
GET request and thereby <span class="emphasis"><em>pull</em></span> the current representation of the resource.
</li></ul></div><p>The example in this section illustrates the
second approach with a jQuery client that continually polls the <span class="emphasis"><em>predictions3</em></span> service with GET requests for a JSON
response. The <span class="emphasis"><em>predictions3</em></span> service is unchanged from Chapter 2.</p><div class="example"><a id="poll_client"></a><p class="title"><b>Example 25. The <span class="emphasis"><em>poll.html</em></span> page with jQuery to poll the <span class="emphasis"><em>predictions3</em></span> service.</b></p><div class="example-contents"><pre class="screen">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Ajax olling example&lt;/title&gt;
    &lt;script type = "text/javascript"
            src  = "http://code.jquery.com/jquery-latest.min.js"&gt;
    &lt;/script&gt;
    &lt;script type = "text/javascript"&gt;
      var url = 'http://localhost:8080/predictions3/resourcesP/json';
      function displayPreds(preds) {
         $('#container').empty(); // clear the old list, if any
         $.each(preds, function(ind, val) {
              $('#container').append('&lt;li&gt;' + preds[ind].who + ': ' +
                                              preds[ind].what + '&lt;/li&gt;'); } );
      }
      function fetch() {
          $.ajax({                                                                <a id="CO1-89"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
                   url:         url,
                   method:      'GET',                                            <a id="CO1-90"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
                   dataType:    'json',
                   contentType: "application/json; charset=utf-8",
                   cache:       false,
                   success:     function(res) { displayPreds(res.predictions); },
                   error:       function(res) { console.log(res); },
                   complete:    function () {                                     <a id="CO1-91"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                                   setTimeout(function() { fetch() }, 5000)}});   <a id="CO1-92"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
      }
      $(document).ready(fetch); // invoked after DOM is built and loaded          <a id="CO1-93"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul id = 'container'&gt;&lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><br class="example-break" /><p>The HTML page <span class="emphasis"><em>poll.html</em></span> (see <a class="xref" href="#poll_client" title="Example 25. The poll.html page with jQuery to poll the predictions3 service.">Example 25, “The <span class="emphasis"><em>poll.html</em></span> page with jQuery to poll the <span class="emphasis"><em>predictions3</em></span> service.”</a>) embeds a jQuery script that continually polls
the <span class="emphasis"><em>predictions3</em></span> service. The workhorse function is <code class="literal">fetch</code> (line 1), which makes an
Ajax call against the RESTful <span class="emphasis"><em>predictions3</em></span>
service. The URL ends with <code class="literal">/json</code>, which signals that the response should be JSON rather
than XML or plain text. As the key named <code class="literal">method</code> and its value indicate (line 2), the Ajax call is
essentially a GET request. This example thus goes back to the generic <code class="literal">ajax</code> call rather than
a shortcut call such as <code class="literal">getJSON</code>.</p><p>The Ajax request from <code class="literal">fetch</code> has two possible outcomes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
If the request succeeds, then the predictions are displayed on the HTML page as elements in an unordered list.
</li><li class="listitem">
If the request fails, the response message is logged.
</li></ul></div><p>In either case, the <code class="literal">complete</code> key (line 3) has as its value a function (lines 4 and 5) that invokes
the jQuery <code class="literal">setTimeout</code> function; and the <code class="literal">setTimeout</code> function pauses for 5 seconds before
invoking <code class="literal">fetch</code> yet again. The <code class="literal">complete</code> function executes <span class="emphasis"><em>after</em></span> either the <code class="literal">success</code>
or the <code class="literal">error</code> function has executed. The jQuery script thus polls the <span class="emphasis"><em>predictions3</em></span> service repeatedly, with
brief pauses in-between each polling operation; and the <span class="emphasis"><em>poll.html</em></span> page displays, to within
five seconds or so, the current state of the <span class="emphasis"><em>predictions3</em></span> resource.</p><p>The deployed <span class="emphasis"><em>poll.html</em></span> page (see the sidebar) can be tested as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
The page can be displayed and thereby checked in a browser. If none of
the predictions has been deleted and no new one has been added, there should be 32
predictions in all, the last of which should be:
</p><pre class="screen">Hiram Gulgowski: Versatile tangible application will maximize...</pre></li><li class="listitem"><p class="simpara">
A <span class="emphasis"><em>curl</em></span> call then can be used, for example, to delete this prediction, whose
<code class="literal">id</code> is 32:
</p><pre class="screen">% curl --request DELETE localhost:8080/predictions3/resourcesP/delete/32</pre><p class="simpara">In about five seconds or so, the <span class="emphasis"><em>poll.html</em></span> page can be inspected again in the browser to
confirm that the Hiram Gulgowski prediction is gone. Similar <span class="emphasis"><em>curl</em></span> tests involving
POST and PUT requests should have the expected impact on the browser-displayed
<span class="emphasis"><em>poll.html</em></span>.</p></li></ul></div><div class="sidebar" title="Why deploy the poll.html page as a one-page web site?"><p class="title"><b>Why deploy the <span class="emphasis"><em>poll.html</em></span> page as a one-page web site?</b></p><p>The ZIP file with the sample code includes a simple web site (<span class="emphasis"><em>ch3/poll</em></span>) consisting of two
files, <span class="emphasis"><em>poll.html</em></span> and <span class="emphasis"><em>web.xml</em></span>. The site can be deployed in the usual way:</p><pre class="screen">% ant -Dwar.name=ajax deploy</pre><p>After deployment, a browser hits the site with the URL</p><pre class="screen">http://localhost:8080/ajax/</pre><p>It is tempting to avoid the deployment altogether and, instead, load the local file
<span class="emphasis"><em>poll.html</em></span> into the browser with a URL such as</p><pre class="screen">file:///home/kalin/jwsur2/ch3/poll/poll.html</pre><p>In some browsers, this may be alright but in others (for example, Chrome) the
<span class="emphasis"><em>same origin policy</em></span>, discussed earlier with respect to JSONP, comes into play. In
the case of Chrome, even two local files in the same directory are treated as
having different origins. The upshot is that Ajax calls in an HTML page such as
<span class="emphasis"><em>poll.html</em></span> should be tested by deploying the page as part of a web site.
Accordingly, the <span class="emphasis"><em>poll.html</em></span> page is deployed in the
<span class="emphasis"><em>ajax.war</em></span> file and a browser is then directed to this WAR file.</p></div><p>The Ajax polling example, like the earlier <span class="emphasis"><em>cds</em></span> service, shows the benefit that a
jQuery or other JavaScipt client enjoys from a JSON response. In the polling example,
the <code class="literal">who</code> and the <code class="literal">what</code> attributes a JSON prediction are extracted
straightforwardly. Here, for review, is the code snippet that displays a prediction
as an HTML element in an unordered list:</p><pre class="screen">$('#container').append('&lt;li&gt;' + preds[ind].who + ': ' +
                        preds[ind].what + '&lt;/li&gt;'); } );</pre><p>In an expression such as</p><pre class="screen">preds[ind].who</pre><p><code class="literal">preds</code> refers to the JSON array,
<code class="literal">ind</code> is an integer index into this array, and <code class="literal">who</code> is a field in the JSON
representation of a JavaScript prediction object. The jQuery script can access the
information of interest in a natural way precisely because the script deals with
JSON rather than, say, XML.</p><p>JavaScript clients of RESTful web services, such as the jQuery clients illustrated in the three examples of
this section, are becoming increasingly popular. RESTful services are sufficiently flexible to generate
response payloads in whatever format a client prefers. In the case of JavaScript clients, the preferred
format is clear: JSON.</p></div></div><div class="section" title="1.10. What’s Next?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_8217_s_next"></a>1.10. What’s Next?</h3></div></div></div><p>The focus in the first three chapters has been on RESTful web services and their clients. The next
chapter turns to SOAP-based services delivered over HTTP(S), which can be viewed as a special case
of RESTful services. The normal request and response payloads in a SOAP-based service are
<span class="emphasis"><em>SOAP envelopes</em></span>, XML documents whose root element has a tag with <code class="literal">Envelope</code> as the local name. An
example is:</p><pre class="screen">&lt;soap:Envelope xmlns:soap = '...'&gt;
  ...
&lt;/soap:Envelope&gt;</pre><p>In a typical SOAP-based exchange, a client sends an <code class="literal">Envelope</code> to a service and gets an
<code class="literal">Envelope</code> in return. SOAP, like XML in general, is programming-language neutral; and any language
with the appropriate libraries can support
SOAP-based services and clients. At present, however, only Java and DotNet have strong support for
SOAP; the other language systems have spotty support at best.</p><p>There is much to be said for SOAP over HTTP. The HTTP handles the transport and, in the case of HTTPS,
addresses major wire-level security concerns. The SOAP libraries on the service and the client
side typically hide the SOAP, although the SOAP is available to inspect or even manipulate
if a service or a client requires this. Chapter 4 looks at the service and the client sides of
SOAP-based services; and this look includes two SOAP-based clients against the Amazon E-Commerce service.
Chapter 5 then examines the <span class="emphasis"><em>handler level</em></span> in SOAP-based services. At the <span class="emphasis"><em>application level</em></span> in
SOAP-based services, the SOAP itself is transparent; at the <span class="emphasis"><em>handler level</em></span>, the SOAP is exposed for
examination and manipulation.</p></div></div></div></body></html>

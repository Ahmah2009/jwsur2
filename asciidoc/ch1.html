<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#jwsur_2nd_chapter_1">1. Web Services Quickstart</a></span></dt><dd><dl><dt><span class="section"><a href="#_what_are_web_services">1.1. What Are Web Services?</a></span></dt><dt><span class="section"><a href="#_web_service_miscellany">1.2. Web Service Miscellany</a></span></dt><dt><span class="section"><a href="#_what_good_are_web_services">1.3. What Good are Web Services?</a></span></dt><dt><span class="section"><a href="#_web_services_and_service_oriented_architecture">1.4. Web Services and Service Oriented Architecture</a></span></dt><dt><span class="section"><a href="#_a_very_short_history_of_web_services">1.5. A Very Short History of Web Services</a></span></dt><dt><span class="section"><a href="#_what_is_rest">1.6. What is REST?</a></span></dt><dt><span class="section"><a href="#_review_of_http_requests_and_responses">1.7. Review of HTTP Requests and Responses</a></span></dt><dt><span class="section"><a href="#_http_as_an_api">1.8. HTTP as an API</a></span></dt><dt><span class="section"><a href="#_a_first_restful_example">1.9. A First RESTful Example</a></span></dt><dt><span class="section"><a href="#_why_use_servlets_for_restful_web_services">1.10. Why Use Servlets for RESTful Web Services?</a></span></dt><dt><span class="section"><a href="#_what_8217_s_next">1.11. What’s Next?</a></span></dt></dl></dd></dl></div><div class="section" title="1. Web Services Quickstart"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="jwsur_2nd_chapter_1"></a>1. Web Services Quickstart</h2></div></div></div><div class="section" title="1.1. What Are Web Services?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_are_web_services"></a>1.1. What Are Web Services?</h3></div></div></div><p>Although the term <span class="emphasis"><em>web service</em></span> has various, imprecise, and evolving meanings,
a working definition should be enough for the upcoming code example, which consists
of a service and a client, also known as a consumer or requester. As the name suggests,
a web service is a kind of webified application, that is, an application typically
delivered over HTTP (HyperText Transport Protocol). HTTPS (HTTP Secure) adds a security
layer to HTTP; hence, a service delivered over HTTPS likewise counts as web service. Until the
main topic of interest is web service security, HTTP should be understood to include HTTPS.</p><p>Amazon, a pioneer in web services, is well-known for its various web sites, among which
is the E-Commerce site for shopping. Amazon has other popular web sites as well. Of interest here
is that the data and functionality available at Amazon web sites are likewise available as
Amazon web services. For example, someone can use a browser to shop interactively at the Amazon E-Commerce site; but
this person also could write a program, as later examples show, to do the shopping through the corresponding
Amazon E-Commerce web service. Amazon is particularly good at pairing off its web sites with web services.</p><p>Web services
can be programmed a variety of languages, old and new.
The obvious way to publish a web service is with a web server; and a web service
client needs to execute on a machine that has network access, usually over HTTP, to the
web server. In more technical
terms, a web service is a distributed software system whose components can be deployed and executed on physically
distinct devices. Consider, for example, a web server <span class="emphasis"><em>host1</em></span> that hosts a web service and a mobile device <span class="emphasis"><em>host2</em></span>, which
hosts an application that issues
requests against the service on <span class="emphasis"><em>host1</em></span> (see Figure 1-1).
Web services may be more architecturally more complicated than this, of course; for one thing, a service may
have many clients issuing requests against it and the service itself may be composed of other services.
For instance, a stock-picking web service might consist of several code components,
each hosted on a separate commercial-grade web server; and any mix of PCs, handhelds, and other
networked devices might host programs that consume the service. Although the building blocks of web services
are relatively simple, the web services themselves can be arbitrarily complex.</p><p title="Figure 1-1. A web service and one of its clients."><a id="fig1_1"></a><b>Figure 1-1. A web service and one of its clients. </b>
</p><pre class="screen">   +---------+    HTTP request     +---------+
   |   web   |&lt;--------------------| service |
   | service |--------------------&gt;| client  |
   +---------+    HTTP response    +---------+
  host1: server                 host2: mobile device</pre><p title="Figure 1-1. A web service and one of its clients.">
</p><p>An HTTP request goes, by definition, from client to server; and an HTTP response goes, also
by definition, from server to client. For web services over HTTP, the HTTP messages are the
infrastructure; and these HTTP messages can be combined into basic conversational
patterns that characterize a web service. For example, if the web service conversation starts with an HTTP request that
expects an HTTP response, the pattern is the familiar <span class="emphasis"><em>request/response</em></span> conversation.
By contrast, if the
conversation starts with an HTTP message from the server, a message that expects a message from
the client in return, then the pattern is <span class="emphasis"><em>solicit/response</em></span>. Richer conversational patterns can
be composed out of such basic two-message patterns. Indeed, these two-message patterns are composed of
even more primitive ones: a message from client to server without a response is
a pattern known as <span class="emphasis"><em>one-way</em></span>; and the reverse pattern, from server to client without a
client response, is known as <span class="emphasis"><em>notification</em></span>. Web services tend to be simple in structure. The four
conversational patterns enumerated just now cover most modern web services; and request/response is
the pattern that still dominates.</p><p>Web services come in two popular flavors: SOAP-based and REST-style. SOAP is an XML dialect with
a grammar that specifies the structure that a document must have in order to count as SOAP. In a
typical SOAP-based service, the client sends SOAP messages to the service and the service
responds in kind, that is, with SOAP messages. REST-style services are hard to characterize in a
sentence or two but, with respect to pattern, these services tend to be request/response; and the same holds
for SOAP-based services. For now, a REST-style service is one that treats HTTP
not only as transport infrastructure also but as a set of guidelines for designing service requests
and service responses. In a REST-style service, HTTP itself can be seen as an API. SOAP has standards, tool-kits, and
bountiful software libraries. REST has no
official standards, comparatively few tool-kits, and uneven software libraries among programming languages. Yet there is growing
support for REST-style services across programmings languages; hence, it seems only a matter of time until
tool-kits and libraries for REST-style services mature.</p><p>From an historical perspective, the
RESTful approach to web services can be viewed as an antidote to the creeping complexity of SOAP-based web services.
SOAP-based services are designed to be transport neutral; as a result, SOAP messaging may seem overly complicated
if the transport is, in fact, HTTP.
This book covers SOAP-based and REST-style web services, starting with REST-style ones. This chapter
ends with a sample REST-style service and sample client calls against the service.
At present, the distinction between the two flavors of web service is not sharp because a SOAP-based service delivered over
HTTP can be seen as a special case of a REST-style service; and HTTP remains the dominant transport for
SOAP-based services.</p><p>SOAP originally stood for Simple Object
Access Protocol and then, by serendipity but never officially, might have stood for Service
Oriented Architecture (SOA) Protocol. (SOA is discussed in Section 1.4.)
The World Wide Web Consortium (hereafter, W3C) currently
oversees SOAP; and SOAP officially is no longer an acronym.</p></div><div class="section" title="1.2. Web Service Miscellany"><div class="titlepage"><div><div><h3 class="title"><a id="_web_service_miscellany"></a>1.2. Web Service Miscellany</h3></div></div></div><p>Except in test mode, the client of either a SOAP-based or REST-style
service is rarely a web browser but, rather, usually an application without a
graphical user-interface. The client may be written in any language with
the appropriate support libraries. Indeed, a major appeal of web services
is language transparency: the service and its clients need not be written
in the same language. Language transparency is a key contributor to web service
interoperability, that is, the ability of web
services and their consumers to interact seamlessly despite differences in
programming languages, support libraries, operating systems, and hardware platforms.
To underscore this appeal, my examples use a mix of languages besides Java, among them
C#, JavaScript, and Perl. My sample clients in Java consume services written in languages other
than Java, indeed, sometimes in languages unknown.</p><p>There is no magic in language transparency, of course. If a
web service written in Java can have a Python or a Ruby consumer,
there must be an intermediary layer that handles the differences in data types
between the service and the client languages. XML technologies, which
support structured document interchange and processing, act as one such
intermediary level. Another intermediary level is JSON (JavaScript Object Notation).
XML and JSON are both data-interchange formats but JSON clearly has the upper hand
with data-receivers written in JavaScript because a JSON document is the
text representation of a native JavaScript object.
Web service clients are increasingly JavaScript programs embedded in
HTML documents and executing in a browser; and such clients process
JSON with less fuss than they do XML. Even among non-JavaScript clients, JSON has gained
in popularity; for one thing, JSON is more readable than XML because JSON has relatively less markup.
Chapter 2 illustrates various ways in which REST-style services can generate XML and
JSON payloads; then Chapter 3 focuses on consuming XML and JSON payloads from
RESTful web services. In SOAP-based services, XML remains the dominant format, although
the DotNet framework is especially good at giving JSON equal status.</p><p>Several features distinguish web services from other distributed
software systems. Here are three:</p><div class="variablelist"><dl><dt><span class="term">
Open infrastructure
</span></dt><dd>
Web services are deployed using industry-standard,
vendor-independent protocols and languages such as HTTP, XML, and JSON,
all of which are ubiquitous and well understood. Web services can
piggy-back on
networking, data formatting, security, and other infrastructures
already in place, which lowers entry costs and promotes
interoperability among services. Organizations that publish web sites
with production-grade web servers such as Apache2, IIS, and Nginx can
publish web services with these very web servers. Firewalls and other
security mechanisms that defend web sites thereby defend web services as well.
</dd><dt><span class="term">
Platform and language transparency
</span></dt><dd>
Web services and their clients can interoperate even if
written in different programming languages. Languages such as C,
C#, Go, Java, JavaScript, Perl, Python, Ruby, and others provide libraries,
utilities, and even frameworks in support of web services. Web services
can be published and consumed on various hardware platforms and under
different operating systems.
Web services are an excellent way to
integrate diverse software systems while allowing the  programmer to work in the
programmer’s language of choice. The web-service approach to software development is not to rewrite but,
rather, to integrate.
</dd><dt><span class="term">
Modular design
</span></dt><dd>
Web services are meant to be modular in design so that new
services can be composed out of existing ones.
Imagine, for example, an inventory-tracking
service integrated with an on-line ordering service to compose a
service that automatically orders the appropriate products in
response to inventory levels. Web services are the small software parts
out of which arbitrarily large systems can be built. A guiding principle in web-service design
is to begin with very simple service operations, essentially uncomplicated functions, and to
group these operations into services, which in turn can be orchestrated to work with other
services, and so on indefinitely.
</dd></dl></div></div><div class="section" title="1.3. What Good are Web Services?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_good_are_web_services"></a>1.3. What Good are Web Services?</h3></div></div></div><p>This obvious question has no simple answer but the benefits and promises of web
services can be clarified with examples. The first example underscores how the distinction
between <span class="emphasis"><em>web sites</em></span> and <span class="emphasis"><em>web services</em></span> continues to blur: the data and functionality available at one
can be available at the other. (One web framework that emphasizes the blurring is Rails, which is
discussed in more detail later.)
The second example focuses on how
web services can be used to integrate diverse software systems and to make legacy systems more
widely accessible.</p><p>A visit to a web site such as the Amazon E-Commerce site (<span class="emphasis"><em>www.amazon.com</em></span>) is often interactive:
a shopper uses a browser to search
the Amazon site for desired items, places some of these in a shopping cart, checks out the cart, finalizes the order with
a credit card or the equivalent, and receives a confirmation page and usually an email.
Pioneers in web services,
such as Amazon, expose the information and functionality of web sites through web services as well. Searching and shopping against
Amazon, as code examples in later chapters illustrate, are tasks that are automated readily because Amazon makes a point of
coordinating its web sites with its web services. In any case, here is a sketch of how a search-and-shop experience might be
automated.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
A shopper has a database table or even a simple text file, <span class="emphasis"><em>wishList.txt</em></span>, that contains items of interest
such as books, movies, or any other search-and-shop category that Amazon supports.
</li><li class="listitem">
The database table or text file, which acts as a wish list with constraints, provides pertinent information such as the ISBN number of
a desired book, the maximum price the shopper is willing to pay, the number of items to order, and so on.
</li><li class="listitem">
The shopper programs a client, in whatever language the shopper prefers, that reads the database table or text file,
opens a connection to Amazon, searches Amazon for
wish-list items, checks whether the items are available under the constraints in the wish-list, and orders the
items that meet the constraints.
</li><li class="listitem">
The client program checks an email account for the confirming email; and, if all goes well, the client places confirmation
information in a data store such as database table or another simple text file.
</li></ul></div><p>An interactive shopping experience thus gives way to an automated one. Of course, some shoppers derive as much pleasure from the
activity as from the outcome. The point is not that shopping should be automated but, rather, that web services open up this
possibility for many tasks, shopping included. At one time, <span class="emphasis"><em>HTML screen scraping</em></span> was a popular way to have applications
other than browsers hit a web site, download HTML documents, and then parse the HTML for its informational content. As more
sites follow the Amazon practice of exposing the same or, at least, nearly the same data and functionality as both web sites
and web services, this screen scraping becomes increasingly unnecessary.
Later chapters illustrate, with code examples, the close relationship between web sites and web services.</p><p>The second example of what makes web services attractive focuses on a major challenge in modern software development:
systems integration. Modern
software systems are written in a variety of languages, a variety that
seems likely to increase. These software systems will continue to be
hosted on a variety of platforms. Institutions large and small have
significant investment in legacy software systems whose functionality is
useful and perhaps mission critical; and few of these institutions have
the will and the resources, human or financial, to rewrite their legacy
systems. How are such disparate software systems to interact? That these
systems must interact is taken for granted nowadays; it is a rare software
system that gets to run in splendid isolation.</p><p>A challenge, then, is to have a software system interoperate with others,
which may reside on different hosts under different operating systems and be written in different
languages. Interoperability is not just a long-term challenge but also a
current requirement of production software. Web services provide a
relatively simple answer to question of how diverse software systems,
written in many languages and executing on various platforms under
different operating systems, can interoperate. In short, web services are
an excellent way to integrate software systems.</p><p>Web services address the problem of interoperability directly because such services
are, first and foremost, language and platform neutral. If a legacy
COBOL system is exposed through a web service, the system is thereby
interoperable with service clients written in other, currently more
widely used languages. Exposing a legacy COBOL system as a web service should be
significantly less expensive than, say, rewriting the system from scratch. Legacy
database systems are an obvious source of data and functionality; and these systems, too,
can be made readily accessible, beyond the local machine that hosts the database,
through web services.</p><p title="Figure 1-2. A web service as the front-end of a datastore."><a id="web_service_data_store"></a><b>Figure 1-2. A web service as the front-end of a datastore. </b>
</p><pre class="screen">                   +-------------+            +----------+
         API calls |  Front-end  |            | Database |
clients&lt;----------&gt;| web service |&lt;----------&gt;| system   |
                   +-------------+            +----------+</pre><p title="Figure 1-2. A web service as the front-end of a datastore.">
</p><p>In the past, data sources for applications were usually <span class="emphasis"><em>data stores</em></span> such as relational database management
systems (RDBMS) or even local file systems. Nowadays web services also serve as data sources, at least
as intermediate ones that are backed up ultimately with persistent data stores.
Indeed, web services integrate
readily with RDBMS and other data-storage systems as front-ends that are easier conversational partners than the
data-storage systems themselves—because web services, at least well-designed ones, have APIs that
publish their functionality in high-level, language-neutral, and platform-independent terms.
A web service thus can be viewed as uniform access mechanism for divergent data stores.
A web service can act as the front-end of a database system, a front-end that
exposes, through a published API, the data and the functionality of the database system (see Figure 1-2).</p><p>Web services are inherently distributed systems that communicate mostly over HTTP but
can communicate over other popular transports as well. The communication payloads of web services
are typically structured text, usually XML or JSON documents, which can be inspected,
transformed, persisted, and otherwise processed with widely and even
freely available tools. When efficiency demands it, however, web
services also can deliver compact binary payloads. Finally, web services are a
work in progress with real-world distributed systems as their test bed.
For all of these reasons, web services are an essential tool in any
modern programmer’s toolbox.</p><p>The examples that follow, in this and later chapters, are
simple enough to isolate critical features of web services such as security
but also realistic enough to illustrate the power and flexibility that
such services bring to software development. The main service examples have an accompanying Ant
script to compile and then publish the web service on a production-grade web server
such as Tomcat or Jetty; and many of the Java clients against web services are packaged as
executable JAR files in order to reduce hassle.</p><p>As noted earlier, web services come in different flavors, SOAP-based and REST-style. SOAP and
SOA, although related, remain distinct. The next section goes into detail about the relationship
between SOA and web services, REST-style and SOAP-based.</p></div><div class="section" title="1.4. Web Services and Service Oriented Architecture"><div class="titlepage"><div><div><h3 class="title"><a id="_web_services_and_service_oriented_architecture"></a>1.4. Web Services and Service Oriented Architecture</h3></div></div></div><p>Web services and <span class="emphasis"><em>service-oriented architecture</em></span> (hereafter, SOA) are related but distinct.
SOA, like REST, is more an architectural style—indeed, a mindset—than a body of
precisely defined rules for the design and implementation of distributed systems; and web services are a
natural, important way to provide the services at the core of any SOA system. A fundamental idea in
SOA is that an application results from integrating network-accessible services, which are
interoperable because each has an interface that clearly defines the operations encapsulated in the
service: per operation, the interface specifies the number and type of each argument
passed to the service operation together with the number and type of values returned from each service
operation. The very point of a service interface is to publish the invocation syntax of each operation
encapsulated in the service. One attraction of the SOA approach is that the ultimate building blocks of
even large, complicated systems are structurally simple components; and this simplicity at the base level
makes it relatively easy to test, debug, deploy, extend, and otherwise maintain
a software system.</p><p>In an SOA system, services as building-block components may be characterized as <span class="emphasis"><em>unassociated</em></span> and
<span class="emphasis"><em>loosely coupled</em></span>. Consider, for example, two primitive services <span class="emphasis"><em>S<sub>1</sub></em></span> and <span class="emphasis"><em>S<sub>2</sub></em></span> in an SOA application. The
two services are <span class="emphasis"><em>unassociated</em></span> in that neither <span class="emphasis"><em>S<sub>1</sub></em></span> nor <span class="emphasis"><em>S<sub>2</sub></em></span> depends on the other: <span class="emphasis"><em>S<sub>1</sub></em></span>
is not required to use <span class="emphasis"><em>S<sub>2</sub></em></span> or vice-verse.
The services are mutually independent but can be used together or orchestrated as parts of
a larger software system. Following the same theme, components such as <span class="emphasis"><em>S<sub>1</sub></em></span> and <span class="emphasis"><em>S<sub>2</sub></em></span> are <span class="emphasis"><em>loosely coupled</em></span>
in that neither needs to know anything about the internal structure of the other in order for both of these services to
work together as parts of a larger distributed system. A persistent theme in the many discussions of SOA is
the modularity of SOA-based systems.</p><p>At the implementation level, a service operation is a function call: the function takes zero or more arguments and
returns zero or more values. Although functions in many languages such as C and even Java technically return, at most, only a
single value and therefore must resort to an aggregate data structures such as a lists to return multiple values, newer languages
such as Go have uncomplicated syntax for functions to return arbitrarily many values including, of course, none. This fact underscores the
inherent richness and flexibility of the function as a system building-block. Programmers fluent in virtually an language
are thereby knowledgeable about the syntax and semantics of functions.</p><p>In an SOA system, a very simple service may consist of a single function.
The implementation model is thus uncomplicated and familiar to programmers; and
the simplicity of service operations promotes code reuse through the composition of new services out of
existing ones. This ground-level simplicity also enables relatively straightforward troubleshooting because services reduce to
primitive function calls. An SOA system can be quite complicated, of course, but the complication arises from
the composition and not from the simple services into which the system ultimately decomposes.</p><p>Web services are well suited as components in an SOA system. Following best practices, a web service should
consist of operations, each of which is implemented as a stateless function call: the call is <span class="emphasis"><em>stateless</em></span>
in that the return value(s) depend only on the arguments passed to the call. In an object-oriented language such
as a Java, a well-designed web service is a class that has instance methods as service operations but no
instance fields that impact the value returned from a particular method. In practice, <span class="emphasis"><em>statelessness</em></span> is
easier said than done, as the many examples in this book illustrate. In the context of SOA, it is
common to distinguish between <span class="emphasis"><em>providers</em></span> and <span class="emphasis"><em>consumers</em></span> of web services: the provider furnishes the service’s
functionality and the consumer is a client that issues requests against the service’s operations. The
provider/consumer pair is commonly used to describe web services and their clients, respectively.</p><p>Perhaps the best way to clarify SOA in the concrete is to contrast this approach to distributed systems with a quite different
approach, DOA (Distributed Object Architecture). Web services came to fore as a reaction against the
complexity of DOA systems. The next section provides a short history of web services,
with emphasis on the kinds of software challenges that web services are meant to address.</p></div><div class="section" title="1.5. A Very Short History of Web Services"><div class="titlepage"><div><div><h3 class="title"><a id="_a_very_short_history_of_web_services"></a>1.5. A Very Short History of Web Services</h3></div></div></div><p>Web services evolved from the RPC (Remote Procedure Call) mechanism in
DCE (Distributed Computing Environment), a framework for software development
from the early 1990s. DCE includes a distributed file system
(DCE/DFS) and a Kerberos-based authentication system. Although DCE has its
origins in the Unix world, Microsoft quickly did its own implementation
known as MSRPC, which in turn served as the infrastructure for interprocess communication in Windows.
Microsoft’s COM/OLE (Common Object Model/Object Linking and Embedding) technologies and services
were built on a DCE/RPC foundation. There is irony here. DCE designed RPC as a way to do
distributed computing, that is, computing across distinct physical devices; and Microsoft cleverly
adapted RPC to support interprocess communication, in the form of COM infrastructure, on a single
device—a PC running Windows.</p><p>The first-generation frameworks for distributed-object systems,
CORBA (Common Object Request Broker Architecture) and Microsoft’s DCOM (Distributed COM), are anchored
in the DCE/RPC procedural framework. Java RMI (Remote Method Invocation) also derives from DCE/RPC; and the
method calls in Java EE (Enterprise Edition), specifically in Session and Entity EJBs (Enterprise Java Bean),
are Java RMI calls. Java EE (formerly J2EE) and Microsoft’s DotNet are second-generation frameworks for
distributed-object systems; and these frameworks, like CORBA and DCOM before them, trace
their ancestry back to DCE/RPC. By the way, DCE/RPC is not dead. Various popular system utilities (for
instance, the Samba file and print service for Windows clients) use DCE/RPC.</p><div class="section" title="1.5.1. From DCE/RPC to XML-RPC"><div class="titlepage"><div><div><h4 class="title"><a id="_from_dce_rpc_to_xml_rpc"></a>1.5.1. From DCE/RPC to XML-RPC</h4></div></div></div><p>DCE/RPC has the familiar client/server architecture in which a
client invokes a procedure that executes on the server. Arguments can be
passed from the client to the server and return values can be passed from
the server to the client. The framework is platform and language neutral in principle,
although strongly tilted towards C in practice. DCE/RPC includes
utilities for generating client and server artifacts (stubs and skeletons,
respectively). DCE/RPC also provides software libraries that hide the transport details. Of
interest now is the IDL (Interface Definition Language) document that acts as the
service contract and is an input to utilities that generate artifacts in support
of the DCE/RPC calls. An IDL document can be short and to the point (see <a class="xref" href="#Ex_idl" title="Example 1. A sample IDL document that declares the echo function.">Example 1, “A sample IDL document that declares the <code class="literal">echo</code> function.”</a>).</p><div class="example"><a id="Ex_idl"></a><p class="title"><b>Example 1. A sample IDL document that declares the <code class="literal">echo</code> function.</b></p><div class="example-contents"><pre class="screen">/* echo.idl */
[uuid(2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]
interface echo {
    const long int ECHO_SIZE = 512;
    void echo(
        [in]             handle_t h,
        [in,  string]    idl_char from_client[ ],
        [out, string]    idl_char from_server[ECHO_SIZE]
    );
}</pre></div></div><br class="example-break" /><p>The IDL interface named <code class="literal">echo</code>, identified with a machine-generated UUID (Universally Unique IDentifier),
declares a single function with the same name, <code class="literal">echo</code>. The names are arbitrary and need not be the same.
The <code class="literal">echo</code> function expects three arguments, two of which are
<code class="literal">in</code> parameters (that is, inputs into the remote procedure) and one of which is an <code class="literal">out</code> parameter (that
is, an output from the remote procedure). The first argument, of built-in
type <code class="literal">handle_t</code>, is required and points to an RPC data structure. The function <code class="literal">echo</code> could but does
not return a value because the echoed string is returned instead as an <code class="literal">out</code> parameter. The IDL specifies
the invocation syntax for the <code class="literal">echo</code> function, which is the one and only operation in the service.
Except for annotations in square brackets to the left of the three <code class="literal">echo</code> parameters, the syntax of the
IDL is essentially C syntax. The
IDL document is a precursor of the WSDL (Web Service Definition Language) document that provides a
formal specification of a web service and its operations. The WSDL document is discussed at length in
Chapter 4 on SOAP-based services.</p><p>There is a Microsoft twist to the IDL story as well. An ActiveX control under Windows is a
DLL (Dynamic Link Library) with an embedded <span class="emphasis"><em>typelib</em></span>, which in turn is a compiled IDL file. For
example, suppose that a calendar ActiveX control is plugged into a browser. The browser can read the
<span class="emphasis"><em>typelib</em></span>, which contains the invocation syntax for each operation (<span class="emphasis"><em>e.g.</em></span>, displaying the next month)
in the control. An ActiveX control is thus a chunk of software that embeds its own interface.
This is yet another inspired local use of a technology designed for distributed computing.</p><p>In the late 1990s, Dave Winer of UserLand Software developed XML-RPC, a technology innovation that has
as good a claim as any to mark
the birth of web services. XML-RPC is a very lightweight RPC system with support for
elementary data types (basically, the built-in C types together with a
<code class="literal">boolean</code> and a <code class="literal">datetime</code> type) and a few simple commands. The original specification is about seven
pages in length. The two key features are the use of XML marshaling/unmarshaling
to achieve language neutrality and reliance on HTTP (and, later, SMTP)
for transport. The term <span class="emphasis"><em>marshaling</em></span> refers to the conversion of an in-memory object (for instance, an
<code class="literal">Employee</code> object in Java) to some other format (for instance, an XML document); and <span class="emphasis"><em>unmarshaling</em></span>
refers to the inverse process of generating an in-memory object from, in this example,
an XML document. The marshal/unmarshal distinction is somewhere between close to and identical
with the serialize/deserialize distinction. My habit is to use the distinctions interchangeably.
In any case, the O’Reilly open-wire Meerkat service and the WordPress publishing platform are based on
XML-RPC.</p><p>Two key differences separate XML-RPC, on the one side, from DCE/RPC and its off-shoots, on the other
side:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
XML-RPC payloads are text, whereas DCE/PRC payloads are binary. Text is relatively easy to inspect
and process with standard, readily available tools such as editors and parsers.
</li><li class="listitem">
XML-RPC transport uses HTTP rather than a proprietary system. To support XML-RPC, a programming language
requires only a standard HTTP library together with libraries to generate, parse, transform, and otherwise process
XML.
</li></ul></div><p>As an RPC technology, XML-RPC supports the request/response pattern. Here is the XML request to
invoke, on a remote machine, the Fibonacci function with an argument of 11. This
argument is passed as a four-byte integer, as the XML start tag <code class="literal">&lt;i4&gt;</code> indicates:</p><pre class="screen">&lt;?xml version="1.0"&gt;
&lt;methodCall&gt;
   &lt;methodName&gt;fib&lt;methodName&gt;
   &lt;params&gt;
     &lt;param&gt;&lt;value&gt;&lt;i4&gt;11&lt;/i4&gt;&lt;/value&gt;&lt;/param&gt;
   &lt;/params&gt;
&lt;/methodCall&gt;</pre><p>The integer 11 occurs in the XML-RPC message as text. An XML-RPC library on the receiving end needs to
extract 11 as text and then to convert the text into a 4-byte integer in the receiving language such as Go or Java.
Even this short example illustrates the idea of having XML—in particular, data types expressed in XML—serve
as the leveling mechanism between two different languages involved in an XML-RPC exchange.</p><p>XML-RPC is deliberately low fuss and lightweight. SOAP, an XML dialect derived
straight from XML-RPC, is considerably heavier in weight. From inception, XML-RPC faced
competition from second-generation DOA systems such as Java EE (J2EE) and AspNet.
The next section considers the challenges inherent in DOA systems, challenges that sustained and
eventually intensified interest in lighter-weight approaches to distributed computing—modern web services.</p></div><div class="section" title="1.5.2. Distributed Object Architecture: A Java Example"><div class="titlepage"><div><div><h4 class="title"><a id="_distributed_object_architecture_a_java_example"></a>1.5.2. Distributed Object Architecture: A Java Example</h4></div></div></div><p>What advantages do web services have over DOA technologies such as Java RMI? This section addresses the
question with an example. Java RMI (including the Session and Entity EJB constructs built on
Java RMI) and DotNet Remoting are examples of second-generation distributed
object systems. Consider what a Java RMI client requires in order to invoke a
method declared in a service interface such as this:</p><pre class="screen">import java.util.List;
public interface BenefitsService extends java.rmi.Remote {
   public List&lt;Benefit&gt; getBenefits(Emp emp) throws RemoteException;
}</pre><p>The interface appears deceptively simple in that it declares only the
method named <code class="literal">getBenefits</code>; yet the interface likewise hints at what makes
a distributed-object architecture so tricky.
A client against this <code class="literal">BenefitsService</code> requires a Java RMI stub, an instance
of a class that implements the <code class="literal">BenefitsService</code> interface. The stub is downloaded automatically
from the server to the client as part of the Java RMI set-up (see Figure 1-3).</p><p title="Figure 1-3. Downloading a stub in Java RMI."><a id="stub_download"></a><b>Figure 1-3. Downloading a stub in Java RMI. </b>
</p><pre class="screen">+------------+   BenefitsService stub download  +------------+
| RMI client |&lt;---------------------------------| RMI server |
+------------+                                  +------------+</pre><p title="Figure 1-3. Downloading a stub in Java RMI.">
</p><p>Once the stub set-up is done,
the <code class="literal">getBenefits</code> method then is executed as a stub method; that is, the stub acts as the
client-side object making a remote method call through one of stub’s encapsulated methods.
The call thus has the syntax:</p><pre class="screen">Emp fred = new Emp();
//...
List&lt;Benefit&gt; benefits = rmiStub.getBenefits(fred); // rmiStub = reference</pre><p>Invoking the <code class="literal">getBenefits</code> method
requires that the byte codes for various Java classes, standard and
programmer-defined, be downloaded to the client machine. To begin, the client
needs the class <code class="literal">Emp</code>, the argument type for the <code class="literal">getBenefits</code> method, and the class
<code class="literal">Benefit</code>, the member type for the <code class="literal">List</code> that the method <code class="literal">getBenfits</code> returns.
Suppose that the class <code class="literal">Emp</code> begins like this:</p><pre class="screen">public class Emp {
   private Department                   department;
   private List&lt;BusinessCertification&gt;  certifications;
   private List&lt;ClientAccount&gt;          accounts;
   private Map&lt;String, Contact&gt;         contacts;
   ...
}</pre><p>The standard Java types such as <code class="literal">List</code> and <code class="literal">Map</code> already are available on the client side because
the client is, by assumption, a Java application. The challenge involves the
additional, programmer-defined types such as <code class="literal">Department</code>,
<code class="literal">BusinessCertification</code>, <code class="literal">ClientAccount</code>, and <code class="literal">Contact</code> that are needed
to support the client-side invocation of a remotely executed method. The
set-up on the client side to enable a remote call such as</p><pre class="screen">Emp fred = new Emp();
// set properties, etc.
List&lt;EmpBenefits&gt; fredBenefits = rmiStub.getBenefits(fred);</pre><p>is significant, with lots and lots of bytes required to move from the server down to
the client just for the set-up. Anything this complicated is, of course, prone to problems such as
versioning issues and outright errors in the remote method calls.</p><p>Java RMI uses proprietary marshaling/unmarshaling and proprietary transport; and DotNet does the
same. There are third-party libraries for interoperability between the two frameworks. Yet a
Java RMI service can be expected to have mostly
Java clients; and a DotNet Remoting service can be expected to have mostly DotNet clients.
Web services represent a move towards standardization, simplicity, and
interoperability.</p></div><div class="section" title="1.5.3. Web Services to the Rescue"><div class="titlepage"><div><div><h4 class="title"><a id="_web_services_to_the_rescue"></a>1.5.3. Web Services to the Rescue</h4></div></div></div><p>Web services simplify matters in distributed computing. For one thing, the client and service typically
exchange XML or equivalent documents, that is, <span class="emphasis"><em>text</em></span>. If needed, non-text bytes can be exchanged
instead but the preferred payloads are text. The exchanged text can be inspected, validated,
transformed, persisted, and otherwise processed using readily available,
non-proprietary, and often free tools. Each side, client and service,
simply needs a local software library that binds language-specific types
such as the Java <code class="literal">String</code> to XML Schema or comparable
types, in this case <code class="literal">xsd:string</code>. (In the qualified name <code class="literal">xsd:string</code>, <code class="literal">xsd</code> is a namespace
abbreviation
and <code class="literal">string</code> is a local name. Of interest here is that <code class="literal">xsd:string</code> is an XML type rather
than a Java type.) Given these Java/XML bindings, relatively uncomplicated library modules can
convert from one to the other, that is, from Java to XML or from XML to
Java (see Figure 1-4).</p><p title="Figure 1-4. Java/XML conversions."><a id="fig_java_xml"></a><b>Figure 1-4. Java/XML conversions. </b>
</p><pre class="screen">                  +----------------+  XML   +-----------------+
non-Java types---&gt;| convert to XML |-------&gt;| convert to Java |---&gt;Java types
                  +----------------+        +-----------------+</pre><p title="Figure 1-4. Java/XML conversions.">
</p><p>Processing on the client side, as on the service side,
requires only locally available libraries and
utilities. The complexities, therefore, can be isolated at the endpoints—the service and the
client applications together with their supporting libraries—and need not
seep into the exchanged messages. Finally, web services are available over HTTP, a
non-propriety protocol that has become standard, ubiquitous infrastructure; and HTTP
in particular comes with a security extension, HTTPS, that provides multi-faceted security
services.</p><p>In a web service, the requesting client and the service need not be coded in
the same language or even in the same style of language. Clients and
services can be implemented in object-oriented, procedural, functional,
and other language styles. The languages on either end may be statically
typed (for instance, Java and Go) or dynamically typed (for example, JavaScript
and Ruby). The complexities of stubs and skeletons, the serializing and
deserializing of objects encoded in some proprietary format, gives way to relatively
simple text-based representations of messages exchanged over standard transports such
as HTTP. The messages themselves are neutral; they have no bias towards a particular
language or even family of languages.</p><p>The first code example in this chapter, and all of the code examples in Chapter 2 and
Chapter 3, involve REST-style services. Accordingly, the next section looks
at what REST means and why the REST-style service has become so popular. From an
historical perspective, REST-style services can be viewed as a reaction to the
growing complexity of SOAP-based ones.</p></div></div><div class="section" title="1.6. What is REST?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_is_rest"></a>1.6. What is REST?</h3></div></div></div><p>Roy Fielding (<span class="emphasis"><em>roy.gbiv.com</em></span>) coined the acronym REST in his PhD dissertation. The
acronym, which stands for REpresentational State Transfer, is clarified shortly.
Chapter 5 of Fielding’s dissertation lays out the guiding principles for what have come to be
known as REST-style or RESTful web services. Fielding has an impressive resume. He is, among
other things, a principal author of the HTTP 1.1 specification and a
co-founder of the Apache Software Foundation.</p><p>REST and SOAP are quite different. SOAP is a messaging protocol in which the messages
are XML documents, whereas REST is a style of software architecture for distributed
hypermedia systems, that is, systems in which text, graphics, audio, and
other media are stored across a network and interconnected through
hyperlinks. The World Wide Web is the obvious example of such a system. As
the focus here is on <span class="emphasis"><em>web</em></span> services, the World Wide Web is the
distributed hypermedia system of interest. In the web, HTTP is both a
transport protocol and a messaging system because HTTP requests and
responses are messages. The payloads of HTTP messages can be typed using
the MIME (Multipurpose Internet Mail Extension) type system. MIME has
types such as <code class="literal">text/html</code>, <code class="literal">application/octet-stream</code>, and <code class="literal">audio/mpeg3</code>.
HTTP also provides response status codes to inform
the requester about whether a request succeeded and, if not, why. Table 1-1
lists some common status codes.</p><div class="table"><a id="idp5711104"></a><p class="title"><b>Table 1. Sample HTTP status codes and their meanings</b></p><div class="table-contents"><table summary="Sample HTTP status codes and their meanings" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col /><col /><col /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Status code</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">In English</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>200</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>OK</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Request OK.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>303</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>See Other</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Redirect.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>400</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Bad Request</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Request malformed.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>401</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unauthorized</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Authentication error.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>403</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Forbidden</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Request refused.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>404</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Not Found</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Resource not found.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>405</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Method Not Allowed</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Method not supported.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>415</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unsupported Media Type</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Content type not recognized.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>500</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Internal Server Error</p></td><td style="" align="left" valign="top"><p>Request processing failed.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>REST stands for REpresentational State Transfer, which requires clarification because the
central abstraction in REST—the resource—does not
occur in the acronym. A <span class="emphasis"><em>resource</em></span> in the RESTful sense is something that is accessible
through HTTP because this thing has a name, a URI (Uniform Resource Identifier). A URI has
two subtypes: the familiar URL, which specifies a <span class="emphasis"><em>location</em></span>; and the URN, which is a
symbolic name but not a location.
URIs are <span class="emphasis"><em>uniform</em></span> because they must be structured in a certain way; there is a
syntax (<span class="emphasis"><em>tools.ietf.org/html/rfc3986</em></span>) for URIs.
In summary, a URI is a standardized name for a resource and, in this sense, a URI acts as noun.</p><p>In practical terms, a resource is a web-accessible, informational item that may have
hyperlinks to it. Hyperlinks use URIs to do the linking. Examples of
resources are plentiful but likewise misleading in suggesting that
resources must have something in common other than identifiability through
URIs. The gross national product of Lithuania is a resource as is
the Modern Jazz Quartet. Ernie Bank’s baseball accomplishments count as a
resource as does the maximum flow algorithm. The concept of a resource is
remarkably broad but, at the same time, impressively simple and
precise.</p><p>As web-based informational items, resources are pointless unless
they have at least one representation. In the web, representations are
MIME typed. The most common type of resource representation is probably
still <code class="literal">text/html</code> but nowadays resources tend to have
multiple representations. For example, there are various interlinked HTML
pages that represent the Modern Jazz Quartet but there are also audio and
audiovisual representations of this resource.</p><p>Resources have state. For example, Ernie Bank’s baseball
accomplishments changed during his career with the dismal Chicago Cubs from 1953
through 1971 and culminated in his 1977 induction into the Baseball Hall
of Fame. A useful representation must capture a resource’s state. For
example, the current HTML pages on Ernie at the Baseball Reference Web
site (<span class="emphasis"><em>www.baseball-reference.com</em></span>) need to
represent all of his major league accomplishments, from his rookie year in
1953 through his induction into the Hall of Fame.</p><p>A RESTful request targets a resource but the resource itself typically
is created on the service machine and remains there. A resource may be persisted in
a data store such as a database system. Some mix of humans and applications
may maintain the state of the resource. In the usual case of web-service access to
a resource, the requester receives a
representation of the resource if the request
succeeds. It is the representation that transfers from the service machine
to the requester machine. In a REST-style web service, a client does two things in
an HTTP request:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Names the targeted resource by giving its URI, typically as part of a URL.
</li><li class="listitem">
Specifies a <span class="emphasis"><em>verb</em></span> (HTTP method), which indicates what the client
wishes to do, for example, <span class="emphasis"><em>read</em></span> an existing resource, <span class="emphasis"><em>create</em></span> a new
resource from scratch, <span class="emphasis"><em>edit</em></span> an existing resource, or <span class="emphasis"><em>delete</em></span> an
existing resource.
</li></ul></div><p>One of the basic cases is a <span class="emphasis"><em>read</em></span> request. If a <span class="emphasis"><em>read</em></span> request succeeds, a
typed representation (for instance, <code class="literal">text/html</code>) of the
resource is transferred from the server that hosts and maintains the resource to the
client that issues the request. The client is an arbitrary application written in
some language with support for REST-style requests. The representation returned from
the service is a good one only if
the representation captures the resource’s state in some appropriate way. Figure 1-5 depicts a resource
with its identifying URI, together with a RESTful client and some typed
representations sent back to the client in response to client requests.</p><div class="figure"><a id="fig_ch1_rest"></a><p class="title"><b>Figure 1. A small slice of a RESTful system</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0401.png" alt="images/jwsu_0401.png" /></div></div></div><br class="figure-break" /><p>In summary, RESTful web services involve not just resources to
represent but also client-invoked operations on such resources. At the
core of the RESTful approach is the insight that HTTP, despite the
occurrence of Transport in its name, acts as an API and
not simply as a transport protocol. HTTP has its well-known
verbs, officially known as <span class="emphasis"><em>methods</em></span>. Table 2 lists the HTTP verbs that correspond to
the CRUD (Create, Read, Update, Delete)
operations so familiar throughout computing:</p><div class="table"><a id="idp5769408"></a><p class="title"><b>Table 2. HTTP verbs and their CRUD operations</b></p><div class="table-contents"><table summary="HTTP verbs and their CRUD operations" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col /><col /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">HTTP Verb</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">CRUD Operation</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>POST</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>GET</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Read</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>PUT</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Update</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>DELETE</p></td><td style="" align="left" valign="top"><p>Delete</p></td></tr></tbody></table></div></div><br class="table-break" /><p>Although HTTP is not case sensitive, the HTTP verbs are
traditionally written in uppercase. There are additional verbs. For
example, the verb HEAD is a variation on GET that requests only the HTTP
headers that would be sent to fulfill a GET request.</p><p>HTTP also has standard response codes such as 404 to signal that the
requested resource could not be found and 200 to signal that the request
was handled successfully. In short, HTTP provides request verbs and MIME
types for client requests and status codes (and MIME types) for service
responses.</p><p>Modern browsers generate only GET and POST requests. If a user enters a URL into the
browser’s input window, the browser generates a GET request. A
browser ordinarily generates a POST request for an HTML form with a <span class="emphasis"><em>submit</em></span>
button. It goes against the spirit of REST to treat GET and POST interchangeably. In
Java, for example, an <code class="literal">HttpServlet</code> instance has callback methods such
as <code class="literal">doGet</code> and <code class="literal">doPost</code> that handle GET
and POST requests, respectively. Each callback has the same parameter
types, the type <code class="literal">HttpServletRequest</code> (the key/value pairs from the
request) and the type <code class="literal">HttpServletResponse</code> (effectively a channel to communicate back to
the requester). It is not unknown for a programmer to have the two callbacks execute the same
code (for instance, by having one invoke the other), thereby conflating
the original HTTP distinction between <span class="emphasis"><em>read</em></span> and
<span class="emphasis"><em>create</em></span>. A key guiding principle of the RESTful style
is to respect the original meanings of the HTTP verbs. In particular, any
GET request should be side-effect free (<span class="emphasis"><em>idempotent</em></span>) because a GET is a
<span class="emphasis"><em>read</em></span> rather than a <span class="emphasis"><em>create</em></span>,
<span class="emphasis"><em>update</em></span>, or <span class="emphasis"><em>delete</em></span> operation. A
GET as a <span class="emphasis"><em>read</em></span> with no side effects is called a
<span class="emphasis"><em>safe</em></span> GET.</p><p>The REST approach does not imply that either resources or the
processing needed to generate adequate representations of them are simple.
A REST-style web service might be every bit as subtle and complicated, in its
functionality, as a
SOAP-based service or a DOA application. The RESTful approach tries to simplify
a service’s implementation by
taking what HTTP and the MIME type system already offer: built-in CRUD
operations, uniformly identifiable resources, typed representations
that can capture a resource’s state, and status codes to summarize the outcome of
a request. REST as a design philosophy tries to
isolate application complexity at the endpoints, that is, at the client
and at the service. A service may require lots of logic and computation to
maintain resources and to generate adequate representation of resources,
for instance, large and subtly formatted XML documents; and a client may
require significant XML processing to extract the desired information from
the XML representations transferred from the service to the client. Yet
the RESTful approach keeps the complexity out of the transport level, as a
resource representation is transferred to the client as the body of an
HTTP response message. For the record, RESTful web services are Turing complete; that is,
these services are equal in power to any computational system, including
a system that consists of SOAP-based web services or DOA stubs and skeletons.</p><div class="section" title="1.6.1. Verbs and Opaque Nouns"><div class="titlepage"><div><div><h4 class="title"><a id="_verbs_and_opaque_nouns"></a>1.6.1. Verbs and Opaque Nouns</h4></div></div></div><p>In HTTP a URI is meant to be opaque, which means that the URI</p><pre class="screen">http://bedrock/citizens/fred</pre><p>has no inherent connection to the URI</p><pre class="screen">http://bedrock/citizens</pre><p>although Fred happens to be a citizen of Bedrock. These are simply
two different, independent identifiers. Of course, a good URI designer
will come up with URIs that are suggestive about what they are meant to
identify. The point is that URIs have no intrinsic hierarchical
structure. URIs can and should be interpreted but these interpretations
are imposed on URIs, not inherent in them. Although URI syntax looks
like the syntax used to navigate a hierarchical file system, this
resemblance is misleading. A URI is an opaque identifier, a logically
proper name that should denote exactly one resource.</p></div></div><div class="section" title="1.7. Review of HTTP Requests and Responses"><div class="titlepage"><div><div><h3 class="title"><a id="_review_of_http_requests_and_responses"></a>1.7. Review of HTTP Requests and Responses</h3></div></div></div><p>The next section has a REST-style sample service whose URL is</p><pre class="screen">http://localhost:8080/predictions/</pre><p>If this URL were typed into a browser’s window, the browser
would generate an HTTP request similar to</p><pre class="screen">GET /predictions/ HTTP/1.1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) Chrome/24.0.1312.56
Host: localhost:8080
Accept: text/html</pre><p>The browser parses the entered URL into these parts, with clarifications
below:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
<code class="literal">GET /predictions/ HTTP/1.1</code>
</p><p class="simpara">This is the HTTP request <span class="emphasis"><em>start line</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
GET is the HTTP method (verb).
</li><li class="listitem">
<code class="literal">/predictions/</code> is the URI (resource’s name).
</li><li class="listitem">
<code class="literal">HTTP/1.1</code> is the HTTP version that the requester is using.
</li></ul></div></li><li class="listitem"><p class="simpara">
<code class="literal">User-Agent: Mozilla/5.0 (X11; Linux x86_64) Chrome/24.0</code>
</p><p class="simpara">Immediately after the <span class="emphasis"><em>start line</em></span> come the HTTP request header elements or
<span class="emphasis"><em>headers</em></span> for short. Each such element is a key/value pair with a colon <code class="literal">:</code>
separating the key on the left from the value on the right. In this element,
<code class="literal">User-Agent</code> is the key and everything to the right of colon is the value.
Chrome is the browser used in this request and Mozilla/5.0 specifies
a browser-compatibility type. The <code class="literal">User-Agent</code> information also
includes the operating system in use, 64-bit Linux.
Of interest here is that key <code class="literal">User-Agent</code> captures
the intended meaning: it is the application (agent) that a user employs
to make a request.</p></li><li class="listitem"><p class="simpara">
<code class="literal">Host: localhost:8080</code>
</p><p class="simpara">In <code class="literal">localhost:8080</code>, the network address of the machine that hosts
the resource is to the left of the colon; and the port number, in this case <code class="literal">8080</code>, is to the
right. In this example, the network address is <code class="literal">localhost</code> and its dotted-decimal
equivalent is 127.0.0.1.
Because the network address is <code class="literal">localhost</code>, the web server and
the requesting application are on the same machine, which is convenient during development.
In a production environment, the web server might have a network address such as
<code class="literal">dcequip.cti.depaul.edu</code>. Port numbers range from 0 to roughly 65,000, with
port numbers from 0 through 1023 typically reserved for standard applications
such as web servers (port 80 for HTTP and port 443 for HTTPS), SMTP (email, port 25),
SSH (secure shell, port 22), and so on. For convenience, the web servers Tomcat and Jetty use port 8080 by
default but the number can be changed (for example, to the standard HTTP port number 80). Under HTTP 1.1,
the key/value pair, with <code class="literal">Host</code> as the key, is required. The other header elements are optional, although the
ones shown here are typical.</p></li><li class="listitem"><p class="simpara">
<code class="literal">Accept: text/html</code>
</p><p class="simpara">This is the MIME type (<code class="literal">text</code>) and subtype (<code class="literal">html</code>), which the browser
is ready to accept. The application running on web server may not honor the requested
type and respond instead with, for example, <code class="literal">text/plain</code> or <code class="literal">text/xml</code>.</p></li></ul></div><p>In summary, the key/value pairs such as</p><pre class="screen">Accept: text/html</pre><p>make up the HTTP request headers. These pairs
may occur in any order and only the</p><pre class="screen">Host: &lt;network address&gt;</pre><p>pair is mandatory under HTTP 1.1.</p><p>Two newlines terminate the headers section. A GET request has no body; hence, a GET request
consists only of the start line and the headers. A POST request always has a body, which may
be empty. In a POST request, two newlines also mark the end of the headers.</p><p>Because a GET request has no body, such a request often includes, in the URI, a
query string that consists of key/value pairs. For example, this GET request</p><pre class="screen">http://.../products?id=27&amp;category=boots</pre><p>includes a query-string with two key/value pairs: <code class="literal">id</code> is the first key and <code class="literal">27</code> is the value;
<code class="literal">category</code> is the second key and <code class="literal">boots</code> is the value. The query string thus provides a way
for a body-less GET request to include information within the request. The query string data
are encapsulated in the HTTP request headers. POST requests always have a body, which is
usually non-empty. The body of a POST request holds key/value pairs as well.</p><p>If all goes well, sending an HTTP request to the URL</p><pre class="screen">http://localhost:8080/predictions/</pre><p>leads to an HTTP response, which is similar to <a class="xref" href="#http_response" title="Example 2. The HTTP response message from the predictions service.">Example 2, “The HTTP response message from the <span class="emphasis"><em>predictions</em></span> service.”</a>.</p><div class="example"><a id="http_response"></a><p class="title"><b>Example 2. The HTTP response message from the <span class="emphasis"><em>predictions</em></span> service.</b></p><div class="example-contents"><pre class="screen">HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=35B1E3AA21EB7242FD2FC50044D2166A; Path=/predictions/;
Content-Type: text/html;charset=ISO-8859-1
Transfer-Encoding: chunked

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.7.0" class="java.beans.XMLDecoder"&gt;
 &lt;array class="predictions.Prediction" length="32"&gt;
  &lt;void index="0"&gt;
   &lt;object class="predictions.Prediction"&gt;
    &lt;void property="what"&gt;
     &lt;string&gt;
        Managed holistic contingency will grow killer action-items.
     &lt;/string&gt;
    &lt;/void&gt;
    &lt;void property="who"&gt;
     &lt;string&gt;
        Cornelius Tillman
     &lt;/string&gt;
    &lt;/void&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  ...
&lt;/java&gt;</pre></div></div><br class="example-break" /><p>The start line</p><pre class="screen">HTTP/1.1 200 OK</pre><p>begins with the HTTP version in use on the server. Next comes the HTTP status code (<span class="strong"><strong>SC</strong></span> for short) as
a number (200) and in English (OK). Status codes in the 200-range signal success. Five
header elements follow, including the name of the web server that sends the
response and the content type of the response. Note that the response type is given
as <code class="literal">text/html</code> rather than as what it actually is: <code class="literal">text/xml</code>. The reason is that
my code, which generates the response, does not bother to set the content type;
hence, the Apache-Coyote (that is, Tomcat) web server uses its default type of <code class="literal">text/html</code>. Two
newline characters again separate the headers from the HTTP body, which can be
empty. In this case, the body is an XML document that lists corporate predictions
together with their predictors.</p></div><div class="section" title="1.8. HTTP as an API"><div class="titlepage"><div><div><h3 class="title"><a id="_http_as_an_api"></a>1.8. HTTP as an API</h3></div></div></div><p>HTTP can be viewed as an API. Among frameworks for developing web sites and RESTful web services,
Rails has pioneered this view of HTTP, which deliberately blurs the distinction between web sites that deliver HTML
and web services that deliver XML or JSON. In a well-designed Rails application, a GET request
for the URI <span class="emphasis"><em>/products</em></span> is equivalent to the same request for <span class="emphasis"><em>/products.html</em></span>; and an HTML
list of products is returned in response. A GET request against <span class="emphasis"><em>/products.json</em></span> or
<span class="emphasis"><em>/products.xml</em></span> would return the same list but in JSON or XML, respectively. Rails has an often-copied
idiom for combining URIs and HTTP verbs into a <span class="emphasis"><em>RESTful route</em></span>, that is, the route that a request takes
to the code that handles the request. The Rails routing style
is an elegant yet practical use of HTTP
as an API. Table 3 is a summary of the Rails approach. In a URI, a term such as <span class="emphasis"><em>:id</em></span>, which
begins with a colon character,
indicates a placeholder or parameter, in this case a placeholder whose intended value is a
numerical identifier such as 27.</p><div class="table"><a id="idp5855584"></a><p class="title"><b>Table 3. Rails routing idioms.</b></p><div class="table-contents"><table summary="Rails routing idioms." cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col /><col /><col /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">HTTP Verb  </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">URI (Name)           </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Meaning</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Read all products</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>POST</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create a new product from information in the POST body</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products/new</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Read the form to create a new product</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products/:id/edit</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Read the form to edit an existing product</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products/:id</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Read a single product</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>PUT</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>/products/:id</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Update a product with information in the POST body</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>DELETE</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>/products:id</p></td><td style="" align="left" valign="top"><p>Delete the specified product</p></td></tr></tbody></table></div></div><br class="table-break" /><p>These verb/name pairs are terse, precise, intuitive, and uniform in style. The
pairs illustrate that RESTful conventions can yield simple, clear
routing expressions about which operation should be performed on which resource.
The POST and PUT verbs are used in requests that have an HTTP body;
hence, the request data are in the HTTP message body. The GET and
DELETE verbs are used in requests that have no body; hence, the request
data, if any, are sent as query-string key/value pairs.</p><p>The decision about whether to be RESTful in a particular application depends, as
always, on practical matters that will come to the fore throughout this book. The current section
has looked at REST from on high; it is now time to descend into details with code examples. The next
section summarizes the overview of HTTP with two Java clients. A first RESTful service follows.</p><div class="section" title="1.8.1. Two HTTP Clients in Java"><div class="titlepage"><div><div><h4 class="title"><a id="_two_http_clients_in_java"></a>1.8.1. Two HTTP Clients in Java</h4></div></div></div><p>The foregoing descriptions about HTTP can be fleshed out and summarized with two short Java clients,
which can be run against any URL—for a web site or a web service. The first client (see <a class="xref" href="#simple_client" title="Example 3. A simple Java client that makes an HTTP GET request.">Example 3, “A simple Java client that makes an HTTP GET request.”</a>) takes a deliberately
low-level approach by building up the HTTP request as a string, one chunk at a time. The second client (see <a class="xref" href="#url_connection" title="Example 4. A Java HTTP client that uses the utility URLConnection class.">Example 4, “A Java HTTP client that uses the utility <code class="literal">URLConnection</code> class.”</a>)
uses the Java utility class <code class="literal">URLConnection</code>, which shortens the code and makes the program more readable.</p><div class="example"><a id="simple_client"></a><p class="title"><b>Example 3. A simple Java client that makes an HTTP GET request.</b></p><div class="example-contents"><pre class="screen">import java.net.Socket;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class SimpleHttpClient {
    public static void main(String[ ] args) {
        // usage
        if (args.length &lt; 1) {                                             <a id="CO1-1"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
            System.err.println("Usage: SimpleHttpClient &lt;url&gt;");
            return;
        }
        try {
            // Parse the URL.
            URL url = new URL(args[0]);                                    <a id="CO1-2"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
            String host = url.getHost();                                   <a id="CO1-3"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
            String path = url.getPath();                                   <a id="CO1-4"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
            int port = url.getPort();                                      <a id="CO1-5"></a><img src="/etc/asciidoc/images/icons//callouts/5.png" alt="5" border="0" />
            if (port &lt; 0) port = 80;
            // Send the request.
            String request = "GET " + path + " HTTP/1.1\n";                <a id="CO1-6"></a><img src="/etc/asciidoc/images/icons//callouts/6.png" alt="6" border="0" />
            request += "host: " + host;                                    <a id="CO1-7"></a><img src="/etc/asciidoc/images/icons//callouts/7.png" alt="7" border="0" />
            request += "\n\n";
            Socket sock = new Socket(host, port);
            PrintWriter writer = new PrintWriter(sock.getOutputStream());
            writer.print(request);                                         <a id="CO1-8"></a><img src="/etc/asciidoc/images/icons//callouts/8.png" alt="8" border="0" />
            writer.flush();
            // Read and print the response.
            BufferedReader reader =                                        <a id="CO1-9"></a><img src="/etc/asciidoc/images/icons//callouts/9.png" alt="9" border="0" />
                new BufferedReader(new InputStreamReader(sock.getInputStream()));
            String next_record = null;
            while ((next_record = reader.readLine()) != null)              <a id="CO1-10"></a><img src="/etc/asciidoc/images/icons//callouts/10.png" alt="10" border="0" />
                System.out.println(next_record);
            sock.close();
        }
        catch(MalformedURLException e) {
            throw new RuntimeException("Please try again. Bad URL.\n" + e);
        }
        catch(UnknownHostException e) {
            throw new RuntimeException("Please try again. Unknown host.\n" + e);
        }
        catch(IOException e) {
            throw new RuntimeException("Please try again. Something's wrong.\n" + e);
        }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">SimpleHttpClient</code> expects, as a command-line argument (line 1), a URL such as
<span class="emphasis"><em>http://www.amazon.com/index.html</em></span>. After constructing a <code class="literal">URL</code> instance from the
string URL (line 2), the client extracts the <span class="emphasis"><em>host</em></span>, the <span class="emphasis"><em>path</em></span> (URI), and the
<span class="emphasis"><em>port number</em></span> (lines 3, 4, and 5) so that an HTTP GET request can be built in chunks.
Line 6, for example, builds the start-line</p><pre class="screen">GET /index.html HTTP/1.1</pre><p>given the sample Amazon URL. Only the required HTTP header is generated (line 7), with
<code class="literal">host</code> as the key and the IP address of the server (in this case, <code class="literal">www.amazon.com</code>) as
the value. After the request is sent (line 8), the response is read (lines 9 and 10)
and the connection is closed.</p><div class="example"><a id="url_connection"></a><p class="title"><b>Example 4. A Java HTTP client that uses the utility <code class="literal">URLConnection</code> class.</b></p><div class="example-contents"><pre class="screen">import java.net.URL;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;

public class UrlConnectionClient {
    public static void main(String[ ] args) {
        // usage
        if (args.length &lt; 1) {
            System.err.println("Usage: UrlConnectionClient &lt;url&gt;");
            return;
        }

        try {
            // Parse the URL.
            URL url = new URL(args[0].trim());                                     <a id="CO1-11"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />

            // Connect.
            URLConnection sock = url.openConnection();                             <a id="CO1-12"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />

            // Read and print.
            BufferedReader reader =
                new BufferedReader(new InputStreamReader(sock.getInputStream()));
            String next_record = null;
            while ((next_record = reader.readLine()) != null)                      <a id="CO1-13"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
                System.out.println(next_record);

            // Close.
            reader.close();                                                        <a id="CO1-14"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        }
        catch(MalformedURLException e) { throw new RuntimeException(e); }
        catch(IOException e) { throw new RuntimeException(e); }
    }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">UrlConnectionClient</code> (see Example 1-3) uses the class <code class="literal">URLConnection</code>, which simplifies the code.
This client, like the first, expects a URL as a command-line argument. A <code class="literal">URL</code> instance (line 1) again
is constructed but then used immediately (line 2) to open a connection. By default, the opened connection
is a GET request against the site with the given URL. The response is read chunk by chunk (line 3) and printed.
The connection then is closed (line 4).</p><p>Clients such as these occur throughout the forthcoming chapters, especially in examples that involve
REST-style services. It is now time to introduce the first RESTful example.</p></div></div><div class="section" title="1.9. A First RESTful Example"><div class="titlepage"><div><div><h3 class="title"><a id="_a_first_restful_example"></a>1.9. A First RESTful Example</h3></div></div></div><p>As befits a first example, the implementation is simple but sufficient to highlight key aspects of
a RESTful web service. The implementation consists of a JSP (Java Server Pages) script and two back-end
JavaBeans that the JSP script uses to get the data returned to the client (see <a class="xref" href="#Ex_predictions_service" title="Example 5. The organization of the predictions web service.">Example 5, “The organization of the <span class="emphasis"><em>predictions</em></span> web service.”</a>).
The data are sage corporate predictions. Here
is a sample:</p><pre class="screen">Decentralized 24/7 hub will target robust web-readiness.
Synergistic disintermediate policy will expedite back-end experiences.
Universal fault-tolerant architecture will synthesize bleeding-edge channels.</pre><div class="example"><a id="Ex_predictions_service"></a><p class="title"><b>Example 5. The organization of the <span class="emphasis"><em>predictions</em></span> web service.</b></p><div class="example-contents"><pre class="screen">                                                             +----------------+
                                                             | predictions.db |
                                                             | data file      |--+
                                                             +----------------+  | initial
                                                                                 | data
+--------+   GET requests     +-----------------+   data?  +-----------+         | read
| client |-------------------&gt;| predictions.jsp |---------&gt;| backend   |&lt;--------+
|        |&lt;-------------------|   JSP script    |&lt;---------| JavaBeans |
+--------+  service responses +-----------------+   data   +-----------+</pre></div></div><br class="example-break" /><p>There is an Ant script (see <a class="xref" href="#sidebar_ant" title="An Ant script for service deployment">An Ant script for service deployment</a>) that automates the deployment of this and other service examples. Here is
a summary of the service parts and of how the Ant script puts the parts together:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
The service consists of a JSP script together with two POJO (JavaBean) classes. The classes
provide back-end support for the JSP script. There is also a small configuration file, <span class="emphasis"><em>web.xml</em></span>,
that allows the URI to be shortened from
</p><pre class="screen">/predictions/predictions.jsp</pre><p class="simpara">to</p><pre class="screen">/predictions/</pre></li><li class="listitem">
The Ant script compiles the <span class="emphasis"><em>.java</em></span> files and then packages the JSP script, the compiled
<span class="emphasis"><em>.class</em></span> files, and—only for convenience—the <span class="emphasis"><em>.java</em></span> files into a JAR file with a <span class="emphasis"><em>.war</em></span>
extension (hereafter, a WAR file).
</li><li class="listitem">
The WAR file is copied to the Tomcat <span class="emphasis"><em>webapps</em></span> subdirectory, which thereby deploys the service.
The first sidebar (see <a class="xref" href="#sidebar_tomcat" title="The Tomcat web server">The Tomcat web server</a>) goes into the details of Tomcat installation and management.
</li></ul></div><p>In the <span class="emphasis"><em>predictions</em></span> service, each prediction has an associated human predictor. The RESTful resource is thus a list of
predictor names (<span class="emphasis"><em>e.g.</em></span>, Hollis McCullough) and their predictions (Hollis is
responsible for the third prediction shown above). The resource name or URI is <span class="emphasis"><em>/predictions/</em></span>;
and the only allowable HTTP verb is GET, which corresponds to <span class="emphasis"><em>read</em></span> among the CRUD operations.
If the HTTP request is correct, the RESTful service returns an XML representation of the
predictor/prediction list; otherwise, the service returns the appropriate HTTP
status code, <span class="emphasis"><em>e.g.</em></span>, 404 for "Not Found", if the URI is incorrect, or
405 for "Method Not Allowed", if the verb is not GET. <a class="xref" href="#Ex_xml_response" title="Example 6. The XML response from the predictions service">Example 6, “The XML response from the predictions service”</a> shows a slice of
the XML payload returned upon a successful request.</p><div class="example"><a id="Ex_xml_response"></a><p class="title"><b>Example 6. The XML response from the predictions service</b></p><div class="example-contents"><pre class="screen">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.7.0" class="java.beans.XMLDecoder"&gt;
 &lt;array class="predictions.Prediction" length="32"&gt;
  &lt;void index="0"&gt;
   &lt;object class="predictions.Prediction"&gt;
    &lt;void property="what"&gt;
     &lt;string&gt;
       Managed holistic contingency will grow killer action-items.
     &lt;/string&gt;
    &lt;/void&gt;
    &lt;void property="who"&gt;
     &lt;string&gt;Cornelius Tillman&lt;/string&gt;
    &lt;/void&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  ...
  &lt;void index="31"&gt;
   &lt;object class="predictions.Prediction"&gt;
    &lt;void property="what"&gt;
     &lt;string&gt;
       Versatile tangible application will maximize rich e-business.
     &lt;/string&gt;
    &lt;/void&gt;
    &lt;void property="who"&gt;
     &lt;string&gt;Hiram Gulgowski&lt;/string&gt;
    &lt;/void&gt;
   &lt;/object&gt;
  &lt;/void&gt;
 &lt;/array&gt;
&lt;/java&gt;</pre></div></div><br class="example-break" /><div class="section" title="1.9.1. How the predictions Web Service Works"><div class="titlepage"><div><div><h4 class="title"><a id="_how_the_emphasis_predictions_emphasis_web_service_works"></a>1.9.1. How the <span class="emphasis"><em>predictions</em></span> Web Service Works</h4></div></div></div><p>When the <span class="emphasis"><em>predictions</em></span> service is deployed to a web server such as Tomcat, the server translates
the JSP script <span class="emphasis"><em>predictions.jsp</em></span> (see <a class="xref" href="#Ex_predictions_jsp" title="Example 7. The JSP script predictions.jsp.">Example 7, “The JSP script <code class="literal">predictions.jsp</code>.”</a>) into a servlet instance. For now, this technical detail is
overlooked because it is convenient
to talk about the JSP script itself as the target of a request.</p><div class="example"><a id="Ex_predictions_jsp"></a><p class="title"><b>Example 7. The JSP script <code class="literal">predictions.jsp</code>.</b></p><div class="example-contents"><pre class="screen">&lt;jsp:useBean id    = "preds"                            <a id="CO1-15"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
             type  = "predictions.Predictions"
             class = "predictions.Predictions"&gt;
  &lt;% // Check the HTTP verb: if it's anything but GET,
     // return 405 (Method Not Allowed).
     String verb = request.getMethod();
     if (!verb.equalsIgnoreCase("GET")) {
       response.sendError(response.SC_METHOD_NOT_ALLOWED,
                          "Only GET requests are allowed.");
     }
     // If it's a GET request, return the predictions.
     else {
       preds.setServletContext(application);            <a id="CO1-16"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
       out.println(preds.getPredictions());
     }
  %&gt;
&lt;/jsp:useBean&gt;</pre></div></div><br class="example-break" /><p>As requests come to the JSP script, the script first checks the request’s HTTP method.
If the method is GET, an XML representation of the predictions is returned to the requester.
If the verb is not GET, the script returns an
error message together with the HTTP status code. The relevant code is:</p><pre class="screen">String verb = request.getMethod();
if (!verb.equalsIgnoreCase("GET")) {
  response.sendError(response.SC_METHOD_NOT_ALLOWED,
                     "Only GET requests are allowed.");
}</pre><p>JSP scripts have implicit object references such as <code class="literal">request</code>, <code class="literal">response</code>, and <code class="literal">out</code>; each of these is a
field or a parameter in the servlet code into which the web server such as Tomcat or Jetty
translates the JSP script. A JSP script can make the same calls as an
<code class="literal">HttpServlet</code>.</p><p>On a successful request, the JSP script returns a list of predictions and
their predictors, a list available from the back-end JavaBean
<code class="literal">Predictions</code>. The JSP code is straightforward:</p><pre class="screen">out.println(preds.getPredictions());</pre><p>The object reference <code class="literal">out</code>, available in every JSP script, refers to an output stream
through which the JSP script can communicate with the client. In this example,
the object reference <code class="literal">preds</code> (line 1) refers to the back-end JavaBean that maintains
the collection of predictions; and the <code class="literal">getPredictions</code> method in the back-end bean converts the
Java list of <code class="literal">Predictions</code> into an XML document.</p><p>The back-end code consists of two POJO classes, <code class="literal">Prediction</code> (see <a class="xref" href="#Ex_prediction" title="Example 8. The back-end predictions.Prediction class.">Example 8, “The back-end <code class="literal">predictions.Prediction</code> class.”</a>) and <code class="literal">Predictions</code> (see <a class="xref" href="#Ex_predictions" title="Example 9. The back-end predictions.Predictions class.">Example 9, “The back-end <code class="literal">predictions.Predictions</code> class.”</a>). The
<code class="literal">Prediction</code> class is quite simple, consisting of two properties: <code class="literal">who</code> (line 1) is the
person making the prediction and <code class="literal">what</code> (line 2) is the prediction.</p><div class="example"><a id="Ex_prediction"></a><p class="title"><b>Example 8. The back-end <code class="literal">predictions.Prediction</code> class.</b></p><div class="example-contents"><pre class="screen">package predictions;
import java.io.Serializable;

public class Prediction implements Serializable {
    private String who;   // person
    private String what;  // his/her prediction
    public Prediction() { }
    public void setWho(String who) { this.who = who; }      <a id="CO1-17"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public String getWho() { return this.who; }
    public void setWhat(String what) { this.what = what; }  <a id="CO1-18"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
    public String getWhat() { return this.what; }
}</pre></div></div><br class="example-break" /><p>The <code class="literal">Predictions</code>
class does the grunt work. For example, its <code class="literal">populate</code> method (line 3) reads the prediction
data from a text file, <span class="emphasis"><em>predictions.db</em></span>, encapsulated in the deployed WAR file; and
the <code class="literal">toXML</code> method serializes a Java <code class="literal">List&lt;Prediction&gt;</code> into an XML document,
which is sent back to the client. If there were problems reading or formatting the
data, the <span class="emphasis"><em>predictions</em></span> service would return <code class="literal">null</code> to the client.</p><div class="example"><a id="Ex_predictions"></a><p class="title"><b>Example 9. The back-end <code class="literal">predictions.Predictions</code> class.</b></p><div class="example-contents"><pre class="screen">package predictions;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.beans.XMLEncoder; // simple and effective
import javax.servlet.ServletContext;

public class Predictions {
    private int n = 32;
    private Prediction[ ] predictions;
    private ServletContext sctx;
    public Predictions() { }
    public void setServletContext(ServletContext sctx) { this.sctx = sctx; } <a id="CO1-19"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
    public ServletContext getServletContext() { return this.sctx; }
    // getPredictions returns an XML representation of
    // the Predictions array
    public void setPredictions(String ps) { } // no-op
    public String getPredictions() {                                         <a id="CO1-20"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
        // Has the ServletContext been set?
        if (getServletContext() == null) return null;
        // Have the data been read already?
        if (predictions == null) populate();
        // Convert the Predictions array into an XML document
        return toXML();
    }
    private void populate() {                                                <a id="CO1-21"></a><img src="/etc/asciidoc/images/icons//callouts/3.png" alt="3" border="0" />
        String filename = "/WEB-INF/data/predictions.db";
        InputStream in = sctx.getResourceAsStream(filename);
        // Read the data into the array of Predictions.
        if (in != null) {
            try {
                InputStreamReader isr = new InputStreamReader(in);
                BufferedReader reader = new BufferedReader(isr);
                predictions = new Prediction[n];
                int i = 0;
                String record = null;
                while ((record = reader.readLine()) != null) {
                    String[] parts = record.split("!");
                    Prediction p = new Prediction();
                    p.setWho(parts[0]);
                    p.setWhat(parts[1]);

                    predictions[i++] = p;
                }
            }
            catch (IOException e) { }
        }
    }
    private String toXML() {                                              <a id="CO1-22"></a><img src="/etc/asciidoc/images/icons//callouts/4.png" alt="4" border="0" />
        String xml = null;
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            XMLEncoder encoder = new XMLEncoder(out);
            encoder.writeObject(predictions); // serialize to XML
            encoder.close();
            xml = out.toString(); // stringify
        }
        catch(Exception e) { }
        return xml;
    }
}</pre></div></div><br class="example-break" /><p>On a GET request, the JSP script invokes the method
<code class="literal">setServletContext</code> (line 1 in the bean, line 2 in the JSP script) with an argument,
the implicit object reference named <code class="literal">application</code>.
The back-end bean needs access to the servlet context
in order to read data from a
text file embedded in the deployed WAR file. The <code class="literal">ServletContext</code> is a data structure
through which a servlet/JSP script can interact explicitly with the servlet container.
The call to the <code class="literal">setServletContext</code> method sets up
the subsequent call to the <code class="literal">getPredictions</code> method (line 2), which returns the XML representation shown in
Example 3. Here is the <code class="literal">getPredictions</code> method without the comments:</p><pre class="screen">public String getPredictions() {
   if (getServletContext() == null) return null;
   if (predictions == null) populate(); <a id="CO1-23"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   return toXML();
}</pre><p>The method <code class="literal">populate</code> (line 1 immediately above) reads the data.
The <code class="literal">predictions</code> reference in the code segment above refers to the <code class="literal">Map</code> in which <code class="literal">Prediction</code> references are values.
If the JSP script fails to set the servlet context, there is no way for the back-end
<code class="literal">Predictions</code> bean to provide the requested data. The reason is that the
the <code class="literal">populate</code> method requires the servlet context (the reference is <code class="literal">sctx</code>, line 1, in the code below)
in order to access the data:</p><pre class="screen">private void populate() {
   String filename = "/WEB-INF/data/predictions.db";
   InputStream in = sctx.getResourceAsStream(filename); <a id="CO1-24"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
   ...
}</pre><p>If the servlet context has been set but the <code class="literal">predictions</code> reference is <code class="literal">null</code>, then the data
must be read from the <span class="emphasis"><em>predictions.db</em></span> file into the <code class="literal">Map</code> that makes the data available to
clients. Each entry in the <code class="literal">Map</code> is a <code class="literal">Prediction</code>, which again is a pair: <code class="literal">who</code> predicts <code class="literal">what</code>.
Finally, the <code class="literal">toXML</code> method serializes the
Java predictions into an XML document using the Java utility class  <code class="literal">XMLEncoder</code> (line 1):</p><pre class="screen">private String toXML() {
   String xml = null;
   try {
      ByteArrayOutputStream out = new ByteArrayOutputStream();
      XMLEncoder encoder = new XMLEncoder(out);                 <a id="CO1-25"></a><img src="/etc/asciidoc/images/icons//callouts/1.png" alt="1" border="0" />
      encoder.writeObject(predictions); // serialize to XML
      encoder.close();
      xml = out.toString(); // stringify
   }
   catch(Exception e) { }
   return xml;                                                  <a id="CO1-26"></a><img src="/etc/asciidoc/images/icons//callouts/2.png" alt="2" border="0" />
}</pre><p>The XML document from the <code class="literal">toXML</code> method (line 2) becomes the body of the HTTP response to the client.</p><p>Although the XML from the <span class="emphasis"><em>predictions</em></span> service is generated using the <code class="literal">XMLEncoder</code> class,
Java does provide other ways to generate XML—but perhaps none quite as simple as
<code class="literal">XMLEncoder</code>. The <code class="literal">Prediction</code> objects must be serializable in order to be encoded as
XML using the <code class="literal">XMLEncoder</code>; hence, the <code class="literal">Prediction</code>
class implements the empty (or <span class="emphasis"><em>marker</em></span>) <code class="literal">Serializable</code> interface and defines the
<span class="emphasis"><em>get/set</em></span> methods for the properties <code class="literal">who</code> (the predictor) and <code class="literal">what</code> (the
prediction). The <code class="literal">Prediction</code> properties are serialized into XML elements in the
response document.</p><p>The predictions service can be deployed under the Tomcat web server using a provided
Ant script (with <code class="literal">%</code> as the command-line prompt):</p><pre class="screen">% ant -Dwar.name=predictions deploy</pre><p>The deployed WAR file would be <span class="emphasis"><em>predictions.war</em></span> in this case.
The first sidebar (see <a class="xref" href="#sidebar_tomcat" title="The Tomcat web server">The Tomcat web server</a>) elaborates on the Apache Tomcat server and explains how to install and use
this server. The second sidebar (see <a class="xref" href="#sidebar_ant" title="An Ant script for service deployment">An Ant script for service deployment</a>) clarifies the Ant script, which is packaged with the book’s
code examples. The deployed WAR file
<span class="emphasis"><em>predictions.war</em></span> includes a standard web deployment document, <span class="emphasis"><em>web.xml</em></span>, so that
the URI can be shortened to <span class="emphasis"><em>/predictions/</em></span>.</p><div class="sidebar" title="The Tomcat web server"><a id="sidebar_tomcat"></a><p class="title"><b>The Tomcat web server</b></p><p>Apache Tomcat (<span class="emphasis"><em>tomcat.apache.org/</em></span>) is a commercial-grade yet lightweight web server
implemented in Java. Tomcat has various subsystems for administration, security, logging,
and trouble-shooting but its central subsystem is Catalina, a container that executes servlets,
including JSP and other scripts (<span class="emphasis"><em>e.g.</em></span>, JSF scripts) that Tomcat automatically translates into
servlets. Tomcat is the popular name for the web server; and Catalina is the official name for
the servlet container that comes with Tomcat.</p><p>Tomcat also includes a web console, tutorials, and sample code. This note focuses on
installing Tomcat and on basic post-installation tasks such as starting and stopping the web server.
The current version is 7.x, which requires Java SE 6 or higher. Earlier Tomcat versions are
still available.</p><p>There are different ways to download Tomcat, including as a ZIP file. Tomcat can be installed in
any directory. For convenience, let <span class="emphasis"><em>TOMCAT_HOME</em></span> be the install directory. The
directory <span class="emphasis"><em>TOMCAT_HOME/bin</em></span> has startup and shutdown scripts for Unixy and Windows
systems. For instance, the startup script is <span class="emphasis"><em>startup.sh</em></span> for Unix and <span class="emphasis"><em>startup.bat</em></span> for
Windows. Tomcat is written in Java but does not ship with the Java run-time; instead, Tomcat uses
the Java run-time on the host system. To that end, the
environment variable <span class="emphasis"><em>JAVA_HOME</em></span> should be set to the Java install directory (<span class="emphasis"><em>e.g.</em></span>, to
<span class="emphasis"><em>/usr/local/java7</em></span>, <span class="emphasis"><em>D:\java7</em></span>, and the like).</p><p>In summary, the key commands (with comments
introduced with two semicolons) are:</p><pre class="screen">% startup.sh   ;; or startup.bat on Windows to start Tomcat
% shutdown.sh  ;; or shutdown.bat on Windows to stop Tomcat</pre><p>The commands can be given at a command-line prompt. On startup, a message
similar to</p><pre class="screen">Using CATALINA_BASE:   /home/mkalin/tomcat7
Using CATALINA_HOME:   /home/mkalin/tomcat7
Using CATALINA_TMPDIR: /home/mkalin/tomcat7/temp
Using JRE_HOME:        /usr/local/java
Using CLASSPATH:       /home/mkalin/tomcat7/bin/bootstrap.jar</pre><p>appears.</p><p>Under <span class="emphasis"><em>TOMCAT_HOME</em></span> there is directory named <span class="emphasis"><em>logs</em></span>, which contains various log
files, and several other directories, some of which will be clarified later. A
important directory for now is <span class="emphasis"><em>TOMCAT_HOME/webapps</em></span>, which holds JAR files with a <span class="emphasis"><em>.war</em></span> extension
(hence the name WAR file). Subdirectories under <span class="emphasis"><em>TOMCAT_HOME/webapps</em></span> can be added as
needed. Deploying a web service under Tomcat is the same as deploying a web site: a WAR file
containing the site or the service is copied to
the <span class="emphasis"><em>webapps</em></span> directory; and a web site or web service is undeployed by removing its WAR file.</p><p>Tomcat maintains various log files in <span class="emphasis"><em>TOMCAT_HOME/logs</em></span>, one of which is especially
convenient for <span class="emphasis"><em>ad hoc</em></span> debugging. In standard configuration, Tomcat redirects output to
<code class="literal">System.err</code> and <code class="literal">System.out</code> to <span class="emphasis"><em>logs/catalina.out</em></span>. Accordingly, if a servlet executes</p><pre class="screen">System.err.println("Goodbye, cruel world!");</pre><p>the farewell message would appear in the <span class="emphasis"><em>catalina.out</em></span> log file.</p><p>Apache Tomcat is not the only game in town. There is the related TomEE web server,
basically Tomcat with support for Java EE beyond servlets. Another popular Java-centric
web server is Jetty (<span class="emphasis"><em>jetty.codehaus.org</em></span>). The sample services in this book
can be deployed, as is, with either Tomcat or Jetty; and the next chapter has a sidebar
on how to install and run Jetty.</p></div><div class="sidebar" title="An Ant script for service deployment"><a id="sidebar_ant"></a><p class="title"><b>An Ant script for service deployment</b></p><p>The first sample web service is published with a web server such as Tomcat or Jetty. The ZIP
file with my code examples includes an Ant script to ease the task of deployment.
The Ant utility, written in Java, is available on all platforms. My script requires
Ant 1.6 or higher.</p><p>To begin, let the <span class="emphasis"><em>current working directory</em></span> (<span class="emphasis"><em>cwd</em></span>) be any directory on the local
file system. The <span class="emphasis"><em>cwd</em></span> holds the Ant script build.xml:</p><pre class="screen">cwd: build.xml</pre><p>The <span class="emphasis"><em>cwd</em></span> has a subdirectory named <span class="emphasis"><em>src</em></span> that holds the web service’s artifacts.
Suppose, for example, that a web service includes a
JSP script, a back-end JavaBean, the standard Tomcat or Jetty deployment file <span class="emphasis"><em>web.xml</em></span>,
and a JAR file that holds a JSON library. Here is a depiction:</p><pre class="screen">cwd: build.xml
 |
src: products.jsp, json.jar, web.xml</pre><p>Suppose, further, that the back-end JavaBean has the fully qualified name</p><pre class="screen">acme.Products</pre><p>The file structure is now</p><pre class="screen">cwd: build.xml
 |
src: products.jsp, json.jar, web.xml
 |
acme: Products.java</pre><p>Finally, assume that the <span class="emphasis"><em>src</em></span> directory also holds the data file <span class="emphasis"><em>new_products.db</em></span>.
From the <span class="emphasis"><em>cwd</em></span> command-line, the command</p><pre class="screen">% ant -Dwar.name=products deploy</pre><p>does the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Creates the directory <span class="emphasis"><em>cwd/build</em></span>, which holds copies of files in directory <span class="emphasis"><em>src</em></span> and any subdirectories.
</li><li class="listitem">
Compiles any <span class="emphasis"><em>.java</em></span> files, in this case <span class="emphasis"><em>acme.Products.java</em></span>.
</li><li class="listitem"><p class="simpara">
Builds the WAR file, whose major contents are:
</p><pre class="screen">WEB-INF/web.xml
WEB-INF/classes/acme/Products.class
WEB-INF/data/new_products.db
WEB-INF/lib/json.jar
acme/Products.java
products.jsp</pre></li></ul></div><p>In the constructed WAR file,</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Any <span class="emphasis"><em>.xml</em></span> file winds up in <span class="emphasis"><em>WEB-INF</em></span>.
</li><li class="listitem">
Any <span class="emphasis"><em>.jar</em></span> file winds up in <span class="emphasis"><em>WEB-INF/lib</em></span>.
</li><li class="listitem">
Any <span class="emphasis"><em>.db</em></span> file winds up in <span class="emphasis"><em>WEB-INF/data</em></span>.
</li><li class="listitem">
Any <span class="emphasis"><em>.java</em></span> or <span class="emphasis"><em>.class</em></span> file winds up in its package/subdirectory.
</li><li class="listitem">
Other files, such as <span class="emphasis"><em>.jsp</em></span> files, wind up in the WAR file’s top level.
</li></ul></div><p>For convenience the Ant script includes, in the WAR file, Java source (<span class="emphasis"><em>.java</em></span>) and
compiled (<span class="emphasis"><em>.class</em></span>) files. In production, the source files would be omitted.</p><p>Finally, the Ant script copies the constructed WAR file to <span class="emphasis"><em>TOMCAT_HOME/webapps</em></span> and thereby deploys the web service.
The script also leaves a copy of the WAR file in <span class="emphasis"><em>cwd</em></span>.</p><p>The command</p><pre class="screen">% ant</pre><p>displays the three most useful commands. The command</p><pre class="screen">% ant clean</pre><p>removes any <span class="emphasis"><em>.war</em></span> files from the <span class="emphasis"><em>cwd</em></span> and deletes the <span class="emphasis"><em>build</em></span> directory.
The command</p><pre class="screen">% ant compile</pre><p>compiles any <span class="emphasis"><em>.java</em></span> files but does not build or deploy a WAR file. The
command</p><pre class="screen">% ant -Dwar.name=predictions deploy</pre><p>first cleans and compiles; and then the command builds and deploys the WAR
file <span class="emphasis"><em>predictions.war</em></span>.</p><p>The Ant file <span class="emphasis"><em>build.xml</em></span> has extensive documentation and explains, in particular,
what needs to be done to customize this file for your environment. Only one line in
the file needs to be edited. Although the Ant script is targeted at Tomcat deployment,
the WAR files that the script produces
can be deployed as is to Jetty as well. As noted earlier, Chapter 2 goes into the details of
installing and running Jetty.</p></div></div><div class="section" title="1.9.2. A Client against the predictions Web Service"><div class="titlepage"><div><div><h4 class="title"><a id="_a_client_against_the_emphasis_predictions_emphasis_web_service"></a>1.9.2. A Client against the <span class="emphasis"><em>predictions</em></span> Web Service</h4></div></div></div><p>Later examples introduce
RESTful clients in Java and other languages; but, for now, either a browser or a
utility such as <span class="emphasis"><em>curl</em></span> (see <a class="xref" href="#sidebar_curl" title="The curl utility">The <span class="emphasis"><em>curl</em></span> utility</a>) is good enough.
On a successful <span class="emphasis"><em>curl</em></span> request to the service</p><pre class="screen">% curl -v http://localhost:8080/predictions/</pre><p>the response includes not only the XML shown earlier in Example 5 but also a trace (thanks to the <span class="emphasis"><em>-v</em></span> flag)
of the HTTP request and response messages. The HTTP request is:</p><pre class="screen">GET /predictions/ HTTP/1.1
User-Agent: curl/7.19.7
Host: localhost:8080
Accept: */*</pre><p>The HTTP response start line and headers are:</p><pre class="screen">HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=96C78773C190884EDE76C714728164EC; Path=/test1/;
Content-Type: text/html;charset=ISO-8859-1
Transfer-Encoding: chunked</pre><p>Recall that an HTTP GET message has no body; hence, the entire message is the
start line and the headers. The response shows the session identifier (a 128-bit
statistically unique number, in hex, that Tomcat generates) in the header. In
the JSP script, the session identifier could be disabled as it is not needed; but,
for now, the goal is brevity and simplicity in the code.</p><div class="sidebar" title="The curl utility"><a id="sidebar_curl"></a><p class="title"><b>The <span class="emphasis"><em>curl</em></span> utility</b></p><p>The <span class="emphasis"><em>curl</em></span> utility (<span class="emphasis"><em>curl.haxx.se</em></span>) is a command-line tool for requesting data using URL syntax. The
tool supports a wide variety of protocols, including HTTP(S), SMTP, FTP(S), LDAP(S), and others.
The tool is available on Unixy systems and there is port for Windows. This tool is useful
for quick tests to determine whether a service is responding appropriately to requests.</p></div><p>If a POST request were sent to the RESTful predictions service</p><pre class="screen">% curl --request POST --data "foo=bar" http://localhost:8080/predictions/</pre><p>the request message header becomes:</p><pre class="screen">POST /predictions/ HTTP/1.1
User-Agent: curl/7.19.7
Host: localhost:8080
Accept: */*
Content-Length: 7
Content-Type: application/x-www-form-urlencoded</pre><p>The response header now is:</p><pre class="screen">HTTP/1.1 405 Method Not Allowed
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=34A013CDC5A9F9F8995A28E30CF31332; Path=/test1/;
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 1037</pre><p>The error message</p><pre class="screen">Only GET requests are allowed.</pre><p>is in an HTML document that makes up the response message’s body. Tomcat generates an HTML response
because my code does not (but could) stipulate a format other than HTML, the default Tomcat format for a Tomcat response.</p><p>This first example illustrates how a JSP script
is readily adapted to support web services in addition to
web sites. The next section goes into more detail on servlets and JSP
scripts. In summary, the <span class="emphasis"><em>predictions</em></span> web service is implemented as a JSP script with the two
back-end JavaBeans in support. This first example highlights key aspects of a REST-style service:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The service provides access to resource under the URI <span class="emphasis"><em>/predictions/</em></span>.
</li><li class="listitem">
The service filters access on the HTTP request verb. In this example, only GET requests are successful; any other type
of request generates a <span class="emphasis"><em>bad method</em></span> error.
</li><li class="listitem">
The service responds with an XML payload, which the consumer now must process in some appropriate way.
</li></ul></div></div></div><div class="section" title="1.10. Why Use Servlets for RESTful Web Services?"><div class="titlepage"><div><div><h3 class="title"><a id="_why_use_servlets_for_restful_web_services"></a>1.10. Why Use Servlets for RESTful Web Services?</h3></div></div></div><p>Chapter 2 explores various ways in which to implement and publish RESTful services in Java, which has a
rich set of built-in and third-party APIs.
The current chapter introduces a tried-and-true way to do RESTful services in Java: the service is implemented as a
JSP script, which a web server such as Tomcat or Jetty translates into a servlet; and the servlet then is
published with the web server.</p><p>An <code class="literal">HttpServlet</code> is a natural, convenient way to implement RESTful web services for two
main reasons. First, such servlets are close to the HTTP metal. For example,
the <code class="literal">HttpServlet</code> class has methods such as <code class="literal">doGet</code>, <code class="literal">doPost</code>, <code class="literal">doPut</code>, and
<code class="literal">doDelete</code> that match up with the HTTP verbs aligned with the CRUD operations. These
servlet methods execute as callbacks that the servlet container, explained shortly, invokes
as needed. The <code class="literal">HttpServlet</code> class also provides symbolic constants for HTTP status codes, for
example, <code class="literal">SC_NOT_FOUND</code> for status code 404 and <code class="literal">SC_METHOD_NOT_ALLOWED</code> for status
code 405. Each <code class="literal">HttpServlet</code> <span class="emphasis"><em>do</em></span>-method has the same two arguments:
an <code class="literal">HttpServletRequest</code> and an <code class="literal">HttpServletResponse</code>. The servlet request contains, as
key/value pairs, all of the appropriate information encapsulated in the HTTP request,
regardless of the request verb: for a GET request, the <code class="literal">HttpServletRequest</code> would include
any key/value pairs in a query string; for a POST request, this data structure would
include any key/value pairs in the POST request body.
The <code class="literal">HttpServletRequest</code> map is easy to read and, if needed, to update and to forward.
The <code class="literal">HttpServletResponse</code> has methods to adjust the HTTP response message as needed;
and this class encapsulates an output stream to communicate back to the
client.</p><p>A second major advantage of servlets is that they execute in a servlet container,
middleware that mediates between the application code of the servlet and
the web server that provides the usual types of support: wire-level security in the
form of HTTPS transport, user authentication and authorization, logging and
troubleshooting support, server configuration, local or remote database access,
naming services, application deployment and
administration, and so on. In the Tomcat web server, the servlet container is named
Catalina. Because the servlet container is such an integral part of a Java-based
web server, it is common to conflate the container name (Catalina) and the server
name (Tomcat), a practice followed here. (In Jetty, the server and the container have
the same name: <span class="emphasis"><em>Jetty</em></span>.) In any case, a Java-centric web server
such as Tomcat is the natural way to publish real-world web services, including
RESTful ones, written in Java. A servlet container typically houses several instances of
executing servlets, each awaiting client requests (see <a class="xref" href="#fig_servlet_container" title="Figure 2. A servlet container with servlet instances awaiting requests">Figure 2, “A servlet container with servlet instances awaiting requests”</a>).</p><div class="figure"><a id="fig_servlet_container"></a><p class="title"><b>Figure 2. A servlet container with servlet instances awaiting requests</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/jwsu_0402.png" alt="images/jwsu_0402.png" /></div></div></div><br class="figure-break" /><p>Here is a short, more technical review of servlets with emphasis on their use to
deliver RESTful services. The class <code class="literal">HttpServlet</code> extends
the class <code class="literal">GenericServlet</code>, which in turn implements the
<code class="literal">Servlet</code> interface. All three types are in a
that is not included in core Java. (Tomcat and Jetty provide
a JAR file <span class="emphasis"><em>servlet-api.jar</em></span> that contains the required package.) The
<code class="literal">Servlet</code> interface declares five methods, the most
important of which is the <code class="literal">service</code>  method that a web
container invokes on every request to a servlet. The
<code class="literal">service</code>  method has a  <code class="literal">ServletRequest</code> and a  <code class="literal">ServletResponse</code>  parameter. The request
is a map that contains the request information from a client and the response
provides a stream to send responses back to the client. The
<code class="literal">GenericServlet</code> class implements the <code class="literal">Servlet</code>  methods in a transport-neutral fashion, whereas
the <code class="literal">HttpServlet</code>  subclass of <code class="literal">GenericServlet</code> implements these methods in an
HTTP-specific way. Accordingly, the <code class="literal">service</code> parameters in the
<code class="literal">HttpServlet</code>  have the types <code class="literal">HttpServletRequest</code>  and
<code class="literal">HttpServletResponse</code>. The <code class="literal">HttpServlet</code> also provides request filtering that naturally
supports a REST-style service: in an <code class="literal">HttpServlet</code>, the overridden <code class="literal">service</code> method dispatches a incoming
GET request to the method <code class="literal">doGet</code>, an incoming POST
request to the method <code class="literal">doPost</code>, and so on. Because HTTP is the dominant transport for web sites and
web services, the <code class="literal">HttpServlet</code> is an excellent choice for implementing either.</p><p>In the  <code class="literal">HttpServlet</code>  class, the <span class="emphasis"><em>do</em></span>-methods such as <code class="literal">doGet</code> and <code class="literal">doPost</code> are defined as no-ops, that is,
as methods with empty
bodies; and these methods can be overridden as needed in a programmer-derived subclass.
For example, if the class  <code class="literal">MyServlet</code>  extends <code class="literal">HttpServlet</code>  and overrides  <code class="literal">doGet</code>  but
not <code class="literal">doPost</code> , then  <code class="literal">doPost</code> remains a no-op in <code class="literal">MyServlet</code> instances. A servlet programmer
overrides the <span class="emphasis"><em>do</em></span>-methods of interest and ignores the rest.</p><p>Servlets are written in Java and, therefore, have access to all of the Java libraries, standard and contributed.
JSP scripts, by contrast, are an arbitrary mix of HTML and code. In the case of web sites, JSP scripts typically serve
as a HTML templates and, under best practices, the major code segments involve references to back-end JavaBeans.
In the case of web services, by contrast,
JSP scripts would consist predominantly or even exclusively of code because service clients do not expect
HTML payloads as responses.
The advantage of a JSP script over an <code class="literal">HttpServlet</code> is that the programmer does not need to
compile a JSP script. The Java-aware web server assumes this responsibility.
A JSP script is deployed as a text file but executes as a servlet because the web server automatically
translates the script into an <code class="literal">HttpServlet</code> before loading one or more instances of the
resulting servlet into the servlet container. For short examples and for the kind of experimentation
typical of code development, JSP scripts are attractive. For deployment to production, the
Java code of a servlet would be best practice. Some of my shorter servlet-based examples use JSP scripts
but most of the examples use classes that explicitly extend <code class="literal">HttpServlet</code>.</p></div><div class="section" title="1.11. What’s Next?"><div class="titlepage"><div><div><h3 class="title"><a id="_what_8217_s_next"></a>1.11. What’s Next?</h3></div></div></div><p>RESTful services are rich enough to warrant two dedicated chapters. Accordingly, the
next chapter focuses on the service side by exploring options for implementing
and publishing RESTful services. The web service APIs include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">HttpServlet</code> and its equivalents (<span class="emphasis"><em>e.g.</em></span>, JSP scripts)
</li><li class="listitem">
JAX-RS, which has various implementations
</li><li class="listitem">
Restlet, which is similar in style to JAX-RS
</li><li class="listitem">
JAX-WS <code class="literal">@WebServiceProvider</code>, which is a relatively low-level API
</li></ul></div><p>Web services using any these APIs can be published with production-grade web server such as Tomcat or Jetty; and
there are even command-line options for such publication, although these options vary significantly in ease of use. There are
trade-offs among the APIs and the next chapter highlights the pluses and minuses of each API.</p><p>The servlet approach represents a base-level API in that servlets have been a part of Java
since the late 1990s and the remain the foundation for web sites written in Java. The servlet API is close to the HTTP metal in that, for example,
an <code class="literal">HttpServletRequest</code> is a thin but likewise convenient wrapper around an HTTP request; and, in similar fashion, an <code class="literal">HttpServletResponse</code>
is a thin and equally convenient wrapper around an HTTP response. At the same time, servlets provide high-level filtering of HTTP requests
and a data structure such as the <code class="literal">HttpServletRequest</code> collapses the distinction between the key/value pairs in a query string of a GET
or DELETE request and the key/value pairs in the body of a POST or PUT request: all such pairs occur, without distinction, in the
<code class="literal">HttpServletRequest</code> map. Servlets may seem old hat but they are a hat worth trying on for REST-style services. The remaining APIs build upon
what servlets offer and, in this sense, represent a layering on top of servlets.</p><p>JAX-RS and Restlet are roughly peers, although this comparison might stir heated denials from either camp.
Both of these APIs emphasize the use
of Java annotations to describe the RESTful access to a particular CRUD operation. For example, methods that handle GET requests are
annotated with <code class="literal">@GET</code> or <code class="literal">@Get</code>, those that handle POST requests are annotated with <code class="literal">@POST</code> or <code class="literal">@Post</code>, and so on. In both frameworks
there are symbolic constants to specify MIME types and status codes. Further, each framework supports the automated generation of
XML and JSON payloads. These frameworks have a contemporary look-and-feel; but each represents, at the implementation level,
a layer above the servlet layer. When published with a web server such as Tomcat or Jetty, JAX-RS and Restlet provide servlet
interceptors that mediate between the client and the web service. The details are explored in Chapter 2.</p><p>JAW-WS is an API used mostly for SOAP-based services but can be used for REST-style services as well. In the latter case, the
<code class="literal">@WebServiceProvider</code> annotation is central. The <code class="literal">@WebServiceProvider</code> interface is sufficiently flexible that it can be used
to annotate either a SOAP-based or a REST-style service; however, JAX-WS provides a related but higher-level annotation, <code class="literal">@WebService</code>,
for SOAP-based services. The <code class="literal">@WebServiceProvider</code> API is deliberately lower level than the servlet, JAX-RS, and Restlet APIs; and
the <code class="literal">@WebServiceProvider</code> API is targeted at XML-based services. For programmers who need a low-level API, Java supports
the <code class="literal">@WebServiceProvider</code> option. JAX-RS, Restlet, and <code class="literal">@WebServiceProvider</code> have both service-side and client-side
APIs that can be used independently of one another. For example, a Restlet client could make calls against a JAX-RS service or vice-versa.</p><p>In summary, Chapter 2 focuses on the server side of RESTful services.
Chapter 3 shifts the focus to the client or consumer side of such services. The chapter includes client code against commercial
RESTful services such as
Amazon, Twitter, and the Chicago Transit Authority. The chapter also focuses on how the standard JAX-B (Java API for XML-Binding)
packages and third-party libraries such as <code class="literal">XStream</code> can be put to
good use by the hiding the XML in the consumption of RESTful services. A dominant trend in contemporary web services is the
occurrence of JavaScript clients against RESTful services. Such clients may be written in JavaScript or a dialect such as jQuery. In any
case, these clients are usually embedded in HTML documents so that the clients execute in the context of a browser. JavaScript clients
in general prefer JSON over XML payloads for the obvious reason that a JSON document is the text representation of a
JavaScript object, even a JavaScript function. Chapter 3 also looks at various Java options for generating JSON as well
as XML and plain-text responses; and the chapter explores different ways in which JavaScript clients can process the
JSON payloads.</p></div></div></div></body></html>
